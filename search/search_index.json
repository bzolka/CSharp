{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C# alapok \u00b6 Ismertet\u0151k, fealdatok, p\u00e9ld\u00e1k C# megismer\u00e9s\u00e9hez \u00e9s gyakorl\u00e1s\u00e1hoz.","title":"C# alapok"},{"location":"#c-alapok","text":"Ismertet\u0151k, fealdatok, p\u00e9ld\u00e1k C# megismer\u00e9s\u00e9hez \u00e9s gyakorl\u00e1s\u00e1hoz.","title":"C# alapok"},{"location":"Linq/Linq-attekinto/","text":"LINQ - \u00e1ttekint\u0151 \u00b6 A legfontosabbak parancsok, ',' ut\u00e1n az l\u00e1that\u00f3, mi az adott m\u0171veletn\u00e9l a param\u00e9ter, amit megkapunk: Where: sz\u0171r\u00e9s, elem Select: elemek lek\u00e9pez\u00e9se m\u00e1s elemre, elem OrderBy: sorrendez\u00e9s, elem GroupBy: csoportos\u00edt\u00e1s, csoport","title":"LINQ - \u00e1ttekint\u0151"},{"location":"Linq/Linq-attekinto/#linq-attekinto","text":"A legfontosabbak parancsok, ',' ut\u00e1n az l\u00e1that\u00f3, mi az adott m\u0171veletn\u00e9l a param\u00e9ter, amit megkapunk: Where: sz\u0171r\u00e9s, elem Select: elemek lek\u00e9pez\u00e9se m\u00e1s elemre, elem OrderBy: sorrendez\u00e9s, elem GroupBy: csoportos\u00edt\u00e1s, csoport","title":"LINQ - \u00e1ttekint\u0151"},{"location":"Linq/Linq-csoportositas-feladatok/","text":"LINQ - feladatok \u00b6 Ir\u00e1nyelvek: Pr\u00f3b\u00e1ld is ki a megold\u00e1sod! A feladat sz\u00f6veg\u00e9t \u00edrd a megold\u00e1sod f\u00f6l\u00e9 egy megjegyz\u00e9sben az el\u0151z\u0151 feladatot megold\u00e1s\u00e1t \u00edrd \u00e1t, ahogy haladsz, hanem legyen meg mind k\u00fcl\u00f6n! Kiindul\u00e1s \u00b6 Az al\u00e1bbi oszt\u00e1lyt haszn\u00e1ld a feladatok megold\u00e1sa sor\u00e1n: class Szinesz { public int Szulev ; public string Nev ; // Ne adjuk \u00e1t a sz\u00fcl. \u00e9v\u00e9t, mert m\u00e1r megvan tagv\u00e1ltoz\u00f3ban! public int EletkorSzamolo () { return DateTime . Now . Year - szulev ; } public Szinesz ( int szulev , string nev ) { this . szulev = szulev ; this . nev = nev ; } } Feladat 1 \u00b6 B\u0151v\u00edtsd ki a Szinesz oszt\u00e1lyt, minden sz\u00edn\u00e9sznek legyen egy \u00faj tulajdons\u00e1ga, egy string orszag, ahol sz\u00fcletett. Feladat 2 \u00b6 \u00cdrj egy f\u00fcggv\u00e9nyt (ha m\u00e9g nincs), amelyik el\u0151\u00e1ll\u00edt \u00e9s visszaad egy t\u00f6mbben 6 sz\u00edn\u00e9szt. Mindenkinek m\u00e1s a neve; 1 sz\u00edn\u00e9sz sz\u00fclessen 1975-ben, 2 1998-ban, 3 1980-ban; 1 sz\u00fclet\u00e9si helye Spanyolorsz\u00e1g, 2 USA, 3 Kanada. A t\u00f6mb\u00f6t inicializ\u00e1l\u00e1ssal hozd l\u00e9tre, ha lehet, vagyis az elemeket a l\u00e9trehoz\u00e1skor {} k\u00f6z\u00f6tt add meg, ahogy egyszer mutattam. Ezt a f\u00fcggv\u00e9nyt a k\u00e9s\u0151bb arra haszn\u00e1ljuk, hogy a LINQ lek\u00e9rdez\u00e9sekhez visszaadja a 6 tesztadatot. Feladat 3 \u00b6 a) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szeket egy t\u00f6mbben, akik 1990 ut\u00e1n sz\u00fclettek b) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szek neveit egy list\u00e1ban, akik 1990 ut\u00e1n sz\u00fclettek. c) \u00c1ll\u00edts el\u0151 egyetlen sztringet, mely vessz\u0151vel elv\u00e1lasztva azon sz\u00edn\u00e9szek sz\u00fclet\u00e9si \u00e9v\u00e9t tartalmazza (egyetlen sztringben), akik 1990 ut\u00e1n sz\u00fclettek. Feladat 4 - csoportos\u00edt\u00e1sok \u00b6 a) Egyszer\u0171 csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben a sz\u00fclet\u00e9si helyek szerepelnek (minden csoportra egyszer). Ezt k\u00f6vet\u0151en \u00edrd ki, vessz\u0151vel elv\u00e1lasztva ezen sz\u00fclet\u00e9si helyeket (ezt a ki\u00edr\u00e1st egyetlen sorban oldd meg)! Magyar\u00e1zat : Tfh van 6 sz\u00edn\u00e9sz, sz1, sz2, \u2026sz6. A szineszek.GroupBy(sz => sz.Orszag) ut\u00e1n, ha orsz\u00e1g szerint csoportos\u00edtunk, 3 sz\u00edn\u00e9sz csoport lesz: Csop1: Key: Spanyolorsz\u00e1g Elemek: [sz1] Csop2: Key: USA Elemek: [sz2, sz3] Csop3: Key: Kanada Elemek: [sz4, sz5, sz6] L\u00e9nyeges: minden csoporthoz egy kulcs tartozik (az orsz\u00e1g, mert eszerint csoportos\u00edtottunk), \u00e9s egy gy\u0171jtem\u00e9ny a csoportban lev\u0151 sz\u00edn\u00e9szekr\u0151l (mert sz\u00edn\u00e9szekre h\u00edvtuk a GroupBy-t) b) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: sz\u00edn\u00e9szek t\u00f6mbje \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben az egyes csoportokban lev\u0151 sz\u00edn\u00e9szek tal\u00e1lhat\u00f3k. Ezt pr\u00f3b\u00e1lt elk\u00e9pzelni magadt\u00f3l, \u00e9s csak ut\u00e1na olvass tov\u00e1bb, mert itt kicsit s\u00fagni fogok\u2026 Vagyis a t\u00f6mb els\u0151 eleme az els\u0151 csoport sz\u00edn\u00e9szeit tartalmazza egy t\u00f6mbben, a m\u00e1sodik eleme a m\u00e1sodik csoport szineszeit tartalmazza egy t\u00f6mbben, \u00e9s \u00edgy tov\u00e1bb. Vagyis a kimenet egy olyan t\u00f6mb lesz, melynek az elemi szin\u00e9sz t\u00f6mb\u00f6k. Nincs ebben semmi var\u00e1zslat: t\u00f6mb eleme b\u00e1rmi lehet, sz\u00e1m, string, oszt\u00e1ly, vagy ak\u00e1r mint eset\u00fcnkben is, m\u00e1sik t\u00f6mb is: Kb. ilyesmik\u00e9nt kell elk\u00e9pzelni: [ [sz1, sz2], [sz3, sz5, sz6], [sz7] ]. Ez olyan t\u00f6mb, melynek elemei t\u00f6mb\u00f6k, t\u00f6mb\u00f6k t\u00f6mbj\u00e9nek is szoktuk mondani. c) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: sz\u00edn\u00e9szek neve vessz\u0151vel elv\u00e1lasztva \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, mely elemei a csoportban lev\u0151 sz\u00edn\u00e9szek neveit tartalmazz\u00e1k, vessz\u0151vel elv\u00e1lasztva. El\u0151sz\u00f6r pr\u00f3b\u00e1ld ezt magadt\u00f3l elk\u00e9pzelni, csak ut\u00e1na olvasd tov\u00e1bb, s\u00fagok \u2026 A t\u00f6mb elemei itt most stringek, ilyesmi kimenetet v\u00e1runk, h\u00e1rom elem\u0171 string t\u00f6mb\u00f6t: [\"B\u00e9la, J\u00f3zsi\", \"Jani, Juli, G\u00e9za\", \"Misi\" ] d) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00b6 Hasonl\u00f3, mint a b) volt, vagyis most is sz\u00fclet\u00e9si hely szerint csoportos\u00edtunk. A b)-n\u00e9l, ha megn\u00e9zed, megvolt a kimenetben a h\u00e1rom csoport, mert a kimenet h\u00e1rom elem\u0171 t\u00f6mb volt, de nem tudtuk, melyik t\u00f6mb elem/csoport melyik orsz\u00e1ghoz tartozott. Pl. a kimeneti t\u00f6mb nulladik elem\u00e9ben volt k\u00e9t sz\u00edn\u00e9sz, de nem tudtuk megmondani, mely orsz\u00e1g csoportj\u00e1ba tartoztak . Ezt fontos lenne, hogy \u00e9rtsd, ha nem, besz\u00e9lj\u00fck meg! Mindenesetre ez \u00edgy sokszor nem szerencs\u00e9s. A c\u00e9l az, hogy a kimenetben azt is tudjuk, mely csoporthoz tartoznak az elemek (eset\u00fcnkben mely orsz\u00e1ghoz). Ezt t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet oldani. Picit gondolkozz azon, van-e \u00f6tleted\u2026 Meg lehet oldani KeyValuePair haszn\u00e1lat\u00e1val is, de az a k\u00f6vetkez\u0151 feladat lesz, most m\u00e9g hagyjuk. Els\u0151 k\u00f6rben egy \u201enyersebb\u201d megold\u00e1st n\u00e9z\u00fcnk, mert az sokszor \u00e1ltal\u00e1nosabb \u00e9s jobban haszn\u00e1lhat\u00f3, csak egy kicsit munk\u00e1sabb. A megold\u00e1s alapelve az, hogy bevezet\u00fcnk egy \u00faj oszt\u00e1ly, mely a kimenet egy csoportj\u00e1t (ami a t\u00f6mb egy eleme) fogja reprezent\u00e1lni. Mire is van sz\u00fcks\u00e9g minden egyes csoportn\u00e1l: az orsz\u00e1gn\u00e9vre, illetve hozz\u00e1 tartoz\u00f3 szin\u00e9szek t\u00f6mbj\u00e9re. vagyis egy ilyen oszt\u00e1lyt kell bevezetni: class SzineszCsoport { public string Orszag ; public Szinesz [] Szineszek ; < \u00cdrj m\u00e9g egy konstruktort , minek van k\u00e9t param\u00e9tere , az orsz\u00e1g \u00e9s a szineszek , erre sz\u00fcks\u00e9g lesz > } Ha ez megvan, akkor hasonl\u00f3an kell dolgozni, mint a b)-n\u00e9l, csak a Select-ben a csoportokat nem Szinesz t\u00f6mbre, hanem SzineszCsoport oszt\u00e1lyra kell lepezni, egy ilyet kell a new-val l\u00e9trehozni. Egy picit pr\u00f3b\u00e1lkozz, \u00e9s besz\u00e9lj\u00fck meg, ebben sokminden volt. e) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00e9letkora vessz\u0151vel elv\u00e1lasztva \u00b6 Ugyanaz, mint az el\u0151z\u0151, csak a kimenetben az orsz\u00e1gokhoz nem a szin\u00e9szek t\u00f6mbj\u00e9t, hanem a sz\u00edn\u00e9szek \u00e9letkor\u00e1nak vessz\u0151vel \u00f6sszef\u0171z\u00f6tt \u00e9vsz\u00e1m\u00e1t szeretn\u00e9nk l\u00e1tni. Tipp: vezess be egy SzineszCsoportEvekkel oszt\u00e1lyt, ebben a string Orszag mellett nem szinesz t\u00f6mb, hanem string evek legyen. f) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek, de most a be\u00e9p\u00edtett KeyValuePair-rel \u00b6 Hasonl\u00f3, mint a d) el\u0151z\u0151, csak itt nem akarunk \u00faj oszt\u00e1lyt (SzineszCsoport oszt\u00e1ly) bevezetni. De a c\u00e9lunk ugyanaz, vagyis legyen meg minden csoportra az orsz\u00e1g is, valamint a benne lev\u0151 sz\u00edn\u00e9szek is. A megold\u00e1s elve az, hogy nem vezet\u00fcnk be SzineszCsoport oszt\u00e1lyt, hanem helyette a be\u00e9p\u00edtett KeyValuePair-t haszn\u00e1ljuk. Minden csoportn\u00e1l a kulcs (vagyis a Key) az orsz\u00e1g, hiszen eszerint csoportos\u00edtunk, a Value, a kulcshoz tartoz\u00f3 \u00e9rt\u00e9k pedig \u2026 ezt pr\u00f3b\u00e1ld kital\u00e1lni, hogy \u00e9rdemes. g) Csoportos\u00edt\u00e1s sz\u00edn\u00e9szn\u00e9v kezd\u0151bet\u0171 alapj\u00e1n, sorrendezve \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket aszerint, hogy milyen bet\u0171vel kezd\u0151dik a nev\u00fck. KeyValuePair-rel dolgozz. Az egyes csoportokban ne a csoportban lev\u0151 sz\u00edn\u00e9szeket, hanem a csoportban lev\u0151 sz\u00edn\u00e9szek neveit c\u00edmeit t\u00e1rold t\u00f6mbben. A kimenet legyen sorrendezve a n\u00e9v kezd\u0151bet\u0171 alapj\u00e1n!","title":"LINQ - feladatok"},{"location":"Linq/Linq-csoportositas-feladatok/#linq-feladatok","text":"Ir\u00e1nyelvek: Pr\u00f3b\u00e1ld is ki a megold\u00e1sod! A feladat sz\u00f6veg\u00e9t \u00edrd a megold\u00e1sod f\u00f6l\u00e9 egy megjegyz\u00e9sben az el\u0151z\u0151 feladatot megold\u00e1s\u00e1t \u00edrd \u00e1t, ahogy haladsz, hanem legyen meg mind k\u00fcl\u00f6n!","title":"LINQ - feladatok"},{"location":"Linq/Linq-csoportositas-feladatok/#kiindulas","text":"Az al\u00e1bbi oszt\u00e1lyt haszn\u00e1ld a feladatok megold\u00e1sa sor\u00e1n: class Szinesz { public int Szulev ; public string Nev ; // Ne adjuk \u00e1t a sz\u00fcl. \u00e9v\u00e9t, mert m\u00e1r megvan tagv\u00e1ltoz\u00f3ban! public int EletkorSzamolo () { return DateTime . Now . Year - szulev ; } public Szinesz ( int szulev , string nev ) { this . szulev = szulev ; this . nev = nev ; } }","title":"Kiindul\u00e1s"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-1","text":"B\u0151v\u00edtsd ki a Szinesz oszt\u00e1lyt, minden sz\u00edn\u00e9sznek legyen egy \u00faj tulajdons\u00e1ga, egy string orszag, ahol sz\u00fcletett.","title":"Feladat 1"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-2","text":"\u00cdrj egy f\u00fcggv\u00e9nyt (ha m\u00e9g nincs), amelyik el\u0151\u00e1ll\u00edt \u00e9s visszaad egy t\u00f6mbben 6 sz\u00edn\u00e9szt. Mindenkinek m\u00e1s a neve; 1 sz\u00edn\u00e9sz sz\u00fclessen 1975-ben, 2 1998-ban, 3 1980-ban; 1 sz\u00fclet\u00e9si helye Spanyolorsz\u00e1g, 2 USA, 3 Kanada. A t\u00f6mb\u00f6t inicializ\u00e1l\u00e1ssal hozd l\u00e9tre, ha lehet, vagyis az elemeket a l\u00e9trehoz\u00e1skor {} k\u00f6z\u00f6tt add meg, ahogy egyszer mutattam. Ezt a f\u00fcggv\u00e9nyt a k\u00e9s\u0151bb arra haszn\u00e1ljuk, hogy a LINQ lek\u00e9rdez\u00e9sekhez visszaadja a 6 tesztadatot.","title":"Feladat 2"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-3","text":"a) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szeket egy t\u00f6mbben, akik 1990 ut\u00e1n sz\u00fclettek b) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szek neveit egy list\u00e1ban, akik 1990 ut\u00e1n sz\u00fclettek. c) \u00c1ll\u00edts el\u0151 egyetlen sztringet, mely vessz\u0151vel elv\u00e1lasztva azon sz\u00edn\u00e9szek sz\u00fclet\u00e9si \u00e9v\u00e9t tartalmazza (egyetlen sztringben), akik 1990 ut\u00e1n sz\u00fclettek.","title":"Feladat 3"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-4-csoportositasok","text":"","title":"Feladat 4 - csoportos\u00edt\u00e1sok"},{"location":"Linq/Linq-csoportositas-feladatok/#a-egyszeru-csoportositas-szuletesi-hely-szerint","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben a sz\u00fclet\u00e9si helyek szerepelnek (minden csoportra egyszer). Ezt k\u00f6vet\u0151en \u00edrd ki, vessz\u0151vel elv\u00e1lasztva ezen sz\u00fclet\u00e9si helyeket (ezt a ki\u00edr\u00e1st egyetlen sorban oldd meg)! Magyar\u00e1zat : Tfh van 6 sz\u00edn\u00e9sz, sz1, sz2, \u2026sz6. A szineszek.GroupBy(sz => sz.Orszag) ut\u00e1n, ha orsz\u00e1g szerint csoportos\u00edtunk, 3 sz\u00edn\u00e9sz csoport lesz: Csop1: Key: Spanyolorsz\u00e1g Elemek: [sz1] Csop2: Key: USA Elemek: [sz2, sz3] Csop3: Key: Kanada Elemek: [sz4, sz5, sz6] L\u00e9nyeges: minden csoporthoz egy kulcs tartozik (az orsz\u00e1g, mert eszerint csoportos\u00edtottunk), \u00e9s egy gy\u0171jtem\u00e9ny a csoportban lev\u0151 sz\u00edn\u00e9szekr\u0151l (mert sz\u00edn\u00e9szekre h\u00edvtuk a GroupBy-t)","title":"a) Egyszer\u0171 csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint"},{"location":"Linq/Linq-csoportositas-feladatok/#b-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-szineszek-tombje","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben az egyes csoportokban lev\u0151 sz\u00edn\u00e9szek tal\u00e1lhat\u00f3k. Ezt pr\u00f3b\u00e1lt elk\u00e9pzelni magadt\u00f3l, \u00e9s csak ut\u00e1na olvass tov\u00e1bb, mert itt kicsit s\u00fagni fogok\u2026 Vagyis a t\u00f6mb els\u0151 eleme az els\u0151 csoport sz\u00edn\u00e9szeit tartalmazza egy t\u00f6mbben, a m\u00e1sodik eleme a m\u00e1sodik csoport szineszeit tartalmazza egy t\u00f6mbben, \u00e9s \u00edgy tov\u00e1bb. Vagyis a kimenet egy olyan t\u00f6mb lesz, melynek az elemi szin\u00e9sz t\u00f6mb\u00f6k. Nincs ebben semmi var\u00e1zslat: t\u00f6mb eleme b\u00e1rmi lehet, sz\u00e1m, string, oszt\u00e1ly, vagy ak\u00e1r mint eset\u00fcnkben is, m\u00e1sik t\u00f6mb is: Kb. ilyesmik\u00e9nt kell elk\u00e9pzelni: [ [sz1, sz2], [sz3, sz5, sz6], [sz7] ]. Ez olyan t\u00f6mb, melynek elemei t\u00f6mb\u00f6k, t\u00f6mb\u00f6k t\u00f6mbj\u00e9nek is szoktuk mondani.","title":"b) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: sz\u00edn\u00e9szek t\u00f6mbje"},{"location":"Linq/Linq-csoportositas-feladatok/#c-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-szineszek-neve-vesszovel-elvalasztva","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, mely elemei a csoportban lev\u0151 sz\u00edn\u00e9szek neveit tartalmazz\u00e1k, vessz\u0151vel elv\u00e1lasztva. El\u0151sz\u00f6r pr\u00f3b\u00e1ld ezt magadt\u00f3l elk\u00e9pzelni, csak ut\u00e1na olvasd tov\u00e1bb, s\u00fagok \u2026 A t\u00f6mb elemei itt most stringek, ilyesmi kimenetet v\u00e1runk, h\u00e1rom elem\u0171 string t\u00f6mb\u00f6t: [\"B\u00e9la, J\u00f3zsi\", \"Jani, Juli, G\u00e9za\", \"Misi\" ]","title":"c) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: sz\u00edn\u00e9szek neve vessz\u0151vel elv\u00e1lasztva"},{"location":"Linq/Linq-csoportositas-feladatok/#d-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek","text":"Hasonl\u00f3, mint a b) volt, vagyis most is sz\u00fclet\u00e9si hely szerint csoportos\u00edtunk. A b)-n\u00e9l, ha megn\u00e9zed, megvolt a kimenetben a h\u00e1rom csoport, mert a kimenet h\u00e1rom elem\u0171 t\u00f6mb volt, de nem tudtuk, melyik t\u00f6mb elem/csoport melyik orsz\u00e1ghoz tartozott. Pl. a kimeneti t\u00f6mb nulladik elem\u00e9ben volt k\u00e9t sz\u00edn\u00e9sz, de nem tudtuk megmondani, mely orsz\u00e1g csoportj\u00e1ba tartoztak . Ezt fontos lenne, hogy \u00e9rtsd, ha nem, besz\u00e9lj\u00fck meg! Mindenesetre ez \u00edgy sokszor nem szerencs\u00e9s. A c\u00e9l az, hogy a kimenetben azt is tudjuk, mely csoporthoz tartoznak az elemek (eset\u00fcnkben mely orsz\u00e1ghoz). Ezt t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet oldani. Picit gondolkozz azon, van-e \u00f6tleted\u2026 Meg lehet oldani KeyValuePair haszn\u00e1lat\u00e1val is, de az a k\u00f6vetkez\u0151 feladat lesz, most m\u00e9g hagyjuk. Els\u0151 k\u00f6rben egy \u201enyersebb\u201d megold\u00e1st n\u00e9z\u00fcnk, mert az sokszor \u00e1ltal\u00e1nosabb \u00e9s jobban haszn\u00e1lhat\u00f3, csak egy kicsit munk\u00e1sabb. A megold\u00e1s alapelve az, hogy bevezet\u00fcnk egy \u00faj oszt\u00e1ly, mely a kimenet egy csoportj\u00e1t (ami a t\u00f6mb egy eleme) fogja reprezent\u00e1lni. Mire is van sz\u00fcks\u00e9g minden egyes csoportn\u00e1l: az orsz\u00e1gn\u00e9vre, illetve hozz\u00e1 tartoz\u00f3 szin\u00e9szek t\u00f6mbj\u00e9re. vagyis egy ilyen oszt\u00e1lyt kell bevezetni: class SzineszCsoport { public string Orszag ; public Szinesz [] Szineszek ; < \u00cdrj m\u00e9g egy konstruktort , minek van k\u00e9t param\u00e9tere , az orsz\u00e1g \u00e9s a szineszek , erre sz\u00fcks\u00e9g lesz > } Ha ez megvan, akkor hasonl\u00f3an kell dolgozni, mint a b)-n\u00e9l, csak a Select-ben a csoportokat nem Szinesz t\u00f6mbre, hanem SzineszCsoport oszt\u00e1lyra kell lepezni, egy ilyet kell a new-val l\u00e9trehozni. Egy picit pr\u00f3b\u00e1lkozz, \u00e9s besz\u00e9lj\u00fck meg, ebben sokminden volt.","title":"d) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek"},{"location":"Linq/Linq-csoportositas-feladatok/#e-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek-eletkora-vesszovel-elvalasztva","text":"Ugyanaz, mint az el\u0151z\u0151, csak a kimenetben az orsz\u00e1gokhoz nem a szin\u00e9szek t\u00f6mbj\u00e9t, hanem a sz\u00edn\u00e9szek \u00e9letkor\u00e1nak vessz\u0151vel \u00f6sszef\u0171z\u00f6tt \u00e9vsz\u00e1m\u00e1t szeretn\u00e9nk l\u00e1tni. Tipp: vezess be egy SzineszCsoportEvekkel oszt\u00e1lyt, ebben a string Orszag mellett nem szinesz t\u00f6mb, hanem string evek legyen.","title":"e) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00e9letkora vessz\u0151vel elv\u00e1lasztva"},{"location":"Linq/Linq-csoportositas-feladatok/#f-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek-de-most-a-beepitett-keyvaluepair-rel","text":"Hasonl\u00f3, mint a d) el\u0151z\u0151, csak itt nem akarunk \u00faj oszt\u00e1lyt (SzineszCsoport oszt\u00e1ly) bevezetni. De a c\u00e9lunk ugyanaz, vagyis legyen meg minden csoportra az orsz\u00e1g is, valamint a benne lev\u0151 sz\u00edn\u00e9szek is. A megold\u00e1s elve az, hogy nem vezet\u00fcnk be SzineszCsoport oszt\u00e1lyt, hanem helyette a be\u00e9p\u00edtett KeyValuePair-t haszn\u00e1ljuk. Minden csoportn\u00e1l a kulcs (vagyis a Key) az orsz\u00e1g, hiszen eszerint csoportos\u00edtunk, a Value, a kulcshoz tartoz\u00f3 \u00e9rt\u00e9k pedig \u2026 ezt pr\u00f3b\u00e1ld kital\u00e1lni, hogy \u00e9rdemes.","title":"f) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek, de most a be\u00e9p\u00edtett KeyValuePair-rel"},{"location":"Linq/Linq-csoportositas-feladatok/#g-csoportositas-szinesznev-kezdobetu-alapjan-sorrendezve","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket aszerint, hogy milyen bet\u0171vel kezd\u0151dik a nev\u00fck. KeyValuePair-rel dolgozz. Az egyes csoportokban ne a csoportban lev\u0151 sz\u00edn\u00e9szeket, hanem a csoportban lev\u0151 sz\u00edn\u00e9szek neveit c\u00edmeit t\u00e1rold t\u00f6mbben. A kimenet legyen sorrendezve a n\u00e9v kezd\u0151bet\u0171 alapj\u00e1n!","title":"g) Csoportos\u00edt\u00e1s sz\u00edn\u00e9szn\u00e9v kezd\u0151bet\u0171 alapj\u00e1n, sorrendezve"},{"location":"Static/static-feladatok/","text":"Statikus tagok - feladatok \u00b6 Feladat 1 \u00b6 \u00cdrj egy Matek oszt\u00e1lyt, melynek van egy Osszead \u00e9s Kivon m\u0171velete (melyek visszat\u00e9rnek k\u00e9t eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9vel, ill. k\u00fcl\u00f6nbs\u00e9g\u00e9vel). A Matek oszt\u00e1lyt k\u00e9nyelmesen lehessen haszn\u00e1lni, ne kelljen ehhez objektumokat a new-val l\u00e9trehozni. Mutass p\u00e9ld\u00e1kat a k\u00e9r m\u0171velet haszn\u00e1lat\u00e1ra. Feladat 2 \u00b6 \u00cdrj egy Bomba oszt\u00e1lyt. Minden bomb\u00e1r\u00f3l r\u00e1tolni kell a robban\u00f3erej\u00e9t (int) \u00e9s fel felrobbant-e (bool). Egy bomb\u00e1t felrobbantan a Robban m\u0171velet\u00e9vel lehet, ez a felrobbant \u00e1llapot\u00e1t igazba teszi. Az alkalmaz\u00e1sban lek\u00e9rdezhet\u0151v\u00e9 kell tenni, hogy \u00f6sszesen h\u00e1ny bomba robbant fel! Ennek nyilv\u00e1ntart\u00e1s\u00e1t/lek\u00e9rdezhet\u0151s\u00e9g\u00e9t r\u00e1 lehetne b\u00edzni egy k\u00fcl\u00f6n oszt\u00e1lyba, de a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9p\u00edtsd be mag\u00e1ba a Bomba oszt\u00e1lyba. A megold\u00e1sod teszteld a Main f\u00fcggv\u00e9nyben: hozz l\u00e9tre p\u00e1r bomb\u00e1t, robbantsd fel \u00e9s p\u00e1r helyen \u00edrd ki a felrobbant bomb\u00e1k darabsz\u00e1m\u00e1t!","title":"Statikus tagok - feladatok"},{"location":"Static/static-feladatok/#statikus-tagok-feladatok","text":"","title":"Statikus tagok - feladatok"},{"location":"Static/static-feladatok/#feladat-1","text":"\u00cdrj egy Matek oszt\u00e1lyt, melynek van egy Osszead \u00e9s Kivon m\u0171velete (melyek visszat\u00e9rnek k\u00e9t eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9vel, ill. k\u00fcl\u00f6nbs\u00e9g\u00e9vel). A Matek oszt\u00e1lyt k\u00e9nyelmesen lehessen haszn\u00e1lni, ne kelljen ehhez objektumokat a new-val l\u00e9trehozni. Mutass p\u00e9ld\u00e1kat a k\u00e9r m\u0171velet haszn\u00e1lat\u00e1ra.","title":"Feladat 1"},{"location":"Static/static-feladatok/#feladat-2","text":"\u00cdrj egy Bomba oszt\u00e1lyt. Minden bomb\u00e1r\u00f3l r\u00e1tolni kell a robban\u00f3erej\u00e9t (int) \u00e9s fel felrobbant-e (bool). Egy bomb\u00e1t felrobbantan a Robban m\u0171velet\u00e9vel lehet, ez a felrobbant \u00e1llapot\u00e1t igazba teszi. Az alkalmaz\u00e1sban lek\u00e9rdezhet\u0151v\u00e9 kell tenni, hogy \u00f6sszesen h\u00e1ny bomba robbant fel! Ennek nyilv\u00e1ntart\u00e1s\u00e1t/lek\u00e9rdezhet\u0151s\u00e9g\u00e9t r\u00e1 lehetne b\u00edzni egy k\u00fcl\u00f6n oszt\u00e1lyba, de a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9p\u00edtsd be mag\u00e1ba a Bomba oszt\u00e1lyba. A megold\u00e1sod teszteld a Main f\u00fcggv\u00e9nyben: hozz l\u00e9tre p\u00e1r bomb\u00e1t, robbantsd fel \u00e9s p\u00e1r helyen \u00edrd ki a felrobbant bomb\u00e1k darabsz\u00e1m\u00e1t!","title":"Feladat 2"},{"location":"Static/static/","text":"Statikus tagok \u00b6 Induljunk ki egy olyan oszt\u00e1lyb\u00f3l, melynek van k\u00e9t k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3ja \u00e9s tagf\u00fcggv\u00e9nye (m\u0171velete): class Teglalap { public double Szelesseg ; public double Magassag ; public double Terulet () { return Szelesseg * Magassag ; } } Az al\u00e1bbiakban l\u00e9trehozuk a Teglalap oszt\u00e1lyb\u00f3l k\u00e9t egym\u00e1st\u00f3l f\u00fcggetlen t1 \u00e9s t2 nev\u0171 t\u00e9glalap objektumot, elt\u00e9r\u0151 sz\u00e9less\u00e9g \u00e9s magass\u00e1g \u00e9rt\u00e9kekkel, majd ki\u00edrjuk ezek ter\u00fclet\u00e9t a konzolra. static void Main ( string [] args ) { Teglalap t1 = new Teglalap (); // #1 t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet () ); Teglalap t2 = new Teglalap (); // #2 t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagv\u00e1ltoz\u00f3 \u00b6 A feladat legyen a k\u00f6vetkez\u0151. Tartsuk nyilv\u00e1n egy sz\u00e1ml\u00e1l\u00f3ban, hogy h\u00e1ny objektumot hoztunk l\u00e9tre a Teglalap oszt\u00e1lyb\u00f3l. Ha b\u00e1rhol a programban l\u00e9trehozunk egy \u00faj Teglalap objektumot, akkor ennek a sz\u00e1ml\u00e1l\u00f3nak eggyel n\u0151nie kell. A fenti Main f\u00fcggv\u00e9ny p\u00e9ld\u00e1t n\u00e9zve, am\u00edg a // #1 megjegyz\u00e9ssel ell\u00e1tott sorban az objektumot nem hoztuk l\u00e9tre, addig a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ke 0, ezt k\u00f6vet\u0151en 1, majd a // #2 sor ut\u00e1n 2 kell legyen. Egy nagy, komplex alkalmaz\u00e1sban sok ezer helyen hozhatunk l\u00e9tre Teglalap objektumot, nem akarunk minden helyen sz\u00e1ml\u00e1l\u00f3t n\u00f6velni, csak egy k\u00f6zponti helyen. \u00cdgy tegy\u00fck bele ezt a sz\u00e1ml\u00e1l\u00f3t mag\u00e1ba a Teglalap oszt\u00e1lyba, \u00e9s n\u00f6velj\u00fck annak konstruktor\u00e1ban, hiszen a konstruktor pont akkor h\u00edv\u00f3dik, amikor egy \u00faj objektum l\u00e9trej\u00f6n: class Teglalap { public double Szelesseg ; public double Magassag ; public int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Ez \u00edgy m\u00e9g nem lesz j\u00f3. A probl\u00e9ma az, hogy a Szamlalo egy k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3, minden t\u00e9glalap objektumhoz k\u00fcl\u00f6n \u00e9rt\u00e9ke lesz 0 kezd\u0151\u00e9rt\u00e9kkel (a fenti p\u00e9ld\u00e1nkban a t1 \u00e9s t2 objektumokn\u00e1l k\u00fcl\u00f6n-k\u00fcl\u00f6n), pont \u00fagy, mint a Szelesseg \u00e9s Magassag tagv\u00e1ltoz\u00f3k eset\u00e9n. Ehelyett nek\u00fcnk egy olyan v\u00e1ltoz\u00f3 kell, ami nem Teglalap objektumonk\u00e9nt van, hanem minden Teglalap objektumra k\u00f6z\u00f6s, mag\u00e1hoz az oszt\u00e1lyhoz tartozik egyetlen \u00e9rt\u00e9k, \u00e9s m\u00e1r akkor is l\u00e9tezik, amikor m\u00e9g egyetlen objektumot sem hoztunk l\u00e9tre (ekkor az \u00e9rt\u00e9ke eset\u00fcnkben 0). Ehhez a Szamlalo tagot statikuss\u00e1 kell tenni, el\u00e9 kell \u00edrni a static kulcssz\u00f3t: class Teglalap { public double Szelesseg ; public double Magassag ; public static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } \u00cdgy a Szamlalo m\u00e1r az oszt\u00e1lyhoz tartozik (nem objektumonk\u00e9nt foglal\u00f3dik neki t\u00e1rhely), minden objektum\u00e1ra k\u00f6z\u00f6s, \u00e9s akkor is l\u00e9terzik, ha m\u00e9g egy Teglalap objektumot sem hoztunk l\u00e9tre. Az ilyen v\u00e1ltoz\u00f3k el\u00e9r\u00e9s\u00e9hez nem kell objektumot l\u00e9trehozni, hanem az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rj\u00fck el a \".\"-tal, a p\u00e9ld\u00e1nkban \u00edgy: Teglalap.Szamlalo A teljes p\u00e9lda, mely ki is \u00edrja t\u00f6bb helyen is a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t. static void Main ( string [] args ) { int teglalapokSzama = Teglalap . Szamlalo ; Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcgg\u00e9ny \u00b6 A megold\u00e1sunk m\u00e9g nem t\u00f6k\u00e9letes. A Szamlalo tag publikus a Teglalap oszt\u00e1lyban. \u00cdgy b\u00e1rhol valaki v\u00e9letlen vagy sz\u00e1nd\u00e9skosan elronthatja a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t, pl. ki tudja null\u00e1zni az al\u00e1bbis sorral, akkor is, ha m\u00e1r volt bel\u0151le objektum, \u00edgy \u00e9rt\u00e9ke hamis lesz: Teglalap.Szamlalo = 0; Ezt \u00fagy tudjuk megakad\u00e1lyozni, hogy a Szamlalo -t a Teglalap oszt\u00e1lyban v\u00e9dett\u00e9, priv\u00e1tt\u00e1 tessz\u00fck, ekkor ha m\u00e1s oszt\u00e1lyban pr\u00f3b\u00e1ljuk megv\u00e1ltoztatni az \u00e9rt\u00e9k\u00e9t, akkor a k\u00f3d le sem fordul (a priv\u00e1t tagokhoz csak az adott oszt\u00e1ly f\u00e9rhet hozz\u00e1, eset\u00fcnkben Teglalap , ez persze a norm\u00e1l, nem statikus tagokra is igaz). class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Most m\u00e1r nem lehet elrontani m\u00e1s oszt\u00e1lyb\u00f3l a sz\u00e1ml\u00e1l\u00f3t. De mivel private, lek\u00e9rdezni sem lehet m\u00e1r. Ez probl\u00e9ma, hiszen az pont c\u00e9lunk volt, hogy az aktu\u00e1lis sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ket le lehessen k\u00e9rdezni, b\u00e1rhonnan, pl. a Main f\u00fcggv\u00e9nyb\u0151l is, ahogy azt eddig is tett\u00fck. A megold\u00e1s egyszer\u0171: vezezz\u00fcnk be egy tagf\u00fcggv\u00e9nyt (legyen a neve SzamlaloErtek), ami publikus, \u00e9s le lehet vele k\u00e9rdezni a v\u00e9dett Szamlalo \u00e9rt\u00e9k\u00e9t: class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public static int SzamlaloErtek () { return Szamlalo ; } public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } A SzamlaloErtek tagf\u00fcggv\u00e9nyt statikuss\u00e1 is tett\u00fck a static kulcssz\u00f3val! Ez nagyon fontos, hiszen a statikus tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an csak \u00edgy tudjuk megh\u00edvni objektumok n\u00e9lk\u00fcl az oszt\u00e1ly nev\u00e9n kereszt\u00fcl (ak\u00e1r akkor is, ha m\u00e9g egy objektum sem l\u00e9tezik bel\u0151le): Teglalap.SzamlaloErtek() A Main f\u00fcggv\u00e9nyt is alak\u00edtsuk \u00e1t, hogy ezt a statikus tagf\u00fcggv\u00e9nyt haszn\u00e1lja: static void Main ( string [] args ) { int teglalapokSzama = Teglalap . SzamlaloErtek (); Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcggv\u00e9nyt m\u00e1r j\u00f3p\u00e1r alkalommal haszn\u00e1ltunk. Pl. a Console.WriteLine() eset\u00e9n. A Console egy be\u00e9p\u00edtett oszt\u00e1ly, a WriteLine ennek egy statikus tagf\u00fcggv\u00e9nye. Ha nem lenne statikus, akkor csak objektumra lehetne h\u00edvni, vagyis el\u0151bb l\u00e9tre kellene hozni a new-val egy Console objektumot, \u00edgy: Console c1 = new Console (); c1 . WriteLine (); Ez itt feleslegesen macer\u00e1s lenne, mi nem akarunk k\u00fcl\u00f6nb\u00f6z\u0151 Console objektumokkal bajl\u00f3dni. Hasonl\u00f3 a be\u00e9p\u00edtett Math oszt\u00e1ly is, ennek is egy csom\u00f3s statikus tagf\u00fcggv\u00e9nye van, \u00edgy k\u00e9nyelmesen a Math.Abs(-12) , nem kell Math objektumokat l\u00e9trehozni. Ez \u00edgy k\u00e9nyelmesebb, \u00e9s \u00e9rtelmesebb is, hiszen a Math oszt\u00e1lynak nincsenek \u00e1llapotot ad\u00f3 tagv\u00e1ltoz\u00f3i, szemben pl. a Teglalap oszt\u00e1lyunkkal, aminek van, hiszen a Szelesseg \u00e9s Magassag eset\u00e9n fontos, hogy az minden Tegalalap objektumra k\u00fcl\u00f6n t\u00e1rol\u00f3djon. Ilyen a string.Join(\",\", elemek) , ahol a '.'-t el\u0151tt a string a string oszt\u00e1ly neve (Megjegyz\u00e9s: C#-ban a kis \u00e9s nagybet\u0171vel kezd\u0151d\u0151 string / String ugyanazt jelenti.) Az alkalmaz\u00e1sok bel\u00e9p\u00e9si pontja, a Program oszt\u00e1ly Main f\u00fcgg\u00e9nye is statikus. Szab\u00e1lyok \u00b6 Fontos: Statikus tagf\u00fcggv\u00e9nyb\u0151l a norm\u00e1l (vagyis nem statikus) tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem lehet el\u00e9rni. Ezt meg kell tanulni, mert k\u00fcl\u00f6nben gyakran beleszalad az ember. De egy p\u00e9lda \u00e9rthet\u0151v\u00e9 is teszi: class Teglalap { public double Szelesseg ; public double Magassag ; public static double Terulet () { return Szelesseg * Magassag ; } } A p\u00e9ld\u00e1ban a Terulet() statikus tagf\u00fcggv\u00e9ny, ebb\u0151l pr\u00f3b\u00e1lunk el\u00e9rni k\u00e9t nem statikus tagot (Szelesseg, \u00e9s Magassag). Mivel a Terulet() statikus, nem objektumokre, hanem a Teglalap oszt\u00e1lyra tudjuk megh\u00edvni: double ter = Teglalap . Terulet (); A probl\u00e9ma az, hogy a Terulet() el\u0151tt nem objektum, hanem oszt\u00e1ly \u00e1ll, \u00edgy amikor a Terulet() f\u00fcggv\u00e9nyben hivatkozunk a nem statikus Szelesseg \u00e9s Magassag tagokra, akkor azok melyik t\u00e9galalap objektum sz\u00e9less\u00e9g\u00e9t \u00e9s magass\u00e1g\u00e1t is jelenten\u00e9k? M\u00e9g az is lehet, egyetlen Teglalap objektum sem l\u00e9tezik ekkor. Ha a Ter\u00fclet() h\u00edv\u00e1sakor a '.' el\u0151tt egy adott teglalap objektum \u00e1llna, akkor adn\u00e1 mag\u00e1t, de \u00edgy ennek nincs \u00e9rtelme. A m\u00e1sik ir\u00e1nyba nincs ilyen megk\u00f6t\u00e9s (ez is logikus): nem statikus tagf\u00fcggv\u00e9nyb\u0151l statikus tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket el lehet \u00e9rni. \u00d6sszefoglal\u00f3 \u00b6 A legfontosabb gondolatok A statikus tagv\u00e1ltoz\u00f3k az oszt\u00e1lyhoz tartoznak, annak minden objektum\u00e1ra k\u00f6z\u00f6sek Az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rhet\u0151k el, pl. Teglalap.Szamlalo, Teglalap.SzamlaloErtek(), Console.WriteLine(...), Math.Abs(...) Statikus tagf\u00fcggv\u00e9nyb\u0151l nem statikus tagokat nem lehet el\u00e9rni (nincs is \u00e9rtelme) A statikus tagv\u00e1ltoz\u00f3k \u00e9s tagf\u00fcggv\u00e9nyek haszn\u00e1lata sokszor k\u00e9nyelmes, de nem szabad t\u00falz\u00e1sba esni. Leggyakrabban olyan oszt\u00e1lyok eset\u00e9n haszn\u00e1ljuk, mint a Math, ahol az oszt\u00e1ly \u00e1llapottal (tagv\u00e1ltoz\u00f3kkal) nem rendelkezik, hanem csak egyszer\u0171 f\u00fcggv\u00e9nyek gy\u0171jtem\u00e9nye.","title":"Statikus tagok"},{"location":"Static/static/#statikus-tagok","text":"Induljunk ki egy olyan oszt\u00e1lyb\u00f3l, melynek van k\u00e9t k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3ja \u00e9s tagf\u00fcggv\u00e9nye (m\u0171velete): class Teglalap { public double Szelesseg ; public double Magassag ; public double Terulet () { return Szelesseg * Magassag ; } } Az al\u00e1bbiakban l\u00e9trehozuk a Teglalap oszt\u00e1lyb\u00f3l k\u00e9t egym\u00e1st\u00f3l f\u00fcggetlen t1 \u00e9s t2 nev\u0171 t\u00e9glalap objektumot, elt\u00e9r\u0151 sz\u00e9less\u00e9g \u00e9s magass\u00e1g \u00e9rt\u00e9kekkel, majd ki\u00edrjuk ezek ter\u00fclet\u00e9t a konzolra. static void Main ( string [] args ) { Teglalap t1 = new Teglalap (); // #1 t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet () ); Teglalap t2 = new Teglalap (); // #2 t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); }","title":"Statikus tagok"},{"location":"Static/static/#statikus-tagvaltozo","text":"A feladat legyen a k\u00f6vetkez\u0151. Tartsuk nyilv\u00e1n egy sz\u00e1ml\u00e1l\u00f3ban, hogy h\u00e1ny objektumot hoztunk l\u00e9tre a Teglalap oszt\u00e1lyb\u00f3l. Ha b\u00e1rhol a programban l\u00e9trehozunk egy \u00faj Teglalap objektumot, akkor ennek a sz\u00e1ml\u00e1l\u00f3nak eggyel n\u0151nie kell. A fenti Main f\u00fcggv\u00e9ny p\u00e9ld\u00e1t n\u00e9zve, am\u00edg a // #1 megjegyz\u00e9ssel ell\u00e1tott sorban az objektumot nem hoztuk l\u00e9tre, addig a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ke 0, ezt k\u00f6vet\u0151en 1, majd a // #2 sor ut\u00e1n 2 kell legyen. Egy nagy, komplex alkalmaz\u00e1sban sok ezer helyen hozhatunk l\u00e9tre Teglalap objektumot, nem akarunk minden helyen sz\u00e1ml\u00e1l\u00f3t n\u00f6velni, csak egy k\u00f6zponti helyen. \u00cdgy tegy\u00fck bele ezt a sz\u00e1ml\u00e1l\u00f3t mag\u00e1ba a Teglalap oszt\u00e1lyba, \u00e9s n\u00f6velj\u00fck annak konstruktor\u00e1ban, hiszen a konstruktor pont akkor h\u00edv\u00f3dik, amikor egy \u00faj objektum l\u00e9trej\u00f6n: class Teglalap { public double Szelesseg ; public double Magassag ; public int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Ez \u00edgy m\u00e9g nem lesz j\u00f3. A probl\u00e9ma az, hogy a Szamlalo egy k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3, minden t\u00e9glalap objektumhoz k\u00fcl\u00f6n \u00e9rt\u00e9ke lesz 0 kezd\u0151\u00e9rt\u00e9kkel (a fenti p\u00e9ld\u00e1nkban a t1 \u00e9s t2 objektumokn\u00e1l k\u00fcl\u00f6n-k\u00fcl\u00f6n), pont \u00fagy, mint a Szelesseg \u00e9s Magassag tagv\u00e1ltoz\u00f3k eset\u00e9n. Ehelyett nek\u00fcnk egy olyan v\u00e1ltoz\u00f3 kell, ami nem Teglalap objektumonk\u00e9nt van, hanem minden Teglalap objektumra k\u00f6z\u00f6s, mag\u00e1hoz az oszt\u00e1lyhoz tartozik egyetlen \u00e9rt\u00e9k, \u00e9s m\u00e1r akkor is l\u00e9tezik, amikor m\u00e9g egyetlen objektumot sem hoztunk l\u00e9tre (ekkor az \u00e9rt\u00e9ke eset\u00fcnkben 0). Ehhez a Szamlalo tagot statikuss\u00e1 kell tenni, el\u00e9 kell \u00edrni a static kulcssz\u00f3t: class Teglalap { public double Szelesseg ; public double Magassag ; public static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } \u00cdgy a Szamlalo m\u00e1r az oszt\u00e1lyhoz tartozik (nem objektumonk\u00e9nt foglal\u00f3dik neki t\u00e1rhely), minden objektum\u00e1ra k\u00f6z\u00f6s, \u00e9s akkor is l\u00e9terzik, ha m\u00e9g egy Teglalap objektumot sem hoztunk l\u00e9tre. Az ilyen v\u00e1ltoz\u00f3k el\u00e9r\u00e9s\u00e9hez nem kell objektumot l\u00e9trehozni, hanem az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rj\u00fck el a \".\"-tal, a p\u00e9ld\u00e1nkban \u00edgy: Teglalap.Szamlalo A teljes p\u00e9lda, mely ki is \u00edrja t\u00f6bb helyen is a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t. static void Main ( string [] args ) { int teglalapokSzama = Teglalap . Szamlalo ; Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); }","title":"Statikus tagv\u00e1ltoz\u00f3"},{"location":"Static/static/#statikus-tagfuggeny","text":"A megold\u00e1sunk m\u00e9g nem t\u00f6k\u00e9letes. A Szamlalo tag publikus a Teglalap oszt\u00e1lyban. \u00cdgy b\u00e1rhol valaki v\u00e9letlen vagy sz\u00e1nd\u00e9skosan elronthatja a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t, pl. ki tudja null\u00e1zni az al\u00e1bbis sorral, akkor is, ha m\u00e1r volt bel\u0151le objektum, \u00edgy \u00e9rt\u00e9ke hamis lesz: Teglalap.Szamlalo = 0; Ezt \u00fagy tudjuk megakad\u00e1lyozni, hogy a Szamlalo -t a Teglalap oszt\u00e1lyban v\u00e9dett\u00e9, priv\u00e1tt\u00e1 tessz\u00fck, ekkor ha m\u00e1s oszt\u00e1lyban pr\u00f3b\u00e1ljuk megv\u00e1ltoztatni az \u00e9rt\u00e9k\u00e9t, akkor a k\u00f3d le sem fordul (a priv\u00e1t tagokhoz csak az adott oszt\u00e1ly f\u00e9rhet hozz\u00e1, eset\u00fcnkben Teglalap , ez persze a norm\u00e1l, nem statikus tagokra is igaz). class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Most m\u00e1r nem lehet elrontani m\u00e1s oszt\u00e1lyb\u00f3l a sz\u00e1ml\u00e1l\u00f3t. De mivel private, lek\u00e9rdezni sem lehet m\u00e1r. Ez probl\u00e9ma, hiszen az pont c\u00e9lunk volt, hogy az aktu\u00e1lis sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ket le lehessen k\u00e9rdezni, b\u00e1rhonnan, pl. a Main f\u00fcggv\u00e9nyb\u0151l is, ahogy azt eddig is tett\u00fck. A megold\u00e1s egyszer\u0171: vezezz\u00fcnk be egy tagf\u00fcggv\u00e9nyt (legyen a neve SzamlaloErtek), ami publikus, \u00e9s le lehet vele k\u00e9rdezni a v\u00e9dett Szamlalo \u00e9rt\u00e9k\u00e9t: class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public static int SzamlaloErtek () { return Szamlalo ; } public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } A SzamlaloErtek tagf\u00fcggv\u00e9nyt statikuss\u00e1 is tett\u00fck a static kulcssz\u00f3val! Ez nagyon fontos, hiszen a statikus tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an csak \u00edgy tudjuk megh\u00edvni objektumok n\u00e9lk\u00fcl az oszt\u00e1ly nev\u00e9n kereszt\u00fcl (ak\u00e1r akkor is, ha m\u00e9g egy objektum sem l\u00e9tezik bel\u0151le): Teglalap.SzamlaloErtek() A Main f\u00fcggv\u00e9nyt is alak\u00edtsuk \u00e1t, hogy ezt a statikus tagf\u00fcggv\u00e9nyt haszn\u00e1lja: static void Main ( string [] args ) { int teglalapokSzama = Teglalap . SzamlaloErtek (); Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcggv\u00e9nyt m\u00e1r j\u00f3p\u00e1r alkalommal haszn\u00e1ltunk. Pl. a Console.WriteLine() eset\u00e9n. A Console egy be\u00e9p\u00edtett oszt\u00e1ly, a WriteLine ennek egy statikus tagf\u00fcggv\u00e9nye. Ha nem lenne statikus, akkor csak objektumra lehetne h\u00edvni, vagyis el\u0151bb l\u00e9tre kellene hozni a new-val egy Console objektumot, \u00edgy: Console c1 = new Console (); c1 . WriteLine (); Ez itt feleslegesen macer\u00e1s lenne, mi nem akarunk k\u00fcl\u00f6nb\u00f6z\u0151 Console objektumokkal bajl\u00f3dni. Hasonl\u00f3 a be\u00e9p\u00edtett Math oszt\u00e1ly is, ennek is egy csom\u00f3s statikus tagf\u00fcggv\u00e9nye van, \u00edgy k\u00e9nyelmesen a Math.Abs(-12) , nem kell Math objektumokat l\u00e9trehozni. Ez \u00edgy k\u00e9nyelmesebb, \u00e9s \u00e9rtelmesebb is, hiszen a Math oszt\u00e1lynak nincsenek \u00e1llapotot ad\u00f3 tagv\u00e1ltoz\u00f3i, szemben pl. a Teglalap oszt\u00e1lyunkkal, aminek van, hiszen a Szelesseg \u00e9s Magassag eset\u00e9n fontos, hogy az minden Tegalalap objektumra k\u00fcl\u00f6n t\u00e1rol\u00f3djon. Ilyen a string.Join(\",\", elemek) , ahol a '.'-t el\u0151tt a string a string oszt\u00e1ly neve (Megjegyz\u00e9s: C#-ban a kis \u00e9s nagybet\u0171vel kezd\u0151d\u0151 string / String ugyanazt jelenti.) Az alkalmaz\u00e1sok bel\u00e9p\u00e9si pontja, a Program oszt\u00e1ly Main f\u00fcgg\u00e9nye is statikus.","title":"Statikus tagf\u00fcgg\u00e9ny"},{"location":"Static/static/#szabalyok","text":"Fontos: Statikus tagf\u00fcggv\u00e9nyb\u0151l a norm\u00e1l (vagyis nem statikus) tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem lehet el\u00e9rni. Ezt meg kell tanulni, mert k\u00fcl\u00f6nben gyakran beleszalad az ember. De egy p\u00e9lda \u00e9rthet\u0151v\u00e9 is teszi: class Teglalap { public double Szelesseg ; public double Magassag ; public static double Terulet () { return Szelesseg * Magassag ; } } A p\u00e9ld\u00e1ban a Terulet() statikus tagf\u00fcggv\u00e9ny, ebb\u0151l pr\u00f3b\u00e1lunk el\u00e9rni k\u00e9t nem statikus tagot (Szelesseg, \u00e9s Magassag). Mivel a Terulet() statikus, nem objektumokre, hanem a Teglalap oszt\u00e1lyra tudjuk megh\u00edvni: double ter = Teglalap . Terulet (); A probl\u00e9ma az, hogy a Terulet() el\u0151tt nem objektum, hanem oszt\u00e1ly \u00e1ll, \u00edgy amikor a Terulet() f\u00fcggv\u00e9nyben hivatkozunk a nem statikus Szelesseg \u00e9s Magassag tagokra, akkor azok melyik t\u00e9galalap objektum sz\u00e9less\u00e9g\u00e9t \u00e9s magass\u00e1g\u00e1t is jelenten\u00e9k? M\u00e9g az is lehet, egyetlen Teglalap objektum sem l\u00e9tezik ekkor. Ha a Ter\u00fclet() h\u00edv\u00e1sakor a '.' el\u0151tt egy adott teglalap objektum \u00e1llna, akkor adn\u00e1 mag\u00e1t, de \u00edgy ennek nincs \u00e9rtelme. A m\u00e1sik ir\u00e1nyba nincs ilyen megk\u00f6t\u00e9s (ez is logikus): nem statikus tagf\u00fcggv\u00e9nyb\u0151l statikus tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket el lehet \u00e9rni.","title":"Szab\u00e1lyok"},{"location":"Static/static/#osszefoglalo","text":"A legfontosabb gondolatok A statikus tagv\u00e1ltoz\u00f3k az oszt\u00e1lyhoz tartoznak, annak minden objektum\u00e1ra k\u00f6z\u00f6sek Az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rhet\u0151k el, pl. Teglalap.Szamlalo, Teglalap.SzamlaloErtek(), Console.WriteLine(...), Math.Abs(...) Statikus tagf\u00fcggv\u00e9nyb\u0151l nem statikus tagokat nem lehet el\u00e9rni (nincs is \u00e9rtelme) A statikus tagv\u00e1ltoz\u00f3k \u00e9s tagf\u00fcggv\u00e9nyek haszn\u00e1lata sokszor k\u00e9nyelmes, de nem szabad t\u00falz\u00e1sba esni. Leggyakrabban olyan oszt\u00e1lyok eset\u00e9n haszn\u00e1ljuk, mint a Math, ahol az oszt\u00e1ly \u00e1llapottal (tagv\u00e1ltoz\u00f3kkal) nem rendelkezik, hanem csak egyszer\u0171 f\u00fcggv\u00e9nyek gy\u0171jtem\u00e9nye.","title":"\u00d6sszefoglal\u00f3"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/","text":"String alapok 1 \u00b6 Feladat 1 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely megford\u00edt egy adott stringet \u00e9s visszat\u00e9r vele. Pl: ad\u00e9l ->l\u00e9da Feladat 2 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott string h\u00e1nyszor fordul el\u0151 \u00e9s visszaadja ezt a sz\u00e1mot. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * sz\u00f6veg: \"Az aut\u00f3 gyorsan ment \u00e9s lesodr\u00f3dott az \u00fatr\u00f3l. Az aut\u00f3ban \u00fcl\u0151k megr\u00e9m\u00fcltek \u00e9s kisz\u00e1lltak az aut\u00f3b\u00f3l\" * keresend\u0151: \u201eaut\u00f3\u201d A f\u00fcggv\u00e9ny kimenete: 3, hiszen h\u00e1romszor szerepel benne a keresett kifejez\u00e9s Feladat 3 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott karakter hol fordul el\u0151, \u00e9s minden el\u0151fordul\u00e1s\u00e1ra visszaadja az adott el\u0151fordul\u00e1s kezd\u0151poz\u00edci\u00f3j\u00e1t \u00e9s hossz\u00e1t. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * Sz\u00f6veg: \u201eaz aaaut\u00f3 alm\u00e1t vitt\u201d * Karakter: a A f\u00fcggv\u00e9ny kimenete: 0 poz, 1 hossz; 3 poz 3 hossz; 10 poz 1 hossz Tipp: A megold\u00e1s sor\u00e1n be kell vezetni egy oszt\u00e1lyt vagy strukt\u00far\u00e1t, mely egy el\u0151fordul\u00e1st reprezent\u00e1l (ennek megfelel\u0151en van egy Kezdopoz \u00e9s egy Hossz tagja)","title":"String alapok 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#string-alapok-1","text":"","title":"String alapok 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-1","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely megford\u00edt egy adott stringet \u00e9s visszat\u00e9r vele. Pl: ad\u00e9l ->l\u00e9da","title":"Feladat 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-2","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott string h\u00e1nyszor fordul el\u0151 \u00e9s visszaadja ezt a sz\u00e1mot. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * sz\u00f6veg: \"Az aut\u00f3 gyorsan ment \u00e9s lesodr\u00f3dott az \u00fatr\u00f3l. Az aut\u00f3ban \u00fcl\u0151k megr\u00e9m\u00fcltek \u00e9s kisz\u00e1lltak az aut\u00f3b\u00f3l\" * keresend\u0151: \u201eaut\u00f3\u201d A f\u00fcggv\u00e9ny kimenete: 3, hiszen h\u00e1romszor szerepel benne a keresett kifejez\u00e9s","title":"Feladat 2"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-3","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott karakter hol fordul el\u0151, \u00e9s minden el\u0151fordul\u00e1s\u00e1ra visszaadja az adott el\u0151fordul\u00e1s kezd\u0151poz\u00edci\u00f3j\u00e1t \u00e9s hossz\u00e1t. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * Sz\u00f6veg: \u201eaz aaaut\u00f3 alm\u00e1t vitt\u201d * Karakter: a A f\u00fcggv\u00e9ny kimenete: 0 poz, 1 hossz; 3 poz 3 hossz; 10 poz 1 hossz Tipp: A megold\u00e1s sor\u00e1n be kell vezetni egy oszt\u00e1lyt vagy strukt\u00far\u00e1t, mely egy el\u0151fordul\u00e1st reprezent\u00e1l (ennek megfelel\u0151en van egy Kezdopoz \u00e9s egy Hossz tagja)","title":"Feladat 3"}]}