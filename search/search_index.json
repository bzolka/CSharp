{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C# alapok \u00b6 Ismertet\u0151k, fealdatok, p\u00e9ld\u00e1k C# megismer\u00e9s\u00e9hez \u00e9s gyakorl\u00e1s\u00e1hoz.","title":"C# alapok"},{"location":"#c-alapok","text":"Ismertet\u0151k, fealdatok, p\u00e9ld\u00e1k C# megismer\u00e9s\u00e9hez \u00e9s gyakorl\u00e1s\u00e1hoz.","title":"C# alapok"},{"location":"AlapUtasitasok/ciklusok/","text":"Ciklusok \u00b6 Lehet\u0151s\u00e9gek \u00b6 foreach for while do while foreach \u00b6 A legk\u00e9nyelmesebb, legegyszer\u0171bb m\u00f3dja annak, hogy b\u00e1rmiyen gy\u0171jtem\u00e9nyen egyes\u00e9vel sorban el\u0151re haladva el\u00e9rj\u00fck az elemeket. A gyakorlatban messze ezt haszn\u00e1ljuk a leggyakrabban. P\u00e9lda int t\u00f6mb elemein val\u00f3 v\u00e9gigiter\u00e1l\u00e1sra: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; // Az \"in\" kulcssz\u00f3 ut\u00e1n megadjuk a gy\u0171jtem\u00e9nyt, amin v\u00e9gig akarunk menni. // Az \"in\" kulcssz\u00f3 el\u0151tt bevezet\u00fcnk egy ELEM T\u00cdPUS\u00da v\u00e1ltoz\u00f3t, ennek // tetsz\u0151leges nevet adhatunk (a p\u00e9ld\u00e1ban int sz), ez a ciklus t\u00f6rzs\u00e9ben // minden iter\u00e1ci\u00f3ban az adott elemet fogja tartalmazni. foreach ( int sz in szamok ) { Console . WriteLine ( sz . ToString () ); } Most tegy\u00fck fel, hogy a Szemely egy oszt\u00e1ly, \u00e9s ebb\u0151l van egy list\u00e1nk, ezen menj\u00fcnk v\u00e9gig egyes\u00e9vel: Szemely [] szemelyek = new Szemely [] { ... itt megadjuk a szem\u00e9lyeket ... }; // Itt az elem t\u00edpusa Szemely, szemely neven vezett\u00fck be foreach ( Szemely szemely in szemelyek ) { Console . WriteLine ( szemely . Nev ); } Hint Legegyszer\u0171bben \u00edgy tudsz l\u00e9trehozni Visual Studio alatt: foreach + tab + tab (be kell \u00edrni, hogy foreach, majd k\u00e9tszer tab-ot kell nyomni), majd megadni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t \u00e9s nev\u00e9t. R\u00e9szletesebb magyar\u00e1zat \u00e9s p\u00e9ld\u00e1k: http://aries.ektf.hu/~hz/wiki7/mprog1ea/foreach for \u00b6 Leggyakrabban arra haszn\u00e1ljuk, hogy t\u00f6mb\u00f6n, list\u00e1n lehet v\u00e9gigmenni, az elemeket az index\u00e9vel el\u00e9rve. Ezt m\u00e1r ismered. P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/for https://www.tutorialsteacher.com/csharp/csharp-for-loop while \u00b6 El\u00f6ltesztel\u0151s ciklus. while (< felt\u00e9tel >) { < utas\u00edt\u00e1sok > } P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/while https://www.tutorialsteacher.com/csharp/csharp-while-loop do while \u00b6 H\u00e1tultesztel\u0151s ciklus, ritk\u00e1n haszn\u00e1ljuk. do { < utas\u00edt\u00e1sok > } while (< felt\u00e9tel >); P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: https://www.tutorialsteacher.com/csharp/csharp-do-while-loop","title":"Ciklusok"},{"location":"AlapUtasitasok/ciklusok/#ciklusok","text":"","title":"Ciklusok"},{"location":"AlapUtasitasok/ciklusok/#lehetosegek","text":"foreach for while do while","title":"Lehet\u0151s\u00e9gek"},{"location":"AlapUtasitasok/ciklusok/#foreach","text":"A legk\u00e9nyelmesebb, legegyszer\u0171bb m\u00f3dja annak, hogy b\u00e1rmiyen gy\u0171jtem\u00e9nyen egyes\u00e9vel sorban el\u0151re haladva el\u00e9rj\u00fck az elemeket. A gyakorlatban messze ezt haszn\u00e1ljuk a leggyakrabban. P\u00e9lda int t\u00f6mb elemein val\u00f3 v\u00e9gigiter\u00e1l\u00e1sra: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; // Az \"in\" kulcssz\u00f3 ut\u00e1n megadjuk a gy\u0171jtem\u00e9nyt, amin v\u00e9gig akarunk menni. // Az \"in\" kulcssz\u00f3 el\u0151tt bevezet\u00fcnk egy ELEM T\u00cdPUS\u00da v\u00e1ltoz\u00f3t, ennek // tetsz\u0151leges nevet adhatunk (a p\u00e9ld\u00e1ban int sz), ez a ciklus t\u00f6rzs\u00e9ben // minden iter\u00e1ci\u00f3ban az adott elemet fogja tartalmazni. foreach ( int sz in szamok ) { Console . WriteLine ( sz . ToString () ); } Most tegy\u00fck fel, hogy a Szemely egy oszt\u00e1ly, \u00e9s ebb\u0151l van egy list\u00e1nk, ezen menj\u00fcnk v\u00e9gig egyes\u00e9vel: Szemely [] szemelyek = new Szemely [] { ... itt megadjuk a szem\u00e9lyeket ... }; // Itt az elem t\u00edpusa Szemely, szemely neven vezett\u00fck be foreach ( Szemely szemely in szemelyek ) { Console . WriteLine ( szemely . Nev ); } Hint Legegyszer\u0171bben \u00edgy tudsz l\u00e9trehozni Visual Studio alatt: foreach + tab + tab (be kell \u00edrni, hogy foreach, majd k\u00e9tszer tab-ot kell nyomni), majd megadni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t \u00e9s nev\u00e9t. R\u00e9szletesebb magyar\u00e1zat \u00e9s p\u00e9ld\u00e1k: http://aries.ektf.hu/~hz/wiki7/mprog1ea/foreach","title":"foreach"},{"location":"AlapUtasitasok/ciklusok/#for","text":"Leggyakrabban arra haszn\u00e1ljuk, hogy t\u00f6mb\u00f6n, list\u00e1n lehet v\u00e9gigmenni, az elemeket az index\u00e9vel el\u00e9rve. Ezt m\u00e1r ismered. P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/for https://www.tutorialsteacher.com/csharp/csharp-for-loop","title":"for"},{"location":"AlapUtasitasok/ciklusok/#while","text":"El\u00f6ltesztel\u0151s ciklus. while (< felt\u00e9tel >) { < utas\u00edt\u00e1sok > } P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/while https://www.tutorialsteacher.com/csharp/csharp-while-loop","title":"while"},{"location":"AlapUtasitasok/ciklusok/#do-while","text":"H\u00e1tultesztel\u0151s ciklus, ritk\u00e1n haszn\u00e1ljuk. do { < utas\u00edt\u00e1sok > } while (< felt\u00e9tel >); P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: https://www.tutorialsteacher.com/csharp/csharp-do-while-loop","title":"do while"},{"location":"AlapUtasitasok/felteteles-elagazasok/","text":"","title":"Felteteles elagazasok"},{"location":"Linq/Linq-attekinto/","text":"LINQ - \u00e1ttekint\u0151 \u00b6 A legfontosabbak parancsok, ',' ut\u00e1n az l\u00e1that\u00f3, mi az adott m\u0171veletn\u00e9l a param\u00e9ter, amit megkapunk: Where: sz\u0171r\u00e9s, elem Select: elemek lek\u00e9pez\u00e9se m\u00e1s elemre, elem OrderBy: sorrendez\u00e9s, elem GroupBy: csoportos\u00edt\u00e1s, csoport","title":"LINQ - \u00e1ttekint\u0151"},{"location":"Linq/Linq-attekinto/#linq-attekinto","text":"A legfontosabbak parancsok, ',' ut\u00e1n az l\u00e1that\u00f3, mi az adott m\u0171veletn\u00e9l a param\u00e9ter, amit megkapunk: Where: sz\u0171r\u00e9s, elem Select: elemek lek\u00e9pez\u00e9se m\u00e1s elemre, elem OrderBy: sorrendez\u00e9s, elem GroupBy: csoportos\u00edt\u00e1s, csoport","title":"LINQ - \u00e1ttekint\u0151"},{"location":"Linq/Linq-csoportositas-feladatok/","text":"LINQ - feladatok \u00b6 Ir\u00e1nyelvek: Pr\u00f3b\u00e1ld is ki a megold\u00e1sod! A feladat sz\u00f6veg\u00e9t \u00edrd a megold\u00e1sod f\u00f6l\u00e9 egy megjegyz\u00e9sben az el\u0151z\u0151 feladatot megold\u00e1s\u00e1t \u00edrd \u00e1t, ahogy haladsz, hanem legyen meg mind k\u00fcl\u00f6n! Kiindul\u00e1s \u00b6 Az al\u00e1bbi oszt\u00e1lyt haszn\u00e1ld a feladatok megold\u00e1sa sor\u00e1n: class Szinesz { public int Szulev ; public string Nev ; // Ne adjuk \u00e1t a sz\u00fcl. \u00e9v\u00e9t, mert m\u00e1r megvan tagv\u00e1ltoz\u00f3ban! public int EletkorSzamolo () { return DateTime . Now . Year - szulev ; } public Szinesz ( int szulev , string nev ) { this . szulev = szulev ; this . nev = nev ; } } Feladat 1 \u00b6 B\u0151v\u00edtsd ki a Szinesz oszt\u00e1lyt, minden sz\u00edn\u00e9sznek legyen egy \u00faj tulajdons\u00e1ga, egy string orszag, ahol sz\u00fcletett. Feladat 2 \u00b6 \u00cdrj egy f\u00fcggv\u00e9nyt (ha m\u00e9g nincs), amelyik el\u0151\u00e1ll\u00edt \u00e9s visszaad egy t\u00f6mbben 6 sz\u00edn\u00e9szt. Mindenkinek m\u00e1s a neve; 1 sz\u00edn\u00e9sz sz\u00fclessen 1975-ben, 2 1998-ban, 3 1980-ban; 1 sz\u00fclet\u00e9si helye Spanyolorsz\u00e1g, 2 USA, 3 Kanada. A t\u00f6mb\u00f6t inicializ\u00e1l\u00e1ssal hozd l\u00e9tre, ha lehet, vagyis az elemeket a l\u00e9trehoz\u00e1skor {} k\u00f6z\u00f6tt add meg, ahogy egyszer mutattam. Ezt a f\u00fcggv\u00e9nyt a k\u00e9s\u0151bb arra haszn\u00e1ljuk, hogy a LINQ lek\u00e9rdez\u00e9sekhez visszaadja a 6 tesztadatot. Feladat 3 \u00b6 a) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szeket egy t\u00f6mbben, akik 1990 ut\u00e1n sz\u00fclettek b) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szek neveit egy list\u00e1ban, akik 1990 ut\u00e1n sz\u00fclettek. c) \u00c1ll\u00edts el\u0151 egyetlen sztringet, mely vessz\u0151vel elv\u00e1lasztva azon sz\u00edn\u00e9szek sz\u00fclet\u00e9si \u00e9v\u00e9t tartalmazza (egyetlen sztringben), akik 1990 ut\u00e1n sz\u00fclettek. Feladat 4 - csoportos\u00edt\u00e1sok \u00b6 a) Egyszer\u0171 csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben a sz\u00fclet\u00e9si helyek szerepelnek (minden csoportra egyszer). Ezt k\u00f6vet\u0151en \u00edrd ki, vessz\u0151vel elv\u00e1lasztva ezen sz\u00fclet\u00e9si helyeket (ezt a ki\u00edr\u00e1st egyetlen sorban oldd meg)! Magyar\u00e1zat : Tfh van 6 sz\u00edn\u00e9sz, sz1, sz2, \u2026sz6. A szineszek.GroupBy(sz => sz.Orszag) ut\u00e1n, ha orsz\u00e1g szerint csoportos\u00edtunk, 3 sz\u00edn\u00e9sz csoport lesz: Csop1: Key: Spanyolorsz\u00e1g Elemek: [sz1] Csop2: Key: USA Elemek: [sz2, sz3] Csop3: Key: Kanada Elemek: [sz4, sz5, sz6] L\u00e9nyeges: minden csoporthoz egy kulcs tartozik (az orsz\u00e1g, mert eszerint csoportos\u00edtottunk), \u00e9s egy gy\u0171jtem\u00e9ny a csoportban lev\u0151 sz\u00edn\u00e9szekr\u0151l (mert sz\u00edn\u00e9szekre h\u00edvtuk a GroupBy-t) b) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: sz\u00edn\u00e9szek t\u00f6mbje \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben az egyes csoportokban lev\u0151 sz\u00edn\u00e9szek tal\u00e1lhat\u00f3k. Ezt pr\u00f3b\u00e1lt elk\u00e9pzelni magadt\u00f3l, \u00e9s csak ut\u00e1na olvass tov\u00e1bb, mert itt kicsit s\u00fagni fogok\u2026 Vagyis a t\u00f6mb els\u0151 eleme az els\u0151 csoport sz\u00edn\u00e9szeit tartalmazza egy t\u00f6mbben, a m\u00e1sodik eleme a m\u00e1sodik csoport szineszeit tartalmazza egy t\u00f6mbben, \u00e9s \u00edgy tov\u00e1bb. Vagyis a kimenet egy olyan t\u00f6mb lesz, melynek az elemi szin\u00e9sz t\u00f6mb\u00f6k. Nincs ebben semmi var\u00e1zslat: t\u00f6mb eleme b\u00e1rmi lehet, sz\u00e1m, string, oszt\u00e1ly, vagy ak\u00e1r mint eset\u00fcnkben is, m\u00e1sik t\u00f6mb is: Kb. ilyesmik\u00e9nt kell elk\u00e9pzelni: [ [sz1, sz2], [sz3, sz5, sz6], [sz7] ]. Ez olyan t\u00f6mb, melynek elemei t\u00f6mb\u00f6k, t\u00f6mb\u00f6k t\u00f6mbj\u00e9nek is szoktuk mondani. c) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: sz\u00edn\u00e9szek neve vessz\u0151vel elv\u00e1lasztva \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, mely elemei a csoportban lev\u0151 sz\u00edn\u00e9szek neveit tartalmazz\u00e1k, vessz\u0151vel elv\u00e1lasztva. El\u0151sz\u00f6r pr\u00f3b\u00e1ld ezt magadt\u00f3l elk\u00e9pzelni, csak ut\u00e1na olvasd tov\u00e1bb, s\u00fagok \u2026 A t\u00f6mb elemei itt most stringek, ilyesmi kimenetet v\u00e1runk, h\u00e1rom elem\u0171 string t\u00f6mb\u00f6t: [\"B\u00e9la, J\u00f3zsi\", \"Jani, Juli, G\u00e9za\", \"Misi\" ] d) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00b6 Hasonl\u00f3, mint a b) volt, vagyis most is sz\u00fclet\u00e9si hely szerint csoportos\u00edtunk. A b)-n\u00e9l, ha megn\u00e9zed, megvolt a kimenetben a h\u00e1rom csoport, mert a kimenet h\u00e1rom elem\u0171 t\u00f6mb volt, de nem tudtuk, melyik t\u00f6mb elem/csoport melyik orsz\u00e1ghoz tartozott. Pl. a kimeneti t\u00f6mb nulladik elem\u00e9ben volt k\u00e9t sz\u00edn\u00e9sz, de nem tudtuk megmondani, mely orsz\u00e1g csoportj\u00e1ba tartoztak . Ezt fontos lenne, hogy \u00e9rtsd, ha nem, besz\u00e9lj\u00fck meg! Mindenesetre ez \u00edgy sokszor nem szerencs\u00e9s. A c\u00e9l az, hogy a kimenetben azt is tudjuk, mely csoporthoz tartoznak az elemek (eset\u00fcnkben mely orsz\u00e1ghoz). Ezt t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet oldani. Picit gondolkozz azon, van-e \u00f6tleted\u2026 Meg lehet oldani KeyValuePair haszn\u00e1lat\u00e1val is, de az a k\u00f6vetkez\u0151 feladat lesz, most m\u00e9g hagyjuk. Els\u0151 k\u00f6rben egy \u201enyersebb\u201d megold\u00e1st n\u00e9z\u00fcnk, mert az sokszor \u00e1ltal\u00e1nosabb \u00e9s jobban haszn\u00e1lhat\u00f3, csak egy kicsit munk\u00e1sabb. A megold\u00e1s alapelve az, hogy bevezet\u00fcnk egy \u00faj oszt\u00e1ly, mely a kimenet egy csoportj\u00e1t (ami a t\u00f6mb egy eleme) fogja reprezent\u00e1lni. Mire is van sz\u00fcks\u00e9g minden egyes csoportn\u00e1l: az orsz\u00e1gn\u00e9vre, illetve hozz\u00e1 tartoz\u00f3 szin\u00e9szek t\u00f6mbj\u00e9re. vagyis egy ilyen oszt\u00e1lyt kell bevezetni: class SzineszCsoport { public string Orszag ; public Szinesz [] Szineszek ; < \u00cdrj m\u00e9g egy konstruktort , minek van k\u00e9t param\u00e9tere , az orsz\u00e1g \u00e9s a szineszek , erre sz\u00fcks\u00e9g lesz > } Ha ez megvan, akkor hasonl\u00f3an kell dolgozni, mint a b)-n\u00e9l, csak a Select-ben a csoportokat nem Szinesz t\u00f6mbre, hanem SzineszCsoport oszt\u00e1lyra kell lepezni, egy ilyet kell a new-val l\u00e9trehozni. Egy picit pr\u00f3b\u00e1lkozz, \u00e9s besz\u00e9lj\u00fck meg, ebben sokminden volt. e) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00e9letkora vessz\u0151vel elv\u00e1lasztva \u00b6 Ugyanaz, mint az el\u0151z\u0151, csak a kimenetben az orsz\u00e1gokhoz nem a szin\u00e9szek t\u00f6mbj\u00e9t, hanem a sz\u00edn\u00e9szek \u00e9letkor\u00e1nak vessz\u0151vel \u00f6sszef\u0171z\u00f6tt \u00e9vsz\u00e1m\u00e1t szeretn\u00e9nk l\u00e1tni. Tipp: vezess be egy SzineszCsoportEvekkel oszt\u00e1lyt, ebben a string Orszag mellett nem szinesz t\u00f6mb, hanem string evek legyen. f) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek, de most a be\u00e9p\u00edtett KeyValuePair-rel \u00b6 Hasonl\u00f3, mint a d) el\u0151z\u0151, csak itt nem akarunk \u00faj oszt\u00e1lyt (SzineszCsoport oszt\u00e1ly) bevezetni. De a c\u00e9lunk ugyanaz, vagyis legyen meg minden csoportra az orsz\u00e1g is, valamint a benne lev\u0151 sz\u00edn\u00e9szek is. A megold\u00e1s elve az, hogy nem vezet\u00fcnk be SzineszCsoport oszt\u00e1lyt, hanem helyette a be\u00e9p\u00edtett KeyValuePair-t haszn\u00e1ljuk. Minden csoportn\u00e1l a kulcs (vagyis a Key) az orsz\u00e1g, hiszen eszerint csoportos\u00edtunk, a Value, a kulcshoz tartoz\u00f3 \u00e9rt\u00e9k pedig \u2026 ezt pr\u00f3b\u00e1ld kital\u00e1lni, hogy \u00e9rdemes. g) Csoportos\u00edt\u00e1s sz\u00edn\u00e9szn\u00e9v kezd\u0151bet\u0171 alapj\u00e1n, sorrendezve \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket aszerint, hogy milyen bet\u0171vel kezd\u0151dik a nev\u00fck. KeyValuePair-rel dolgozz. Az egyes csoportokban ne a csoportban lev\u0151 sz\u00edn\u00e9szeket, hanem a csoportban lev\u0151 sz\u00edn\u00e9szek neveit c\u00edmeit t\u00e1rold t\u00f6mbben. A kimenet legyen sorrendezve a n\u00e9v kezd\u0151bet\u0171 alapj\u00e1n!","title":"LINQ - feladatok"},{"location":"Linq/Linq-csoportositas-feladatok/#linq-feladatok","text":"Ir\u00e1nyelvek: Pr\u00f3b\u00e1ld is ki a megold\u00e1sod! A feladat sz\u00f6veg\u00e9t \u00edrd a megold\u00e1sod f\u00f6l\u00e9 egy megjegyz\u00e9sben az el\u0151z\u0151 feladatot megold\u00e1s\u00e1t \u00edrd \u00e1t, ahogy haladsz, hanem legyen meg mind k\u00fcl\u00f6n!","title":"LINQ - feladatok"},{"location":"Linq/Linq-csoportositas-feladatok/#kiindulas","text":"Az al\u00e1bbi oszt\u00e1lyt haszn\u00e1ld a feladatok megold\u00e1sa sor\u00e1n: class Szinesz { public int Szulev ; public string Nev ; // Ne adjuk \u00e1t a sz\u00fcl. \u00e9v\u00e9t, mert m\u00e1r megvan tagv\u00e1ltoz\u00f3ban! public int EletkorSzamolo () { return DateTime . Now . Year - szulev ; } public Szinesz ( int szulev , string nev ) { this . szulev = szulev ; this . nev = nev ; } }","title":"Kiindul\u00e1s"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-1","text":"B\u0151v\u00edtsd ki a Szinesz oszt\u00e1lyt, minden sz\u00edn\u00e9sznek legyen egy \u00faj tulajdons\u00e1ga, egy string orszag, ahol sz\u00fcletett.","title":"Feladat 1"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-2","text":"\u00cdrj egy f\u00fcggv\u00e9nyt (ha m\u00e9g nincs), amelyik el\u0151\u00e1ll\u00edt \u00e9s visszaad egy t\u00f6mbben 6 sz\u00edn\u00e9szt. Mindenkinek m\u00e1s a neve; 1 sz\u00edn\u00e9sz sz\u00fclessen 1975-ben, 2 1998-ban, 3 1980-ban; 1 sz\u00fclet\u00e9si helye Spanyolorsz\u00e1g, 2 USA, 3 Kanada. A t\u00f6mb\u00f6t inicializ\u00e1l\u00e1ssal hozd l\u00e9tre, ha lehet, vagyis az elemeket a l\u00e9trehoz\u00e1skor {} k\u00f6z\u00f6tt add meg, ahogy egyszer mutattam. Ezt a f\u00fcggv\u00e9nyt a k\u00e9s\u0151bb arra haszn\u00e1ljuk, hogy a LINQ lek\u00e9rdez\u00e9sekhez visszaadja a 6 tesztadatot.","title":"Feladat 2"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-3","text":"a) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szeket egy t\u00f6mbben, akik 1990 ut\u00e1n sz\u00fclettek b) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szek neveit egy list\u00e1ban, akik 1990 ut\u00e1n sz\u00fclettek. c) \u00c1ll\u00edts el\u0151 egyetlen sztringet, mely vessz\u0151vel elv\u00e1lasztva azon sz\u00edn\u00e9szek sz\u00fclet\u00e9si \u00e9v\u00e9t tartalmazza (egyetlen sztringben), akik 1990 ut\u00e1n sz\u00fclettek.","title":"Feladat 3"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-4-csoportositasok","text":"","title":"Feladat 4 - csoportos\u00edt\u00e1sok"},{"location":"Linq/Linq-csoportositas-feladatok/#a-egyszeru-csoportositas-szuletesi-hely-szerint","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben a sz\u00fclet\u00e9si helyek szerepelnek (minden csoportra egyszer). Ezt k\u00f6vet\u0151en \u00edrd ki, vessz\u0151vel elv\u00e1lasztva ezen sz\u00fclet\u00e9si helyeket (ezt a ki\u00edr\u00e1st egyetlen sorban oldd meg)! Magyar\u00e1zat : Tfh van 6 sz\u00edn\u00e9sz, sz1, sz2, \u2026sz6. A szineszek.GroupBy(sz => sz.Orszag) ut\u00e1n, ha orsz\u00e1g szerint csoportos\u00edtunk, 3 sz\u00edn\u00e9sz csoport lesz: Csop1: Key: Spanyolorsz\u00e1g Elemek: [sz1] Csop2: Key: USA Elemek: [sz2, sz3] Csop3: Key: Kanada Elemek: [sz4, sz5, sz6] L\u00e9nyeges: minden csoporthoz egy kulcs tartozik (az orsz\u00e1g, mert eszerint csoportos\u00edtottunk), \u00e9s egy gy\u0171jtem\u00e9ny a csoportban lev\u0151 sz\u00edn\u00e9szekr\u0151l (mert sz\u00edn\u00e9szekre h\u00edvtuk a GroupBy-t)","title":"a) Egyszer\u0171 csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint"},{"location":"Linq/Linq-csoportositas-feladatok/#b-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-szineszek-tombje","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben az egyes csoportokban lev\u0151 sz\u00edn\u00e9szek tal\u00e1lhat\u00f3k. Ezt pr\u00f3b\u00e1lt elk\u00e9pzelni magadt\u00f3l, \u00e9s csak ut\u00e1na olvass tov\u00e1bb, mert itt kicsit s\u00fagni fogok\u2026 Vagyis a t\u00f6mb els\u0151 eleme az els\u0151 csoport sz\u00edn\u00e9szeit tartalmazza egy t\u00f6mbben, a m\u00e1sodik eleme a m\u00e1sodik csoport szineszeit tartalmazza egy t\u00f6mbben, \u00e9s \u00edgy tov\u00e1bb. Vagyis a kimenet egy olyan t\u00f6mb lesz, melynek az elemi szin\u00e9sz t\u00f6mb\u00f6k. Nincs ebben semmi var\u00e1zslat: t\u00f6mb eleme b\u00e1rmi lehet, sz\u00e1m, string, oszt\u00e1ly, vagy ak\u00e1r mint eset\u00fcnkben is, m\u00e1sik t\u00f6mb is: Kb. ilyesmik\u00e9nt kell elk\u00e9pzelni: [ [sz1, sz2], [sz3, sz5, sz6], [sz7] ]. Ez olyan t\u00f6mb, melynek elemei t\u00f6mb\u00f6k, t\u00f6mb\u00f6k t\u00f6mbj\u00e9nek is szoktuk mondani.","title":"b) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: sz\u00edn\u00e9szek t\u00f6mbje"},{"location":"Linq/Linq-csoportositas-feladatok/#c-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-szineszek-neve-vesszovel-elvalasztva","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, mely elemei a csoportban lev\u0151 sz\u00edn\u00e9szek neveit tartalmazz\u00e1k, vessz\u0151vel elv\u00e1lasztva. El\u0151sz\u00f6r pr\u00f3b\u00e1ld ezt magadt\u00f3l elk\u00e9pzelni, csak ut\u00e1na olvasd tov\u00e1bb, s\u00fagok \u2026 A t\u00f6mb elemei itt most stringek, ilyesmi kimenetet v\u00e1runk, h\u00e1rom elem\u0171 string t\u00f6mb\u00f6t: [\"B\u00e9la, J\u00f3zsi\", \"Jani, Juli, G\u00e9za\", \"Misi\" ]","title":"c) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: sz\u00edn\u00e9szek neve vessz\u0151vel elv\u00e1lasztva"},{"location":"Linq/Linq-csoportositas-feladatok/#d-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek","text":"Hasonl\u00f3, mint a b) volt, vagyis most is sz\u00fclet\u00e9si hely szerint csoportos\u00edtunk. A b)-n\u00e9l, ha megn\u00e9zed, megvolt a kimenetben a h\u00e1rom csoport, mert a kimenet h\u00e1rom elem\u0171 t\u00f6mb volt, de nem tudtuk, melyik t\u00f6mb elem/csoport melyik orsz\u00e1ghoz tartozott. Pl. a kimeneti t\u00f6mb nulladik elem\u00e9ben volt k\u00e9t sz\u00edn\u00e9sz, de nem tudtuk megmondani, mely orsz\u00e1g csoportj\u00e1ba tartoztak . Ezt fontos lenne, hogy \u00e9rtsd, ha nem, besz\u00e9lj\u00fck meg! Mindenesetre ez \u00edgy sokszor nem szerencs\u00e9s. A c\u00e9l az, hogy a kimenetben azt is tudjuk, mely csoporthoz tartoznak az elemek (eset\u00fcnkben mely orsz\u00e1ghoz). Ezt t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet oldani. Picit gondolkozz azon, van-e \u00f6tleted\u2026 Meg lehet oldani KeyValuePair haszn\u00e1lat\u00e1val is, de az a k\u00f6vetkez\u0151 feladat lesz, most m\u00e9g hagyjuk. Els\u0151 k\u00f6rben egy \u201enyersebb\u201d megold\u00e1st n\u00e9z\u00fcnk, mert az sokszor \u00e1ltal\u00e1nosabb \u00e9s jobban haszn\u00e1lhat\u00f3, csak egy kicsit munk\u00e1sabb. A megold\u00e1s alapelve az, hogy bevezet\u00fcnk egy \u00faj oszt\u00e1ly, mely a kimenet egy csoportj\u00e1t (ami a t\u00f6mb egy eleme) fogja reprezent\u00e1lni. Mire is van sz\u00fcks\u00e9g minden egyes csoportn\u00e1l: az orsz\u00e1gn\u00e9vre, illetve hozz\u00e1 tartoz\u00f3 szin\u00e9szek t\u00f6mbj\u00e9re. vagyis egy ilyen oszt\u00e1lyt kell bevezetni: class SzineszCsoport { public string Orszag ; public Szinesz [] Szineszek ; < \u00cdrj m\u00e9g egy konstruktort , minek van k\u00e9t param\u00e9tere , az orsz\u00e1g \u00e9s a szineszek , erre sz\u00fcks\u00e9g lesz > } Ha ez megvan, akkor hasonl\u00f3an kell dolgozni, mint a b)-n\u00e9l, csak a Select-ben a csoportokat nem Szinesz t\u00f6mbre, hanem SzineszCsoport oszt\u00e1lyra kell lepezni, egy ilyet kell a new-val l\u00e9trehozni. Egy picit pr\u00f3b\u00e1lkozz, \u00e9s besz\u00e9lj\u00fck meg, ebben sokminden volt.","title":"d) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek"},{"location":"Linq/Linq-csoportositas-feladatok/#e-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek-eletkora-vesszovel-elvalasztva","text":"Ugyanaz, mint az el\u0151z\u0151, csak a kimenetben az orsz\u00e1gokhoz nem a szin\u00e9szek t\u00f6mbj\u00e9t, hanem a sz\u00edn\u00e9szek \u00e9letkor\u00e1nak vessz\u0151vel \u00f6sszef\u0171z\u00f6tt \u00e9vsz\u00e1m\u00e1t szeretn\u00e9nk l\u00e1tni. Tipp: vezess be egy SzineszCsoportEvekkel oszt\u00e1lyt, ebben a string Orszag mellett nem szinesz t\u00f6mb, hanem string evek legyen.","title":"e) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00e9letkora vessz\u0151vel elv\u00e1lasztva"},{"location":"Linq/Linq-csoportositas-feladatok/#f-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek-de-most-a-beepitett-keyvaluepair-rel","text":"Hasonl\u00f3, mint a d) el\u0151z\u0151, csak itt nem akarunk \u00faj oszt\u00e1lyt (SzineszCsoport oszt\u00e1ly) bevezetni. De a c\u00e9lunk ugyanaz, vagyis legyen meg minden csoportra az orsz\u00e1g is, valamint a benne lev\u0151 sz\u00edn\u00e9szek is. A megold\u00e1s elve az, hogy nem vezet\u00fcnk be SzineszCsoport oszt\u00e1lyt, hanem helyette a be\u00e9p\u00edtett KeyValuePair-t haszn\u00e1ljuk. Minden csoportn\u00e1l a kulcs (vagyis a Key) az orsz\u00e1g, hiszen eszerint csoportos\u00edtunk, a Value, a kulcshoz tartoz\u00f3 \u00e9rt\u00e9k pedig \u2026 ezt pr\u00f3b\u00e1ld kital\u00e1lni, hogy \u00e9rdemes.","title":"f) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek, de most a be\u00e9p\u00edtett KeyValuePair-rel"},{"location":"Linq/Linq-csoportositas-feladatok/#g-csoportositas-szinesznev-kezdobetu-alapjan-sorrendezve","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket aszerint, hogy milyen bet\u0171vel kezd\u0151dik a nev\u00fck. KeyValuePair-rel dolgozz. Az egyes csoportokban ne a csoportban lev\u0151 sz\u00edn\u00e9szeket, hanem a csoportban lev\u0151 sz\u00edn\u00e9szek neveit c\u00edmeit t\u00e1rold t\u00f6mbben. A kimenet legyen sorrendezve a n\u00e9v kezd\u0151bet\u0171 alapj\u00e1n!","title":"g) Csoportos\u00edt\u00e1s sz\u00edn\u00e9szn\u00e9v kezd\u0151bet\u0171 alapj\u00e1n, sorrendezve"},{"location":"Linq/Linq-kiskerdesek/","text":"LINQ - kisk\u00e9rd\u00e9sek \u00b6 Van egy gy\u0171jtem\u00e9nyed (lehet t\u00f6mb, lista, stb.), ebb\u0151l egy pontosan ilyen elemsz\u00e1m\u00fa, de m\u00e1s gy\u0171jtem\u00e9nyt kell k\u00e9sz\u00edteni, melyben minden elem az els\u0151 gy\u0171jtem\u00e9ny adott eleme alapj\u00e1n \u00e1ll\u00edthat\u00f3 el\u0151. Mit haszn\u00e1ln\u00e1l hozz\u00e1? Egy sz\u00f3ban v\u00e1laszolj! Select","title":"LINQ - kisk\u00e9rd\u00e9sek"},{"location":"Linq/Linq-kiskerdesek/#linq-kiskerdesek","text":"Van egy gy\u0171jtem\u00e9nyed (lehet t\u00f6mb, lista, stb.), ebb\u0151l egy pontosan ilyen elemsz\u00e1m\u00fa, de m\u00e1s gy\u0171jtem\u00e9nyt kell k\u00e9sz\u00edteni, melyben minden elem az els\u0151 gy\u0171jtem\u00e9ny adott eleme alapj\u00e1n \u00e1ll\u00edthat\u00f3 el\u0151. Mit haszn\u00e1ln\u00e1l hozz\u00e1? Egy sz\u00f3ban v\u00e1laszolj! Select","title":"LINQ - kisk\u00e9rd\u00e9sek"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/","text":"Inicializ\u00e1l\u00e1s alapok \u00b6 Objektumok inicializ\u00e1l\u00e1sa (object initilizer) \u00b6 R\u00e9szletes angol le\u00edr\u00e1s: Object initilizers Alepelve: a az objektum new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok \u00e9rt\u00e9k\u00e9t . Ezzel azt nyerj\u00fck, hogy ha nincs az oszt\u00e1lynak ezen tagokat inizializ\u00e1l\u00f3 konstruktora, akkor is kezd\u0151\u00e9rt\u00e9ket tudunk adni ezen tagoknak a l\u00e9trehoz\u00e1skor. A p\u00e9ld\u00e1kban ezen oszt\u00e1lyokat haszn\u00e1ljuk: public class Cim { public string Varos ; public string Utca ; } // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Cim Cim ; // A fenti Cim oszt\u00e1ly objektuma !!! } P\u00e9ld\u00e1k // Pont \u00fagy hozzuk l\u00e9tre a new-val az objektumot, mint eddig // csak folytatjuk a sort {}-lel, \u00e9s k\u00f6zte megadjuk a tagok \u00e9rt\u00e9k\u00e9t Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" } ; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" } ; // Ugyanez, de t\u00f6bb sorba t\u00f6rve (\u00e1ltal\u00e1ban \u00edgy szoktuk) Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" }; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" , } ; // A Szemely oszt\u00e1lynak van Cim tagja, ezt is tudjuk be\u00e1gyazott m\u00f3don inicializ\u00e1lni: ``` csharp Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = cim1 ; // a cim1-et m\u00e1r fent l\u00e9trehoztuk! } // Lehet\u0151s\u00e9g van a be\u00e1gyazott objektumot (Cim) helyben inicializ\u00e1lni // Nagyon gyakran \u00edgy dolgozunk! Ezt tetsz\u0151leges m\u00e9lys\u00e9gben lehets\u00e9ges, // itt egyszint\u0171 a m\u00e9lys\u00e9g. Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = new Cim () { Varos = \"Miskolc\" , Utca = \"Szeretet\" , }; } \u00d6sszefoglal\u00f3 \u00b6 Arra, hogy objektumokat adott \u00e1llapottal, tagv\u00e1ltoz\u00f3 kezd\u0151\u00e9rt\u00e9kekkel hozzunk l\u00e9tre, k\u00e9t lehet\u0151s\u00e9g\u00fcnk is van: Konstruktort \u00edrunk \u00e9s abban \u00e1ll\u00edjuk be a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t. Ez a klasszikus, rugalmas, minden k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt j\u00f3l haszn\u00e1lhat\u00f3 megold\u00e1s. Az itt ismertetett objektum iniciliz\u00e1l\u00e1st haszn\u00e1ljuk. Ez egyszer\u0171bb tud lennni (nem kell konstruktort \u00edrni), de korl\u00e1tozottabban haszn\u00e1lhat\u00f3: Csak akkor m\u0171k\u00f6dik, ha a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok publikusak, amit viszont a gyakorlatban sokszor elker\u00fcl\u00fcnk, \u00e9s ink\u00e1bb v\u00e9dett tagokkal dolgozunk (az\u00e9rt, hogy az objektumot ne lehessen inkonzisztens\u00e9 tenni) M\u00edg a konstruktorba tetsz\u0151leges inicializ\u00e1l\u00f3 k\u00f3dot tudunk tenni (pl. valid\u00e1lni, m\u00e1s f\u00fcggv\u00e9nyeket h\u00edvni, stb.), itt csak a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t tudjuk megadni. A kontruktorral jobban ki tudjuk k\u00e9nyszer\u00edteni a konzisztenci\u00e1t. Pl. egy K\u00f6r osz\u00e1ly eset\u00e9ben el tudjuk v\u00e1rni, hogy l\u00e9trehoz\u00e1skor k\u00f6telez\u0151 legyen megadni a sugarat, s\u0151t, ha a l\u00e9trehoz\u00f3 a new param\u00e9ter\u00e9ben negat\u00edv \u00e9rt\u00e9ket ad meg, akkor ezt tudjuk ellen\u0151rizni \u00e9s hib\u00e1val (kiv\u00e9tellel) jelezni. Megjegyz\u00e9s \u00b6 A LINQ Select haszn\u00e1latakor is j\u00f3l tud j\u00f6nni az objektum inicializ\u00e1l\u00e1s, amikor a => ut\u00e1n \u00faj, de m\u00e1r adott m\u00f3don inicializ\u00e1lt objektumokat kell l\u00e9trehozni, \u00e9s az oszt\u00e1lyban nincs ehhez konstruktor. Pl.: // Ezek csak egyszer\u0171 stringek! string [] varosNevek = new string [] { \"Budapest\" , \"Szeged\" , \"Miskolc\" }; // Minden v\u00e1rosn\u00e9vhez gy\u00e1rtsunk le egy a v\u00e1rosnak megfelel\u0151 c\u00edmet, az utca legyen \"ismeretlen\". Cim [] cimek = varosNevek . Select ( varosnev => new Cim () { Varos = varosnev , Utca = \"ismeretlen\" } ); Gy\u0171jtem\u00e9nyek inicializ\u00e1l\u00e1sa \u00b6 R\u00e9szletes angol le\u00edr\u00e1s: Collection initializers Alepelve: a t\u00f6mb, lista, stb. new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni az elemeket . Int t\u00f6mb p\u00e9lda: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; Int lista p\u00e9lda: List < int > szamok = new List < int > { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; A gy\u0171jtem\u00e9ny elemei lehetnek objektumok is: // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Szemely () { } public Szemely ( string nev , int kor ) { this . Nev = nev ; this . Kor = kor ; } } ... // Minden egy sorban Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // \u00c1ltal\u00e1ban t\u00f6bb sorba t\u00f6rve szoktuk \u00edrni, jobban \u00e1tl\u00e1that\u00f3 Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // Az egyes elemeket objektum inicializ\u00e1l\u00e1ssal is l\u00e9tre lehet hozni (kombin\u00e1ljuk a // gy\u0171jtem\u00e9ny \u00e9s objektum inicializ\u00e1l\u00e1st) Szemely [] szemelyek = new Szemely [] { new Szemely () { Nev = \"Joe\" , Kor = 20 }, new Szemely () { Nev = \"Jill\" , Kor = 23 } };","title":"Inicializ\u00e1l\u00e1s alapok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#inicializalas-alapok","text":"","title":"Inicializ\u00e1l\u00e1s alapok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#objektumok-inicializalasa-object-initilizer","text":"R\u00e9szletes angol le\u00edr\u00e1s: Object initilizers Alepelve: a az objektum new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok \u00e9rt\u00e9k\u00e9t . Ezzel azt nyerj\u00fck, hogy ha nincs az oszt\u00e1lynak ezen tagokat inizializ\u00e1l\u00f3 konstruktora, akkor is kezd\u0151\u00e9rt\u00e9ket tudunk adni ezen tagoknak a l\u00e9trehoz\u00e1skor. A p\u00e9ld\u00e1kban ezen oszt\u00e1lyokat haszn\u00e1ljuk: public class Cim { public string Varos ; public string Utca ; } // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Cim Cim ; // A fenti Cim oszt\u00e1ly objektuma !!! } P\u00e9ld\u00e1k // Pont \u00fagy hozzuk l\u00e9tre a new-val az objektumot, mint eddig // csak folytatjuk a sort {}-lel, \u00e9s k\u00f6zte megadjuk a tagok \u00e9rt\u00e9k\u00e9t Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" } ; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" } ; // Ugyanez, de t\u00f6bb sorba t\u00f6rve (\u00e1ltal\u00e1ban \u00edgy szoktuk) Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" }; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" , } ; // A Szemely oszt\u00e1lynak van Cim tagja, ezt is tudjuk be\u00e1gyazott m\u00f3don inicializ\u00e1lni: ``` csharp Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = cim1 ; // a cim1-et m\u00e1r fent l\u00e9trehoztuk! } // Lehet\u0151s\u00e9g van a be\u00e1gyazott objektumot (Cim) helyben inicializ\u00e1lni // Nagyon gyakran \u00edgy dolgozunk! Ezt tetsz\u0151leges m\u00e9lys\u00e9gben lehets\u00e9ges, // itt egyszint\u0171 a m\u00e9lys\u00e9g. Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = new Cim () { Varos = \"Miskolc\" , Utca = \"Szeretet\" , }; }","title":"Objektumok inicializ\u00e1l\u00e1sa (object initilizer)"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#osszefoglalo","text":"Arra, hogy objektumokat adott \u00e1llapottal, tagv\u00e1ltoz\u00f3 kezd\u0151\u00e9rt\u00e9kekkel hozzunk l\u00e9tre, k\u00e9t lehet\u0151s\u00e9g\u00fcnk is van: Konstruktort \u00edrunk \u00e9s abban \u00e1ll\u00edjuk be a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t. Ez a klasszikus, rugalmas, minden k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt j\u00f3l haszn\u00e1lhat\u00f3 megold\u00e1s. Az itt ismertetett objektum iniciliz\u00e1l\u00e1st haszn\u00e1ljuk. Ez egyszer\u0171bb tud lennni (nem kell konstruktort \u00edrni), de korl\u00e1tozottabban haszn\u00e1lhat\u00f3: Csak akkor m\u0171k\u00f6dik, ha a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok publikusak, amit viszont a gyakorlatban sokszor elker\u00fcl\u00fcnk, \u00e9s ink\u00e1bb v\u00e9dett tagokkal dolgozunk (az\u00e9rt, hogy az objektumot ne lehessen inkonzisztens\u00e9 tenni) M\u00edg a konstruktorba tetsz\u0151leges inicializ\u00e1l\u00f3 k\u00f3dot tudunk tenni (pl. valid\u00e1lni, m\u00e1s f\u00fcggv\u00e9nyeket h\u00edvni, stb.), itt csak a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t tudjuk megadni. A kontruktorral jobban ki tudjuk k\u00e9nyszer\u00edteni a konzisztenci\u00e1t. Pl. egy K\u00f6r osz\u00e1ly eset\u00e9ben el tudjuk v\u00e1rni, hogy l\u00e9trehoz\u00e1skor k\u00f6telez\u0151 legyen megadni a sugarat, s\u0151t, ha a l\u00e9trehoz\u00f3 a new param\u00e9ter\u00e9ben negat\u00edv \u00e9rt\u00e9ket ad meg, akkor ezt tudjuk ellen\u0151rizni \u00e9s hib\u00e1val (kiv\u00e9tellel) jelezni.","title":"\u00d6sszefoglal\u00f3"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#megjegyzes","text":"A LINQ Select haszn\u00e1latakor is j\u00f3l tud j\u00f6nni az objektum inicializ\u00e1l\u00e1s, amikor a => ut\u00e1n \u00faj, de m\u00e1r adott m\u00f3don inicializ\u00e1lt objektumokat kell l\u00e9trehozni, \u00e9s az oszt\u00e1lyban nincs ehhez konstruktor. Pl.: // Ezek csak egyszer\u0171 stringek! string [] varosNevek = new string [] { \"Budapest\" , \"Szeged\" , \"Miskolc\" }; // Minden v\u00e1rosn\u00e9vhez gy\u00e1rtsunk le egy a v\u00e1rosnak megfelel\u0151 c\u00edmet, az utca legyen \"ismeretlen\". Cim [] cimek = varosNevek . Select ( varosnev => new Cim () { Varos = varosnev , Utca = \"ismeretlen\" } );","title":"Megjegyz\u00e9s"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#gyujtemenyek-inicializalasa","text":"R\u00e9szletes angol le\u00edr\u00e1s: Collection initializers Alepelve: a t\u00f6mb, lista, stb. new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni az elemeket . Int t\u00f6mb p\u00e9lda: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; Int lista p\u00e9lda: List < int > szamok = new List < int > { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; A gy\u0171jtem\u00e9ny elemei lehetnek objektumok is: // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Szemely () { } public Szemely ( string nev , int kor ) { this . Nev = nev ; this . Kor = kor ; } } ... // Minden egy sorban Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // \u00c1ltal\u00e1ban t\u00f6bb sorba t\u00f6rve szoktuk \u00edrni, jobban \u00e1tl\u00e1that\u00f3 Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // Az egyes elemeket objektum inicializ\u00e1l\u00e1ssal is l\u00e9tre lehet hozni (kombin\u00e1ljuk a // gy\u0171jtem\u00e9ny \u00e9s objektum inicializ\u00e1l\u00e1st) Szemely [] szemelyek = new Szemely [] { new Szemely () { Nev = \"Joe\" , Kor = 20 }, new Szemely () { Nev = \"Jill\" , Kor = 23 } };","title":"Gy\u0171jtem\u00e9nyek inicializ\u00e1l\u00e1sa"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/","text":"Inicializ\u00e1l\u00e1s feladatok \u00b6 Feladat 1 \u00b6 \u00cdrj egy Kerek (mint j\u00e1rm\u0171ker\u00e9k) oszt\u00e1lyt. K\u00e9t tulajdons\u00e1ga van: int Atmero , double Nyomas . \u00cdrj egy Auto oszt\u00e1ly, melynek van n\u00e9gy kereke ( Kerek t\u00f6mb) \u00e9s sz\u00edne ( string Szin ). Hozz l\u00e9tre egy Auto objektumot egyetlen inicializ\u00e1l\u00f3 kifejez\u00e9ssel (mind a n\u00e9gy kerek\u00e9vel egyszerre). Az aut\u00f3 sz\u00edne k\u00e9k, van n\u00e9gy kereke. A kerekek \u00e1tm\u00e9r\u0151je legyen ugyanaz, de a nyom\u00e1s legyen mindn\u00e9l kicsit m\u00e1s. Feladat 2 \u00b6 Adott az al\u00e1bbi k\u00f3d: public class Szampar { public int Szam1 ; public int Szam2 ; } // A Main f\u00fcggv\u00e9nyben: Szampar [] szamparok = new Szampar [] { new Szampar () { Szam1 = 2 , Szam2 = 3 }, new Szampar () { Szam1 = 4 , Szam2 = 8 }, new Szampar () { Szam1 = 10 , Szam2 = 20 } }; \u00cdrj egy Teglalap osz\u00e1lyt, melynek van Szelesseg \u00e9s Magassag tagja. Konstruktort ne \u00edrj hozz\u00e1. A Main f\u00fcggv\u00e9nyben a fenti szamparok mindegyike alapj\u00e1n \u00e1ll\u00edts el\u0151 egy t\u00e9galalapot egy Tegalap list\u00e1ban, minden t\u00e9glalap eset\u00e9n a szeless\u00e9g az adott sz\u00e1mp\u00e1r els\u0151 tagj\u00e1nak dupl\u00e1ja, a magass\u00e1g pedig az adott sz\u00e1mp\u00e1r m\u00e1sodik tagj\u00e1nak n\u00e9gyzete legyen. A megold\u00e1sodban ne haszn\u00e1lj semmilyen ciklust! (gondolj arra, hogy egy sz\u00e1mp\u00e1r gy\u0171jtem\u00e9nyt kell lek\u00e9pezni egy m\u00e1sik gy\u0171jtem\u00e9nyre, mit is szoktunk erre haszn\u00e1lni).","title":"Inicializ\u00e1l\u00e1s feladatok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/#inicializalas-feladatok","text":"","title":"Inicializ\u00e1l\u00e1s feladatok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/#feladat-1","text":"\u00cdrj egy Kerek (mint j\u00e1rm\u0171ker\u00e9k) oszt\u00e1lyt. K\u00e9t tulajdons\u00e1ga van: int Atmero , double Nyomas . \u00cdrj egy Auto oszt\u00e1ly, melynek van n\u00e9gy kereke ( Kerek t\u00f6mb) \u00e9s sz\u00edne ( string Szin ). Hozz l\u00e9tre egy Auto objektumot egyetlen inicializ\u00e1l\u00f3 kifejez\u00e9ssel (mind a n\u00e9gy kerek\u00e9vel egyszerre). Az aut\u00f3 sz\u00edne k\u00e9k, van n\u00e9gy kereke. A kerekek \u00e1tm\u00e9r\u0151je legyen ugyanaz, de a nyom\u00e1s legyen mindn\u00e9l kicsit m\u00e1s.","title":"Feladat 1"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/#feladat-2","text":"Adott az al\u00e1bbi k\u00f3d: public class Szampar { public int Szam1 ; public int Szam2 ; } // A Main f\u00fcggv\u00e9nyben: Szampar [] szamparok = new Szampar [] { new Szampar () { Szam1 = 2 , Szam2 = 3 }, new Szampar () { Szam1 = 4 , Szam2 = 8 }, new Szampar () { Szam1 = 10 , Szam2 = 20 } }; \u00cdrj egy Teglalap osz\u00e1lyt, melynek van Szelesseg \u00e9s Magassag tagja. Konstruktort ne \u00edrj hozz\u00e1. A Main f\u00fcggv\u00e9nyben a fenti szamparok mindegyike alapj\u00e1n \u00e1ll\u00edts el\u0151 egy t\u00e9galalapot egy Tegalap list\u00e1ban, minden t\u00e9glalap eset\u00e9n a szeless\u00e9g az adott sz\u00e1mp\u00e1r els\u0151 tagj\u00e1nak dupl\u00e1ja, a magass\u00e1g pedig az adott sz\u00e1mp\u00e1r m\u00e1sodik tagj\u00e1nak n\u00e9gyzete legyen. A megold\u00e1sodban ne haszn\u00e1lj semmilyen ciklust! (gondolj arra, hogy egy sz\u00e1mp\u00e1r gy\u0171jtem\u00e9nyt kell lek\u00e9pezni egy m\u00e1sik gy\u0171jtem\u00e9nyre, mit is szoktunk erre haszn\u00e1lni).","title":"Feladat 2"},{"location":"ObjektumokLetrehozasa/Konstruktor/konstruktor-alapok/","text":"Konstruktor alapok \u00b6 TODO","title":"Konstruktor alapok"},{"location":"ObjektumokLetrehozasa/Konstruktor/konstruktor-alapok/#konstruktor-alapok","text":"TODO","title":"Konstruktor alapok"},{"location":"Static/static-feladatok/","text":"Statikus tagok - feladatok \u00b6 Feladat 1 \u00b6 \u00cdrj egy Matek oszt\u00e1lyt, melynek van egy Osszead \u00e9s Kivon m\u0171velete (melyek visszat\u00e9rnek k\u00e9t eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9vel, ill. k\u00fcl\u00f6nbs\u00e9g\u00e9vel). A Matek oszt\u00e1lyt k\u00e9nyelmesen lehessen haszn\u00e1lni, ne kelljen ehhez objektumokat a new-val l\u00e9trehozni. Mutass p\u00e9ld\u00e1kat a k\u00e9r m\u0171velet haszn\u00e1lat\u00e1ra. Feladat 2 \u00b6 \u00cdrj egy Bomba oszt\u00e1lyt. Minden bomb\u00e1r\u00f3l r\u00e1tolni kell a robban\u00f3erej\u00e9t (int) \u00e9s fel felrobbant-e (bool). Egy bomb\u00e1t felrobbantan a Robban m\u0171velet\u00e9vel lehet, ez a felrobbant \u00e1llapot\u00e1t igazba teszi. Az alkalmaz\u00e1sban lek\u00e9rdezhet\u0151v\u00e9 kell tenni, hogy \u00f6sszesen h\u00e1ny bomba robbant fel! Ennek nyilv\u00e1ntart\u00e1s\u00e1t/lek\u00e9rdezhet\u0151s\u00e9g\u00e9t r\u00e1 lehetne b\u00edzni egy k\u00fcl\u00f6n oszt\u00e1lyba, de a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9p\u00edtsd be mag\u00e1ba a Bomba oszt\u00e1lyba. A megold\u00e1sod teszteld a Main f\u00fcggv\u00e9nyben: hozz l\u00e9tre p\u00e1r bomb\u00e1t, robbantsd fel \u00e9s p\u00e1r helyen \u00edrd ki a felrobbant bomb\u00e1k darabsz\u00e1m\u00e1t!","title":"Statikus tagok - feladatok"},{"location":"Static/static-feladatok/#statikus-tagok-feladatok","text":"","title":"Statikus tagok - feladatok"},{"location":"Static/static-feladatok/#feladat-1","text":"\u00cdrj egy Matek oszt\u00e1lyt, melynek van egy Osszead \u00e9s Kivon m\u0171velete (melyek visszat\u00e9rnek k\u00e9t eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9vel, ill. k\u00fcl\u00f6nbs\u00e9g\u00e9vel). A Matek oszt\u00e1lyt k\u00e9nyelmesen lehessen haszn\u00e1lni, ne kelljen ehhez objektumokat a new-val l\u00e9trehozni. Mutass p\u00e9ld\u00e1kat a k\u00e9r m\u0171velet haszn\u00e1lat\u00e1ra.","title":"Feladat 1"},{"location":"Static/static-feladatok/#feladat-2","text":"\u00cdrj egy Bomba oszt\u00e1lyt. Minden bomb\u00e1r\u00f3l r\u00e1tolni kell a robban\u00f3erej\u00e9t (int) \u00e9s fel felrobbant-e (bool). Egy bomb\u00e1t felrobbantan a Robban m\u0171velet\u00e9vel lehet, ez a felrobbant \u00e1llapot\u00e1t igazba teszi. Az alkalmaz\u00e1sban lek\u00e9rdezhet\u0151v\u00e9 kell tenni, hogy \u00f6sszesen h\u00e1ny bomba robbant fel! Ennek nyilv\u00e1ntart\u00e1s\u00e1t/lek\u00e9rdezhet\u0151s\u00e9g\u00e9t r\u00e1 lehetne b\u00edzni egy k\u00fcl\u00f6n oszt\u00e1lyba, de a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9p\u00edtsd be mag\u00e1ba a Bomba oszt\u00e1lyba. A megold\u00e1sod teszteld a Main f\u00fcggv\u00e9nyben: hozz l\u00e9tre p\u00e1r bomb\u00e1t, robbantsd fel \u00e9s p\u00e1r helyen \u00edrd ki a felrobbant bomb\u00e1k darabsz\u00e1m\u00e1t!","title":"Feladat 2"},{"location":"Static/static/","text":"Statikus tagok \u00b6 Induljunk ki egy olyan oszt\u00e1lyb\u00f3l, melynek van k\u00e9t k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3ja \u00e9s tagf\u00fcggv\u00e9nye (m\u0171velete): class Teglalap { public double Szelesseg ; public double Magassag ; public double Terulet () { return Szelesseg * Magassag ; } } Az al\u00e1bbiakban l\u00e9trehozuk a Teglalap oszt\u00e1lyb\u00f3l k\u00e9t egym\u00e1st\u00f3l f\u00fcggetlen t1 \u00e9s t2 nev\u0171 t\u00e9glalap objektumot, elt\u00e9r\u0151 sz\u00e9less\u00e9g \u00e9s magass\u00e1g \u00e9rt\u00e9kekkel, majd ki\u00edrjuk ezek ter\u00fclet\u00e9t a konzolra. static void Main ( string [] args ) { Teglalap t1 = new Teglalap (); // #1 t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet () ); Teglalap t2 = new Teglalap (); // #2 t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagv\u00e1ltoz\u00f3 \u00b6 A feladat legyen a k\u00f6vetkez\u0151. Tartsuk nyilv\u00e1n egy sz\u00e1ml\u00e1l\u00f3ban, hogy h\u00e1ny objektumot hoztunk l\u00e9tre a Teglalap oszt\u00e1lyb\u00f3l. Ha b\u00e1rhol a programban l\u00e9trehozunk egy \u00faj Teglalap objektumot, akkor ennek a sz\u00e1ml\u00e1l\u00f3nak eggyel n\u0151nie kell. A fenti Main f\u00fcggv\u00e9ny p\u00e9ld\u00e1t n\u00e9zve, am\u00edg a // #1 megjegyz\u00e9ssel ell\u00e1tott sorban az objektumot nem hoztuk l\u00e9tre, addig a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ke 0, ezt k\u00f6vet\u0151en 1, majd a // #2 sor ut\u00e1n 2 kell legyen. Egy nagy, komplex alkalmaz\u00e1sban sok ezer helyen hozhatunk l\u00e9tre Teglalap objektumot, nem akarunk minden helyen sz\u00e1ml\u00e1l\u00f3t n\u00f6velni, csak egy k\u00f6zponti helyen. \u00cdgy tegy\u00fck bele ezt a sz\u00e1ml\u00e1l\u00f3t mag\u00e1ba a Teglalap oszt\u00e1lyba, \u00e9s n\u00f6velj\u00fck annak konstruktor\u00e1ban, hiszen a konstruktor pont akkor h\u00edv\u00f3dik, amikor egy \u00faj objektum l\u00e9trej\u00f6n: class Teglalap { public double Szelesseg ; public double Magassag ; public int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Ez \u00edgy m\u00e9g nem lesz j\u00f3. A probl\u00e9ma az, hogy a Szamlalo egy k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3, minden t\u00e9glalap objektumhoz k\u00fcl\u00f6n \u00e9rt\u00e9ke lesz 0 kezd\u0151\u00e9rt\u00e9kkel (a fenti p\u00e9ld\u00e1nkban a t1 \u00e9s t2 objektumokn\u00e1l k\u00fcl\u00f6n-k\u00fcl\u00f6n), pont \u00fagy, mint a Szelesseg \u00e9s Magassag tagv\u00e1ltoz\u00f3k eset\u00e9n. Ehelyett nek\u00fcnk egy olyan v\u00e1ltoz\u00f3 kell, ami nem Teglalap objektumonk\u00e9nt van, hanem minden Teglalap objektumra k\u00f6z\u00f6s, mag\u00e1hoz az oszt\u00e1lyhoz tartozik egyetlen \u00e9rt\u00e9k, \u00e9s m\u00e1r akkor is l\u00e9tezik, amikor m\u00e9g egyetlen objektumot sem hoztunk l\u00e9tre (ekkor az \u00e9rt\u00e9ke eset\u00fcnkben 0). Ehhez a Szamlalo tagot statikuss\u00e1 kell tenni, el\u00e9 kell \u00edrni a static kulcssz\u00f3t: class Teglalap { public double Szelesseg ; public double Magassag ; public static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } \u00cdgy a Szamlalo m\u00e1r az oszt\u00e1lyhoz tartozik (nem objektumonk\u00e9nt foglal\u00f3dik neki t\u00e1rhely), minden objektum\u00e1ra k\u00f6z\u00f6s, \u00e9s akkor is l\u00e9tezik, ha m\u00e9g egy Teglalap objektumot sem hoztunk l\u00e9tre. Valami ilyesmi a mem\u00f3riak\u00e9p a fenti, Main f\u00fcggv\u00e9nybeli haszn\u00e1lat sor\u00e1n: Az ilyen v\u00e1ltoz\u00f3k el\u00e9r\u00e9s\u00e9hez nem kell objektumot l\u00e9trehozni, hanem az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rj\u00fck el a \".\"-tal, a p\u00e9ld\u00e1nkban \u00edgy: Teglalap.Szamlalo A teljes p\u00e9lda, mely ki is \u00edrja t\u00f6bb helyen is a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t. static void Main ( string [] args ) { int teglalapokSzama = Teglalap . Szamlalo ; Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcgg\u00e9ny \u00b6 A megold\u00e1sunk m\u00e9g nem t\u00f6k\u00e9letes. A Szamlalo tag publikus a Teglalap oszt\u00e1lyban. \u00cdgy b\u00e1rhol valaki v\u00e9letlen vagy sz\u00e1nd\u00e9skosan elronthatja a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t, pl. ki tudja null\u00e1zni az al\u00e1bbis sorral, akkor is, ha m\u00e1r volt bel\u0151le objektum, \u00edgy \u00e9rt\u00e9ke hamis lesz: Teglalap.Szamlalo = 0; Ezt \u00fagy tudjuk megakad\u00e1lyozni, hogy a Szamlalo -t a Teglalap oszt\u00e1lyban v\u00e9dett\u00e9, priv\u00e1tt\u00e1 tessz\u00fck, ekkor ha m\u00e1s oszt\u00e1lyban pr\u00f3b\u00e1ljuk megv\u00e1ltoztatni az \u00e9rt\u00e9k\u00e9t, akkor a k\u00f3d le sem fordul (a priv\u00e1t tagokhoz csak az adott oszt\u00e1ly f\u00e9rhet hozz\u00e1, eset\u00fcnkben Teglalap , ez persze a norm\u00e1l, nem statikus tagokra is igaz). class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Most m\u00e1r nem lehet elrontani m\u00e1s oszt\u00e1lyb\u00f3l a sz\u00e1ml\u00e1l\u00f3t. De mivel private, lek\u00e9rdezni sem lehet m\u00e1r. Ez probl\u00e9ma, hiszen az pont c\u00e9lunk volt, hogy az aktu\u00e1lis sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ket le lehessen k\u00e9rdezni, b\u00e1rhonnan, pl. a Main f\u00fcggv\u00e9nyb\u0151l is, ahogy azt eddig is tett\u00fck. A megold\u00e1s egyszer\u0171: vezezz\u00fcnk be egy tagf\u00fcggv\u00e9nyt (legyen a neve SzamlaloErtek), ami publikus, \u00e9s le lehet vele k\u00e9rdezni a v\u00e9dett Szamlalo \u00e9rt\u00e9k\u00e9t: class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public static int SzamlaloErtek () { return Szamlalo ; } public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } A SzamlaloErtek tagf\u00fcggv\u00e9nyt statikuss\u00e1 is tett\u00fck a static kulcssz\u00f3val! Ez nagyon fontos, hiszen a statikus tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an csak \u00edgy tudjuk megh\u00edvni objektumok n\u00e9lk\u00fcl az oszt\u00e1ly nev\u00e9n kereszt\u00fcl (ak\u00e1r akkor is, ha m\u00e9g egy objektum sem l\u00e9tezik bel\u0151le): Teglalap.SzamlaloErtek() A Main f\u00fcggv\u00e9nyt is alak\u00edtsuk \u00e1t, hogy ezt a statikus tagf\u00fcggv\u00e9nyt haszn\u00e1lja: static void Main ( string [] args ) { int teglalapokSzama = Teglalap . SzamlaloErtek (); Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcggv\u00e9nyt m\u00e1r j\u00f3p\u00e1r alkalommal haszn\u00e1ltunk. Pl. a Console.WriteLine() eset\u00e9n. A Console egy be\u00e9p\u00edtett oszt\u00e1ly, a WriteLine ennek egy statikus tagf\u00fcggv\u00e9nye. Ha nem lenne statikus, akkor csak objektumra lehetne h\u00edvni, vagyis el\u0151bb l\u00e9tre kellene hozni a new-val egy Console objektumot, \u00edgy: Console c1 = new Console (); c1 . WriteLine (); Ez itt feleslegesen macer\u00e1s lenne, mi nem akarunk k\u00fcl\u00f6nb\u00f6z\u0151 Console objektumokkal bajl\u00f3dni. Hasonl\u00f3 a be\u00e9p\u00edtett Math oszt\u00e1ly is, ennek is egy csom\u00f3s statikus tagf\u00fcggv\u00e9nye van, \u00edgy k\u00e9nyelmesen a Math.Abs(-12) , nem kell Math objektumokat l\u00e9trehozni. Ez \u00edgy k\u00e9nyelmesebb, \u00e9s \u00e9rtelmesebb is, hiszen a Math oszt\u00e1lynak nincsenek \u00e1llapotot ad\u00f3 tagv\u00e1ltoz\u00f3i, szemben pl. a Teglalap oszt\u00e1lyunkkal, aminek van, hiszen a Szelesseg \u00e9s Magassag eset\u00e9n fontos, hogy az minden Tegalalap objektumra k\u00fcl\u00f6n t\u00e1rol\u00f3djon. Ilyen a string.Join(\",\", elemek) , ahol a '.'-t el\u0151tt a string a string oszt\u00e1ly neve (Megjegyz\u00e9s: C#-ban a kis \u00e9s nagybet\u0171vel kezd\u0151d\u0151 string / String ugyanazt jelenti.) Az alkalmaz\u00e1sok bel\u00e9p\u00e9si pontja, a Program oszt\u00e1ly Main f\u00fcgg\u00e9nye is statikus. Szab\u00e1lyok \u00b6 Fontos: Statikus tagf\u00fcggv\u00e9nyb\u0151l a norm\u00e1l (vagyis nem statikus) tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem lehet el\u00e9rni. Ezt meg kell tanulni, mert k\u00fcl\u00f6nben gyakran beleszalad az ember. De egy p\u00e9lda \u00e9rthet\u0151v\u00e9 is teszi: class Teglalap { public double Szelesseg ; public double Magassag ; public static double Terulet () { return Szelesseg * Magassag ; } } A p\u00e9ld\u00e1ban a Terulet() statikus tagf\u00fcggv\u00e9ny, ebb\u0151l pr\u00f3b\u00e1lunk el\u00e9rni k\u00e9t nem statikus tagot ( Szelesseg , \u00e9s Magassag ). Mivel a Terulet() statikus, nem objektumokre, hanem a Teglalap oszt\u00e1lyra tudjuk megh\u00edvni: double ter = Teglalap . Terulet (); A probl\u00e9ma az, hogy a Terulet() el\u0151tt nem objektum, hanem oszt\u00e1ly \u00e1ll, \u00edgy amikor a Terulet() f\u00fcggv\u00e9nyben hivatkozunk a nem statikus Szelesseg \u00e9s Magassag tagokra, akkor azok melyik t\u00e9galalap objektum sz\u00e9less\u00e9g\u00e9t \u00e9s magass\u00e1g\u00e1t is jelenten\u00e9k? M\u00e9g az is lehet, egyetlen Teglalap objektum sem l\u00e9tezik ekkor. Ha a Ter\u00fclet() h\u00edv\u00e1sakor a '.' el\u0151tt egy adott teglalap objektum \u00e1llna, akkor adn\u00e1 mag\u00e1t, de \u00edgy ennek nincs \u00e9rtelme. A m\u00e1sik ir\u00e1nyba nincs ilyen megk\u00f6t\u00e9s (ez is logikus): nem statikus tagf\u00fcggv\u00e9nyb\u0151l statikus tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket el lehet \u00e9rni. \u00d6sszefoglal\u00f3 \u00b6 A legfontosabb gondolatok A statikus tagv\u00e1ltoz\u00f3k az oszt\u00e1lyhoz tartoznak, annak minden objektum\u00e1ra k\u00f6z\u00f6sek Az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rhet\u0151k el, pl. Teglalap.Szamlalo, Teglalap.SzamlaloErtek(), Console.WriteLine(...), Math.Abs(...) Statikus tagf\u00fcggv\u00e9nyb\u0151l nem statikus tagokat nem lehet el\u00e9rni (nincs is \u00e9rtelme) A statikus tagv\u00e1ltoz\u00f3k \u00e9s tagf\u00fcggv\u00e9nyek haszn\u00e1lata sokszor k\u00e9nyelmes, de nem szabad t\u00falz\u00e1sba esni. Leggyakrabban olyan oszt\u00e1lyok eset\u00e9n haszn\u00e1ljuk, mint a Math, ahol az oszt\u00e1ly \u00e1llapottal (tagv\u00e1ltoz\u00f3kkal) nem rendelkezik, hanem csak egyszer\u0171 f\u00fcggv\u00e9nyek gy\u0171jtem\u00e9nye.","title":"Statikus tagok"},{"location":"Static/static/#statikus-tagok","text":"Induljunk ki egy olyan oszt\u00e1lyb\u00f3l, melynek van k\u00e9t k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3ja \u00e9s tagf\u00fcggv\u00e9nye (m\u0171velete): class Teglalap { public double Szelesseg ; public double Magassag ; public double Terulet () { return Szelesseg * Magassag ; } } Az al\u00e1bbiakban l\u00e9trehozuk a Teglalap oszt\u00e1lyb\u00f3l k\u00e9t egym\u00e1st\u00f3l f\u00fcggetlen t1 \u00e9s t2 nev\u0171 t\u00e9glalap objektumot, elt\u00e9r\u0151 sz\u00e9less\u00e9g \u00e9s magass\u00e1g \u00e9rt\u00e9kekkel, majd ki\u00edrjuk ezek ter\u00fclet\u00e9t a konzolra. static void Main ( string [] args ) { Teglalap t1 = new Teglalap (); // #1 t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet () ); Teglalap t2 = new Teglalap (); // #2 t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); }","title":"Statikus tagok"},{"location":"Static/static/#statikus-tagvaltozo","text":"A feladat legyen a k\u00f6vetkez\u0151. Tartsuk nyilv\u00e1n egy sz\u00e1ml\u00e1l\u00f3ban, hogy h\u00e1ny objektumot hoztunk l\u00e9tre a Teglalap oszt\u00e1lyb\u00f3l. Ha b\u00e1rhol a programban l\u00e9trehozunk egy \u00faj Teglalap objektumot, akkor ennek a sz\u00e1ml\u00e1l\u00f3nak eggyel n\u0151nie kell. A fenti Main f\u00fcggv\u00e9ny p\u00e9ld\u00e1t n\u00e9zve, am\u00edg a // #1 megjegyz\u00e9ssel ell\u00e1tott sorban az objektumot nem hoztuk l\u00e9tre, addig a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ke 0, ezt k\u00f6vet\u0151en 1, majd a // #2 sor ut\u00e1n 2 kell legyen. Egy nagy, komplex alkalmaz\u00e1sban sok ezer helyen hozhatunk l\u00e9tre Teglalap objektumot, nem akarunk minden helyen sz\u00e1ml\u00e1l\u00f3t n\u00f6velni, csak egy k\u00f6zponti helyen. \u00cdgy tegy\u00fck bele ezt a sz\u00e1ml\u00e1l\u00f3t mag\u00e1ba a Teglalap oszt\u00e1lyba, \u00e9s n\u00f6velj\u00fck annak konstruktor\u00e1ban, hiszen a konstruktor pont akkor h\u00edv\u00f3dik, amikor egy \u00faj objektum l\u00e9trej\u00f6n: class Teglalap { public double Szelesseg ; public double Magassag ; public int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Ez \u00edgy m\u00e9g nem lesz j\u00f3. A probl\u00e9ma az, hogy a Szamlalo egy k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3, minden t\u00e9glalap objektumhoz k\u00fcl\u00f6n \u00e9rt\u00e9ke lesz 0 kezd\u0151\u00e9rt\u00e9kkel (a fenti p\u00e9ld\u00e1nkban a t1 \u00e9s t2 objektumokn\u00e1l k\u00fcl\u00f6n-k\u00fcl\u00f6n), pont \u00fagy, mint a Szelesseg \u00e9s Magassag tagv\u00e1ltoz\u00f3k eset\u00e9n. Ehelyett nek\u00fcnk egy olyan v\u00e1ltoz\u00f3 kell, ami nem Teglalap objektumonk\u00e9nt van, hanem minden Teglalap objektumra k\u00f6z\u00f6s, mag\u00e1hoz az oszt\u00e1lyhoz tartozik egyetlen \u00e9rt\u00e9k, \u00e9s m\u00e1r akkor is l\u00e9tezik, amikor m\u00e9g egyetlen objektumot sem hoztunk l\u00e9tre (ekkor az \u00e9rt\u00e9ke eset\u00fcnkben 0). Ehhez a Szamlalo tagot statikuss\u00e1 kell tenni, el\u00e9 kell \u00edrni a static kulcssz\u00f3t: class Teglalap { public double Szelesseg ; public double Magassag ; public static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } \u00cdgy a Szamlalo m\u00e1r az oszt\u00e1lyhoz tartozik (nem objektumonk\u00e9nt foglal\u00f3dik neki t\u00e1rhely), minden objektum\u00e1ra k\u00f6z\u00f6s, \u00e9s akkor is l\u00e9tezik, ha m\u00e9g egy Teglalap objektumot sem hoztunk l\u00e9tre. Valami ilyesmi a mem\u00f3riak\u00e9p a fenti, Main f\u00fcggv\u00e9nybeli haszn\u00e1lat sor\u00e1n: Az ilyen v\u00e1ltoz\u00f3k el\u00e9r\u00e9s\u00e9hez nem kell objektumot l\u00e9trehozni, hanem az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rj\u00fck el a \".\"-tal, a p\u00e9ld\u00e1nkban \u00edgy: Teglalap.Szamlalo A teljes p\u00e9lda, mely ki is \u00edrja t\u00f6bb helyen is a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t. static void Main ( string [] args ) { int teglalapokSzama = Teglalap . Szamlalo ; Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); }","title":"Statikus tagv\u00e1ltoz\u00f3"},{"location":"Static/static/#statikus-tagfuggeny","text":"A megold\u00e1sunk m\u00e9g nem t\u00f6k\u00e9letes. A Szamlalo tag publikus a Teglalap oszt\u00e1lyban. \u00cdgy b\u00e1rhol valaki v\u00e9letlen vagy sz\u00e1nd\u00e9skosan elronthatja a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t, pl. ki tudja null\u00e1zni az al\u00e1bbis sorral, akkor is, ha m\u00e1r volt bel\u0151le objektum, \u00edgy \u00e9rt\u00e9ke hamis lesz: Teglalap.Szamlalo = 0; Ezt \u00fagy tudjuk megakad\u00e1lyozni, hogy a Szamlalo -t a Teglalap oszt\u00e1lyban v\u00e9dett\u00e9, priv\u00e1tt\u00e1 tessz\u00fck, ekkor ha m\u00e1s oszt\u00e1lyban pr\u00f3b\u00e1ljuk megv\u00e1ltoztatni az \u00e9rt\u00e9k\u00e9t, akkor a k\u00f3d le sem fordul (a priv\u00e1t tagokhoz csak az adott oszt\u00e1ly f\u00e9rhet hozz\u00e1, eset\u00fcnkben Teglalap , ez persze a norm\u00e1l, nem statikus tagokra is igaz). class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Most m\u00e1r nem lehet elrontani m\u00e1s oszt\u00e1lyb\u00f3l a sz\u00e1ml\u00e1l\u00f3t. De mivel private, lek\u00e9rdezni sem lehet m\u00e1r. Ez probl\u00e9ma, hiszen az pont c\u00e9lunk volt, hogy az aktu\u00e1lis sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ket le lehessen k\u00e9rdezni, b\u00e1rhonnan, pl. a Main f\u00fcggv\u00e9nyb\u0151l is, ahogy azt eddig is tett\u00fck. A megold\u00e1s egyszer\u0171: vezezz\u00fcnk be egy tagf\u00fcggv\u00e9nyt (legyen a neve SzamlaloErtek), ami publikus, \u00e9s le lehet vele k\u00e9rdezni a v\u00e9dett Szamlalo \u00e9rt\u00e9k\u00e9t: class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public static int SzamlaloErtek () { return Szamlalo ; } public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } A SzamlaloErtek tagf\u00fcggv\u00e9nyt statikuss\u00e1 is tett\u00fck a static kulcssz\u00f3val! Ez nagyon fontos, hiszen a statikus tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an csak \u00edgy tudjuk megh\u00edvni objektumok n\u00e9lk\u00fcl az oszt\u00e1ly nev\u00e9n kereszt\u00fcl (ak\u00e1r akkor is, ha m\u00e9g egy objektum sem l\u00e9tezik bel\u0151le): Teglalap.SzamlaloErtek() A Main f\u00fcggv\u00e9nyt is alak\u00edtsuk \u00e1t, hogy ezt a statikus tagf\u00fcggv\u00e9nyt haszn\u00e1lja: static void Main ( string [] args ) { int teglalapokSzama = Teglalap . SzamlaloErtek (); Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcggv\u00e9nyt m\u00e1r j\u00f3p\u00e1r alkalommal haszn\u00e1ltunk. Pl. a Console.WriteLine() eset\u00e9n. A Console egy be\u00e9p\u00edtett oszt\u00e1ly, a WriteLine ennek egy statikus tagf\u00fcggv\u00e9nye. Ha nem lenne statikus, akkor csak objektumra lehetne h\u00edvni, vagyis el\u0151bb l\u00e9tre kellene hozni a new-val egy Console objektumot, \u00edgy: Console c1 = new Console (); c1 . WriteLine (); Ez itt feleslegesen macer\u00e1s lenne, mi nem akarunk k\u00fcl\u00f6nb\u00f6z\u0151 Console objektumokkal bajl\u00f3dni. Hasonl\u00f3 a be\u00e9p\u00edtett Math oszt\u00e1ly is, ennek is egy csom\u00f3s statikus tagf\u00fcggv\u00e9nye van, \u00edgy k\u00e9nyelmesen a Math.Abs(-12) , nem kell Math objektumokat l\u00e9trehozni. Ez \u00edgy k\u00e9nyelmesebb, \u00e9s \u00e9rtelmesebb is, hiszen a Math oszt\u00e1lynak nincsenek \u00e1llapotot ad\u00f3 tagv\u00e1ltoz\u00f3i, szemben pl. a Teglalap oszt\u00e1lyunkkal, aminek van, hiszen a Szelesseg \u00e9s Magassag eset\u00e9n fontos, hogy az minden Tegalalap objektumra k\u00fcl\u00f6n t\u00e1rol\u00f3djon. Ilyen a string.Join(\",\", elemek) , ahol a '.'-t el\u0151tt a string a string oszt\u00e1ly neve (Megjegyz\u00e9s: C#-ban a kis \u00e9s nagybet\u0171vel kezd\u0151d\u0151 string / String ugyanazt jelenti.) Az alkalmaz\u00e1sok bel\u00e9p\u00e9si pontja, a Program oszt\u00e1ly Main f\u00fcgg\u00e9nye is statikus.","title":"Statikus tagf\u00fcgg\u00e9ny"},{"location":"Static/static/#szabalyok","text":"Fontos: Statikus tagf\u00fcggv\u00e9nyb\u0151l a norm\u00e1l (vagyis nem statikus) tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem lehet el\u00e9rni. Ezt meg kell tanulni, mert k\u00fcl\u00f6nben gyakran beleszalad az ember. De egy p\u00e9lda \u00e9rthet\u0151v\u00e9 is teszi: class Teglalap { public double Szelesseg ; public double Magassag ; public static double Terulet () { return Szelesseg * Magassag ; } } A p\u00e9ld\u00e1ban a Terulet() statikus tagf\u00fcggv\u00e9ny, ebb\u0151l pr\u00f3b\u00e1lunk el\u00e9rni k\u00e9t nem statikus tagot ( Szelesseg , \u00e9s Magassag ). Mivel a Terulet() statikus, nem objektumokre, hanem a Teglalap oszt\u00e1lyra tudjuk megh\u00edvni: double ter = Teglalap . Terulet (); A probl\u00e9ma az, hogy a Terulet() el\u0151tt nem objektum, hanem oszt\u00e1ly \u00e1ll, \u00edgy amikor a Terulet() f\u00fcggv\u00e9nyben hivatkozunk a nem statikus Szelesseg \u00e9s Magassag tagokra, akkor azok melyik t\u00e9galalap objektum sz\u00e9less\u00e9g\u00e9t \u00e9s magass\u00e1g\u00e1t is jelenten\u00e9k? M\u00e9g az is lehet, egyetlen Teglalap objektum sem l\u00e9tezik ekkor. Ha a Ter\u00fclet() h\u00edv\u00e1sakor a '.' el\u0151tt egy adott teglalap objektum \u00e1llna, akkor adn\u00e1 mag\u00e1t, de \u00edgy ennek nincs \u00e9rtelme. A m\u00e1sik ir\u00e1nyba nincs ilyen megk\u00f6t\u00e9s (ez is logikus): nem statikus tagf\u00fcggv\u00e9nyb\u0151l statikus tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket el lehet \u00e9rni.","title":"Szab\u00e1lyok"},{"location":"Static/static/#osszefoglalo","text":"A legfontosabb gondolatok A statikus tagv\u00e1ltoz\u00f3k az oszt\u00e1lyhoz tartoznak, annak minden objektum\u00e1ra k\u00f6z\u00f6sek Az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rhet\u0151k el, pl. Teglalap.Szamlalo, Teglalap.SzamlaloErtek(), Console.WriteLine(...), Math.Abs(...) Statikus tagf\u00fcggv\u00e9nyb\u0151l nem statikus tagokat nem lehet el\u00e9rni (nincs is \u00e9rtelme) A statikus tagv\u00e1ltoz\u00f3k \u00e9s tagf\u00fcggv\u00e9nyek haszn\u00e1lata sokszor k\u00e9nyelmes, de nem szabad t\u00falz\u00e1sba esni. Leggyakrabban olyan oszt\u00e1lyok eset\u00e9n haszn\u00e1ljuk, mint a Math, ahol az oszt\u00e1ly \u00e1llapottal (tagv\u00e1ltoz\u00f3kkal) nem rendelkezik, hanem csak egyszer\u0171 f\u00fcggv\u00e9nyek gy\u0171jtem\u00e9nye.","title":"\u00d6sszefoglal\u00f3"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/","text":"String alapok 1 \u00b6 Feladat 1 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely megford\u00edt egy adott stringet \u00e9s visszat\u00e9r vele. Pl: ad\u00e9l ->l\u00e9da Feladat 2 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott string h\u00e1nyszor fordul el\u0151 \u00e9s visszaadja ezt a sz\u00e1mot. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * sz\u00f6veg: \"Az aut\u00f3 gyorsan ment \u00e9s lesodr\u00f3dott az \u00fatr\u00f3l. Az aut\u00f3ban \u00fcl\u0151k megr\u00e9m\u00fcltek \u00e9s kisz\u00e1lltak az aut\u00f3b\u00f3l\" * keresend\u0151: \u201eaut\u00f3\u201d A f\u00fcggv\u00e9ny kimenete: 3, hiszen h\u00e1romszor szerepel benne a keresett kifejez\u00e9s Feladat 3 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott karakter hol fordul el\u0151, \u00e9s minden el\u0151fordul\u00e1s\u00e1ra visszaadja az adott el\u0151fordul\u00e1s kezd\u0151poz\u00edci\u00f3j\u00e1t \u00e9s hossz\u00e1t. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * Sz\u00f6veg: \u201eaz aaaut\u00f3 alm\u00e1t vitt\u201d * Karakter: a A f\u00fcggv\u00e9ny kimenete: 0 poz, 1 hossz; 3 poz 3 hossz; 10 poz 1 hossz Tipp: A megold\u00e1s sor\u00e1n be kell vezetni egy oszt\u00e1lyt vagy strukt\u00far\u00e1t, mely egy el\u0151fordul\u00e1st reprezent\u00e1l (ennek megfelel\u0151en van egy Kezdopoz \u00e9s egy Hossz tagja)","title":"String alapok 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#string-alapok-1","text":"","title":"String alapok 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-1","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely megford\u00edt egy adott stringet \u00e9s visszat\u00e9r vele. Pl: ad\u00e9l ->l\u00e9da","title":"Feladat 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-2","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott string h\u00e1nyszor fordul el\u0151 \u00e9s visszaadja ezt a sz\u00e1mot. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * sz\u00f6veg: \"Az aut\u00f3 gyorsan ment \u00e9s lesodr\u00f3dott az \u00fatr\u00f3l. Az aut\u00f3ban \u00fcl\u0151k megr\u00e9m\u00fcltek \u00e9s kisz\u00e1lltak az aut\u00f3b\u00f3l\" * keresend\u0151: \u201eaut\u00f3\u201d A f\u00fcggv\u00e9ny kimenete: 3, hiszen h\u00e1romszor szerepel benne a keresett kifejez\u00e9s","title":"Feladat 2"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-3","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott karakter hol fordul el\u0151, \u00e9s minden el\u0151fordul\u00e1s\u00e1ra visszaadja az adott el\u0151fordul\u00e1s kezd\u0151poz\u00edci\u00f3j\u00e1t \u00e9s hossz\u00e1t. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * Sz\u00f6veg: \u201eaz aaaut\u00f3 alm\u00e1t vitt\u201d * Karakter: a A f\u00fcggv\u00e9ny kimenete: 0 poz, 1 hossz; 3 poz 3 hossz; 10 poz 1 hossz Tipp: A megold\u00e1s sor\u00e1n be kell vezetni egy oszt\u00e1lyt vagy strukt\u00far\u00e1t, mely egy el\u0151fordul\u00e1st reprezent\u00e1l (ennek megfelel\u0151en van egy Kezdopoz \u00e9s egy Hossz tagja)","title":"Feladat 3"}]}