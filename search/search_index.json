{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C# alapok \u00b6 Ismertet\u0151k, fealdatok, p\u00e9ld\u00e1k C# megismer\u00e9s\u00e9hez \u00e9s gyakorl\u00e1s\u00e1hoz.","title":"C# alapok"},{"location":"#c-alapok","text":"Ismertet\u0151k, fealdatok, p\u00e9ld\u00e1k C# megismer\u00e9s\u00e9hez \u00e9s gyakorl\u00e1s\u00e1hoz.","title":"C# alapok"},{"location":"AlapUtasitasok/ciklusok/","text":"Ciklusok \u00b6 Lehet\u0151s\u00e9gek \u00b6 foreach for while do while foreach \u00b6 A legk\u00e9nyelmesebb, legegyszer\u0171bb m\u00f3dja annak, hogy b\u00e1rmiyen gy\u0171jtem\u00e9nyen egyes\u00e9vel sorban el\u0151re haladva el\u00e9rj\u00fck az elemeket. A gyakorlatban messze ezt haszn\u00e1ljuk a leggyakrabban. P\u00e9lda int t\u00f6mb elemein val\u00f3 v\u00e9gigiter\u00e1l\u00e1sra: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; // Az \"in\" kulcssz\u00f3 ut\u00e1n megadjuk a gy\u0171jtem\u00e9nyt, amin v\u00e9gig akarunk menni. // Az \"in\" kulcssz\u00f3 el\u0151tt bevezet\u00fcnk egy ELEM T\u00cdPUS\u00da v\u00e1ltoz\u00f3t, ennek // tetsz\u0151leges nevet adhatunk (a p\u00e9ld\u00e1ban int sz), ez a ciklus t\u00f6rzs\u00e9ben // minden iter\u00e1ci\u00f3ban az adott elemet fogja tartalmazni. foreach ( int sz in szamok ) { Console . WriteLine ( sz . ToString () ); } Most tegy\u00fck fel, hogy a Szemely egy oszt\u00e1ly, \u00e9s ebb\u0151l van egy list\u00e1nk, ezen menj\u00fcnk v\u00e9gig egyes\u00e9vel: Szemely [] szemelyek = new Szemely [] { ... itt megadjuk a szem\u00e9lyeket ... }; // Itt az elem t\u00edpusa Szemely, szemely neven vezett\u00fck be foreach ( Szemely szemely in szemelyek ) { Console . WriteLine ( szemely . Nev ); } Hint Legegyszer\u0171bben \u00edgy tudsz l\u00e9trehozni Visual Studio alatt: foreach + tab + tab (be kell \u00edrni, hogy foreach, majd k\u00e9tszer tab-ot kell nyomni), majd megadni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t \u00e9s nev\u00e9t. R\u00e9szletesebb magyar\u00e1zat \u00e9s p\u00e9ld\u00e1k: http://aries.ektf.hu/~hz/wiki7/mprog1ea/foreach for \u00b6 Leggyakrabban arra haszn\u00e1ljuk, hogy t\u00f6mb\u00f6n, list\u00e1n lehet v\u00e9gigmenni, az elemeket az index\u00e9vel el\u00e9rve. Ezt m\u00e1r ismered. P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/for https://www.tutorialsteacher.com/csharp/csharp-for-loop while \u00b6 El\u00f6ltesztel\u0151s ciklus. while (< felt\u00e9tel >) { < utas\u00edt\u00e1sok > } P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/while https://www.tutorialsteacher.com/csharp/csharp-while-loop do while \u00b6 H\u00e1tultesztel\u0151s ciklus, ritk\u00e1n haszn\u00e1ljuk. do { < utas\u00edt\u00e1sok > } while (< felt\u00e9tel >); P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: https://www.tutorialsteacher.com/csharp/csharp-do-while-loop","title":"Ciklusok"},{"location":"AlapUtasitasok/ciklusok/#ciklusok","text":"","title":"Ciklusok"},{"location":"AlapUtasitasok/ciklusok/#lehetosegek","text":"foreach for while do while","title":"Lehet\u0151s\u00e9gek"},{"location":"AlapUtasitasok/ciklusok/#foreach","text":"A legk\u00e9nyelmesebb, legegyszer\u0171bb m\u00f3dja annak, hogy b\u00e1rmiyen gy\u0171jtem\u00e9nyen egyes\u00e9vel sorban el\u0151re haladva el\u00e9rj\u00fck az elemeket. A gyakorlatban messze ezt haszn\u00e1ljuk a leggyakrabban. P\u00e9lda int t\u00f6mb elemein val\u00f3 v\u00e9gigiter\u00e1l\u00e1sra: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; // Az \"in\" kulcssz\u00f3 ut\u00e1n megadjuk a gy\u0171jtem\u00e9nyt, amin v\u00e9gig akarunk menni. // Az \"in\" kulcssz\u00f3 el\u0151tt bevezet\u00fcnk egy ELEM T\u00cdPUS\u00da v\u00e1ltoz\u00f3t, ennek // tetsz\u0151leges nevet adhatunk (a p\u00e9ld\u00e1ban int sz), ez a ciklus t\u00f6rzs\u00e9ben // minden iter\u00e1ci\u00f3ban az adott elemet fogja tartalmazni. foreach ( int sz in szamok ) { Console . WriteLine ( sz . ToString () ); } Most tegy\u00fck fel, hogy a Szemely egy oszt\u00e1ly, \u00e9s ebb\u0151l van egy list\u00e1nk, ezen menj\u00fcnk v\u00e9gig egyes\u00e9vel: Szemely [] szemelyek = new Szemely [] { ... itt megadjuk a szem\u00e9lyeket ... }; // Itt az elem t\u00edpusa Szemely, szemely neven vezett\u00fck be foreach ( Szemely szemely in szemelyek ) { Console . WriteLine ( szemely . Nev ); } Hint Legegyszer\u0171bben \u00edgy tudsz l\u00e9trehozni Visual Studio alatt: foreach + tab + tab (be kell \u00edrni, hogy foreach, majd k\u00e9tszer tab-ot kell nyomni), majd megadni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t \u00e9s nev\u00e9t. R\u00e9szletesebb magyar\u00e1zat \u00e9s p\u00e9ld\u00e1k: http://aries.ektf.hu/~hz/wiki7/mprog1ea/foreach","title":"foreach"},{"location":"AlapUtasitasok/ciklusok/#for","text":"Leggyakrabban arra haszn\u00e1ljuk, hogy t\u00f6mb\u00f6n, list\u00e1n lehet v\u00e9gigmenni, az elemeket az index\u00e9vel el\u00e9rve. Ezt m\u00e1r ismered. P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/for https://www.tutorialsteacher.com/csharp/csharp-for-loop","title":"for"},{"location":"AlapUtasitasok/ciklusok/#while","text":"El\u00f6ltesztel\u0151s ciklus. while (< felt\u00e9tel >) { < utas\u00edt\u00e1sok > } P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: http://aries.ektf.hu/~hz/wiki7/mprog1ea/while https://www.tutorialsteacher.com/csharp/csharp-while-loop","title":"while"},{"location":"AlapUtasitasok/ciklusok/#do-while","text":"H\u00e1tultesztel\u0151s ciklus, ritk\u00e1n haszn\u00e1ljuk. do { < utas\u00edt\u00e1sok > } while (< felt\u00e9tel >); P\u00e9lda, r\u00e9szletesebb magyar\u00e1zat: https://www.tutorialsteacher.com/csharp/csharp-do-while-loop","title":"do while"},{"location":"AlapUtasitasok/felteteles-elagazasok/","text":"","title":"Felteteles elagazasok"},{"location":"Fajlkezeles/fajl-alapok%20old/","text":"F\u00e1jlok (\u00e1llom\u00e1nyok) \u00b6 A program fut\u00e1sa sor\u00e1n sokszor adatokat \u00e1ll\u00edt el\u0151, adatokat k\u00e9r be, ezekkel sz\u00e1m\u00edt\u00e1sokat v\u00e9gez. Gyakran van ig\u00e9ny arra, hogy ezen adatokat valamilyen form\u00e1ban ki\u00edrjuk egy f\u00e1jlban h\u00e1tt\u00e9rt\u00e1rra (diszkre). M\u00edg a mem\u00f3ri\u00e1ban t\u00e1rolt adatok az alkalmaz\u00e1s \u00fajraindul\u00e1sa sor\u00e1n elvesznek, a h\u00e1tt\u00e9rt\u00e1ron lev\u0151 adatok megmaradnak, m\u00e9g akkor is, ha a sz\u00e1m\u00edt\u00f3g\u00e9p \u00fajraindul. Ezen fel\u00fcl a f\u00e1jlok seg\u00edts\u00e9g\u00e9vel nagyon egyszer\u0171 m\u00f3don tudnak alkalmaz\u00e1sok egym\u00e1ssal kommunik\u00e1lni, adatot megosztani. Pl. az egyik alkalmaz\u00e1s ki\u00edrja az adatot egy f\u00e1jlba, egy m\u00e1sik pedig beolvassa. Minden f\u00e1jlt egy \u00fatvonal azonos\u00edt, mely megmondja, mely meghajt\u00f3n, annak milyen mapp\u00e1j\u00e1ban van a f\u00e1jl. Pl.: c:\\work\\temp\\gyumolcsok.txt. A f\u00e1jl tartalma, ha nagyon szigor\u00faan n\u00e9zz\u00fck, akkor bitek (igaz/hamis, 0/1) egym\u00e1sut\u00e1nja, mint minden a digit\u00e1lis vil\u00e1gban. A sz\u00e1m\u00edt\u00f3g\u00e9pek alcsony szinten csak a biteket \u00e9rtik, illetve a h\u00e1tt\u00e9rt\u00e1rak is biteket tudnak nyersen t\u00e1rolni. Pl. egy f\u00e1jl nyers tartalma lehet a k\u00f6vetkez\u0151 bithalmaz: 01100001 01101100 01101101 01100001 00001101 00001010 01110011 01111010 01101001 01101100 01110110 01100001 Szukjuk a gondolatot, hogy minden f\u00e1jl a dolgok legm\u00e9ly\u00e9n hasonl\u00f3k\u00e9ppen bitek sorozat\u00e1b\u00f3l \u00e1ll... A bitek a h\u00e1tt\u00e9rt\u00e1ron gyakran folytat\u00f3lagosan helyezkednek el, de mivel sz\u00e1munka ez teljesen \u00e1tl\u00e1thatatlan lenne, \u00edgy 8 bitenk\u00e9nt csoportos\u00edtva jelen\u00edtett\u00fck meg fent. A gyakorlatban soha nem szoktunk f\u00e1jlok tartalm\u00e1val bitenk\u00e9nt dolgozni. A biteket 8-as csoportokban dolgozzuk fel. 8 bit egy b\u00e1jt. Egy b\u00e1jt 0 \u00e9s 255 k\u00f6z\u00f6tt vehet fel \u00e9rt\u00e9keket. pl. a 00000000 bitsorozat b\u00e1jt\u00e9rt\u00e9ke 0, a 00000001-\u00e9 1, a 00000010-\u00e9 2, a 00000011-\u00e9 3, az 11111111-\u00e9 pedig 255. A l\u00e9nyeg, hogy a f\u00e1jlok tartalm\u00e1ra most m\u00e1r nem mint bitek, hanem f\u00e1jlok sorozat\u00e1ra gondolunk. A fenti f\u00e1jl p\u00e9ld\u00e1nk \u00edgy n\u00e9z ki b\u00e1jtokkal reprezent\u00e1lva (minden 8-as bin\u00e1rist \u00e1tsz\u00e1moltunk b\u00e1jtra, ebben p\u00e9d\u00e1ul a Windows-ban lev\u0151 Sz\u00e1mol\u00f3g\u00e9p alkalmaz\u00e1s is seg\u00edts\u00e9g\u00fcnkre lehet, csak \u00e1t kell kapcsolni Programoz\u00f3 \u00fczemm\u00f3dra - \u00e9rdemes kipr\u00f3b\u00e1lni): 97 108 109 97 13 10 115 122 105 108 118 97 Ez \u00edgy m\u00e1s sokkal \u00e1tl\u00e1that\u00f3bb. Mostant\u00f3l \u00fagy gondolunk minden f\u00e1jlra, mint b\u00e1jtok egym\u00e1s ut\u00e1n k\u00f6vetkez\u0151 sorozat\u00e1ra. Pl. amikor egy k\u00e9p f\u00e1jr\u00f3l van sz\u00f3, ezekbe a sz\u00e1mokban a k\u00e9p pixeljeinek sz\u00ednei vannak \"belek\u00f3dolva\". Egy egyszer\u0171 sz\u00f6vegf\u00e1jl eset\u00e9n pedig ezek a sz\u00e1mok a sz\u00f6veg egyes karaktereit jelentik (erre m\u00e9g visszat\u00e9r\u00fcnk). Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokat \u00edrunk \u00e9s olvasunk nyersen, akkor b\u00e1jtokat \u00edrunk ki \u00e9s b\u00e1jtokat olvasunk be. Pl. C# nyelven ki tudjuk \u00edrni egy b\u00e1jl t\u00f6mb tartalm\u00e1t, vagy be tudunk olvasni f\u00e1jlb\u00f3l r\u00e9szeket egy b\u00e1jt t\u00f6mbbe. F\u00e1jlkezel\u00e9s \u00e1ltal\u00e1noss\u00e1g\u00e1ban \u00b6 Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokkal dolgozunk, akkor lehet\u0151s\u00e9g\u00fcnk van: * A f\u00e1jl tartalm\u00e1t olvasni. * A f\u00e1jl tartalm\u00e1t \u00edrni (ez m\u00f3dos\u00edtja a tartalmat) * F\u00e1jlt l\u00e9trehozni, t\u00f6r\u00f6lni, \u00e1tnevezni, mozgatni, stb. A f\u00e1jl tartalm\u00e1nak olvas\u00e1sa/\u00edr\u00e1sa az al\u00e1bbiaknak megfelel\u0151en t\u00f6rt\u00e9nik: F\u00e1jlt megnyit\u00e1sa Tartalom olvas\u00e1sa vagy \u00edr\u00e1sa C# k\u00f3db\u00f3l be tudunk olvasni adott pozici\u00f3t\u00f3l adott darabsz\u00e1m\u00fa b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l k\u00e9r\u00fcnk 100-at), \u00e9s az pl. egy b\u00e1jt t\u00f6mbbe ker\u00fcl. Onnan tudjuk tov\u00e1bb alak\u00edtani sz\u00e1mm\u00e1, sztring\u00e9, vagy ahogy \u00e9rtelmezni k\u00edv\u00e1njuk az adatokat. Arra vigy\u00e1zni kell, hogy a f\u00e1jl v\u00e9g\u00e9n ne akarjunk t\u00falolvasni (pl. ha 1000 b\u00e1jlt van egy f\u00e1jlban, ne akarjuk az 1001-ediket beolvasni.) Adott poz\u00edci\u00f3t\u00f3l ki tudunk \u00edrni adott darab b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l ki\u00edrunk 100 \u00e1ltalunk mehat\u00e1rozott b\u00e1jtot). Amikor nem b\u00e1jtot/b\u00e1jt t\u00f6mb\u00f6t \u00edrunk ki, f\u00e1jlba, hanem pl. sz\u00e1mot, sztringet, vagy m\u00e1s t\u00edpust, azt is el\u0151sz\u00f6r b\u00e1jtokk\u00e1 kell alak\u00edtani a f\u00e1jlba \u00edr\u00e1s el\u0151tt (szerencs\u00e9re a .NET sz\u00e1munkra ezt sokszor elrejti). F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). K\u00f3d \u00e9s p\u00e9lda. Az alacsonyabb, b\u00e1jtszint\u0171 f\u00e1jlkezel\u00e9sre ritk\u00e1bban van sz\u00fcks\u00e9g, \u00edgy erre nem n\u00e9z\u00fcnk p\u00e9ld\u00e1kat. De itt van egy\u00e9bk\u00e9nt egy p\u00e9lda, az l\u00e1tsz\u00f3dik, hogy a File oszt\u00e1llyal nyitja meg a f\u00e1jlt, \u00e9s ut\u00e1n byte t\u00f6mbe teszi az adatot, \u00e9s ezt \u00edrja ki a FileStream.Write m\u0171velet\u00e9vel (adott poz\u00edci\u00f3t\u00f3l), az olvas\u00e1s is b\u00e1jtokkal dolgozik: https://docs.microsoft.com/en-us/dotnet/api/system.io.file.openwrite?view=netcore-3.1#examples Sz\u00f6vegf\u00e1jlok \u00b6 A sz\u00f6vegf\u00e1jlok is f\u00e1jlok, csak \u00e9ppen a tartalmuk sz\u00f6veg, \u00edgy pl. az egyszer\u0171 Jegyzett\u00f6mb alkalmaz\u00e1ssal is meg lehet \u00e9rtelmesen jelen\u00edteni a tartalmukat. L\u00e9nyeges, hogy nem a f\u00e1jl kiterjeszt\u00e9s\u00e9t\u0151l lesz a f\u00e1jl sz\u00f6veges, hanem a tartalm\u00e1t\u00f3l, b\u00e1milyen kiterjeszt\u00e9s\u0171 f\u00e1jlba lehet sz\u00f6veges tartalmat ki\u00edrni (de term\u00e9szetesen logikus ilyen esetben a .txt kiterjeszt\u00e9s haszn\u00e1lata, vagy pl. a csv, ha valamilyen szepat\u00e1rorral elv\u00e1lasztott struktr\u00e1lt sz\u00f6veges tartalom van a f\u00e1jlban). A sz\u00f6vegf\u00e1jlban is b\u00e1jtok vannak, csak ezek a b\u00e1jtok sz\u00f6vegbeli karaktereket jelentenek. A klasszikus ASCII k\u00f3dol\u00e1s\u00fa sz\u00f6vegf\u00e1jlok eset\u00e9n minden b\u00e1jt pontosan egy karaktert jelent. N\u00e9zz\u00fck a fenti p\u00e9ld\u00e1nkat, amikor a f\u00e1jl tartalma a k\u00f6vetkez\u0151: 97 108 109 97 13 10 115 122 105 108 118 97 Pr\u00f3b\u00e1ljuk ezt most sz\u00f6vegf\u00e1jltk\u00e9nt \u00e9rtelmezni, ennekmegfelel\u0151en egy ASCII t\u00e1bl\u00e1zatban n\u00e9zz\u00fck meg minden egyes b\u00e1jtra, milyen karakter tartozik hozz\u00e1 (pl. itt https://hu.wikipedia.org/wiki/ASCII ): a l m a CR LF s z i v l a Vagyis egy CR+LF-vel elv\u00e1lasztott \"alma\" \u00e9s \"szilva\". Egyben, ha mint C# string n\u00e9zz\u00fck \"alma\\r\\nszilva\" Ez bizony sz\u00f6veges tartalom, vagyis egy sz\u00f6vegf\u00e1jllal van dolgunk. Ha megnyitjuk a Jegyzett\u00f6mb (Notepad) alkalmaz\u00e1sban, \u00edgy n\u00e9z ki: A tiszt\u00e1zand\u00f3 m\u00e9g, hogy mia a 10 (CR) \u00e9s 13 (LF) b\u00e1jt a k\u00f6zep\u00e9n. Egyszer\u0171en arr\u00f3l van sz\u00f3, hogy van egy sort\u00f6r\u00e9s is az alma ut\u00e1n, amit Windows oper\u00e1ci\u00f3s rendszerben k\u00e9t speci\u00e1lis karakter jel\u00f6l. C#-ban '\\r' \u00e9s egy '\\n' karakter, egy stringbe \u00edrva \"\\r\\n\". A '\\r' sz\u00e1m\u00e9rt\u00e9ke 13, a '\\n'-n\u00e9 10. Megjegyz\u00e9s: Linux oper\u00e1ci\u00f3s rendszer alatt csak egy karakter haszn\u00e1latos, a '\\n'. Megjegyz\u00e9s: A '\\n' \u00e9s a '\\n', b\u00e1r C# nyelven a forr\u00e1sk\u00f3dban k\u00e9t karakterrel jel\u00f6lj\u00fck, csak egy b\u00e1jt hossz\u00fa mindkett\u0151: a C# nyelven a egy escape szekvencia kezdet\u00e9t jel\u00f6li, vagyis pl. a '\\n' nem egy '\\' \u00e9s egy 'n' karakter egym\u00e1sut\u00e1n, hanem a '\\n' \u00f6nmag\u00e1ban jel\u00f6l egyetlen speci\u00e1lis karaktert, melynek a sz\u00e1mk\u00f3dja 13. A sz\u00f6vegf\u00e1jlok \u00edr\u00e1s\u00e1ra/olvas\u00e1s\u00e1ra egyszer\u0171bb lehet\u0151s\u00e9g\u00fcnk is van, mint b\u00e1jtokkal, b\u00e1jt\u00f6mb\u00f6kkel dolkgozni. A f\u00e1jlt soronk\u00e9nt \u00edrjuk ( StreamWriter oszt\u00e1ly WriteLine m\u0171velete) \u00e9s olvassuk ( StreamReader oszt\u00e1ly ReadLine m\u0171velete). Mindig egyszerre egy sort \u00edrunk ki, illeve olvasunk be, string form\u00e1j\u00e1ban. A f\u00e1jl tartalm\u00e1nak olvas\u00e1sa/\u00edr\u00e1sa az al\u00e1bbiaknak megfelel\u0151en t\u00f6rt\u00e9nik: F\u00e1jlt megnyit\u00e1sa A f\u00e1jlban mindig van egy aktu\u00e1lis f\u00e1jlmutat\u00f3 , mely alapesetben a f\u00e1jl legelej\u00e9re mutat, de b\u00e1rmelyik poz\u00edci\u00f3ra r\u00e1 tudjuk \u00e1ll\u00edtani (pl. c\u00e9lszer\u0171 a f\u00e1jl v\u00e9g\u00e9re \u00e1ll\u00edtani, ha a f\u00e1jlhoz hozz\u00e1f\u0171zni szeretn\u00e9nk). C# k\u00f3db\u00f3l be tudunk olvasni \u00e1ltalunk meghat\u00e1rozott darabsz\u00e1m\u00fa b\u00e1jtot, \u00e9s az pl. egy b\u00e1jt t\u00f6mbbe ker\u00fcl. Onnan tudjuk tov\u00e1bb alak\u00edtani sz\u00e1mm\u00e1, sztring\u00e9, vagy ahogy \u00e9rtelmezni k\u00edv\u00e1njuk az adatokat. Arra vigy\u00e1zni kell, hogy a f\u00e1jl v\u00e9g\u00e9n ne akarjunk t\u00falolvasni (pl. ha 1000 b\u00e1jlt van egy f\u00e1jlban, ne akarjuk az 1001-ediket beolvasni.) Amikor pl. C# k\u00f3db\u00f3l ki\u00edrunk N darab b\u00e1jtot, az \u00edr\u00e1s a f\u00e1jlmutat\u00f3t\u00f3l kezdve t\u00f6rt\u00e9nik, \u00e9s a f\u00e1jlmutat\u00f3 az ki\u00edr\u00e1s v\u00e9g\u00e9re ker\u00fcl. Amikor nem b\u00e1jtot/b\u00e1jt t\u00f6mb\u00f6t \u00edrunk ki, f\u00e1jlba, hanem pl. sz\u00e1mot, sztringet, vagy m\u00e1s t\u00edpust, azt is el\u0151sz\u00f6r b\u00e1jtokk\u00e1 kell alak\u00edtani a f\u00e1jlba \u00edr\u00e1s el\u0151tt (szerencs\u00e9re a .NET sz\u00e1munkra ezt sokszor elrejti). F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). Itt tal\u00e1lsz j\u00f3 magyar\u00e1zatot \u00e9s p\u00e9ld\u00e1kat sz\u00f6vegf\u00e1jl \u00edr\u00e1s\u00e1ra \u00e9s olvas\u00e1s\u00e1ra is: http://aries.ektf.hu/~hz/wiki7/mprog1ea/text_file Tov\u00e1bbi l\u00e9nyeges inform\u00e1ci\u00f3k \u00b6","title":"Fajl alapok old"},{"location":"Fajlkezeles/fajl-alapok%20old/#fajlok-allomanyok","text":"A program fut\u00e1sa sor\u00e1n sokszor adatokat \u00e1ll\u00edt el\u0151, adatokat k\u00e9r be, ezekkel sz\u00e1m\u00edt\u00e1sokat v\u00e9gez. Gyakran van ig\u00e9ny arra, hogy ezen adatokat valamilyen form\u00e1ban ki\u00edrjuk egy f\u00e1jlban h\u00e1tt\u00e9rt\u00e1rra (diszkre). M\u00edg a mem\u00f3ri\u00e1ban t\u00e1rolt adatok az alkalmaz\u00e1s \u00fajraindul\u00e1sa sor\u00e1n elvesznek, a h\u00e1tt\u00e9rt\u00e1ron lev\u0151 adatok megmaradnak, m\u00e9g akkor is, ha a sz\u00e1m\u00edt\u00f3g\u00e9p \u00fajraindul. Ezen fel\u00fcl a f\u00e1jlok seg\u00edts\u00e9g\u00e9vel nagyon egyszer\u0171 m\u00f3don tudnak alkalmaz\u00e1sok egym\u00e1ssal kommunik\u00e1lni, adatot megosztani. Pl. az egyik alkalmaz\u00e1s ki\u00edrja az adatot egy f\u00e1jlba, egy m\u00e1sik pedig beolvassa. Minden f\u00e1jlt egy \u00fatvonal azonos\u00edt, mely megmondja, mely meghajt\u00f3n, annak milyen mapp\u00e1j\u00e1ban van a f\u00e1jl. Pl.: c:\\work\\temp\\gyumolcsok.txt. A f\u00e1jl tartalma, ha nagyon szigor\u00faan n\u00e9zz\u00fck, akkor bitek (igaz/hamis, 0/1) egym\u00e1sut\u00e1nja, mint minden a digit\u00e1lis vil\u00e1gban. A sz\u00e1m\u00edt\u00f3g\u00e9pek alcsony szinten csak a biteket \u00e9rtik, illetve a h\u00e1tt\u00e9rt\u00e1rak is biteket tudnak nyersen t\u00e1rolni. Pl. egy f\u00e1jl nyers tartalma lehet a k\u00f6vetkez\u0151 bithalmaz: 01100001 01101100 01101101 01100001 00001101 00001010 01110011 01111010 01101001 01101100 01110110 01100001 Szukjuk a gondolatot, hogy minden f\u00e1jl a dolgok legm\u00e9ly\u00e9n hasonl\u00f3k\u00e9ppen bitek sorozat\u00e1b\u00f3l \u00e1ll... A bitek a h\u00e1tt\u00e9rt\u00e1ron gyakran folytat\u00f3lagosan helyezkednek el, de mivel sz\u00e1munka ez teljesen \u00e1tl\u00e1thatatlan lenne, \u00edgy 8 bitenk\u00e9nt csoportos\u00edtva jelen\u00edtett\u00fck meg fent. A gyakorlatban soha nem szoktunk f\u00e1jlok tartalm\u00e1val bitenk\u00e9nt dolgozni. A biteket 8-as csoportokban dolgozzuk fel. 8 bit egy b\u00e1jt. Egy b\u00e1jt 0 \u00e9s 255 k\u00f6z\u00f6tt vehet fel \u00e9rt\u00e9keket. pl. a 00000000 bitsorozat b\u00e1jt\u00e9rt\u00e9ke 0, a 00000001-\u00e9 1, a 00000010-\u00e9 2, a 00000011-\u00e9 3, az 11111111-\u00e9 pedig 255. A l\u00e9nyeg, hogy a f\u00e1jlok tartalm\u00e1ra most m\u00e1r nem mint bitek, hanem f\u00e1jlok sorozat\u00e1ra gondolunk. A fenti f\u00e1jl p\u00e9ld\u00e1nk \u00edgy n\u00e9z ki b\u00e1jtokkal reprezent\u00e1lva (minden 8-as bin\u00e1rist \u00e1tsz\u00e1moltunk b\u00e1jtra, ebben p\u00e9d\u00e1ul a Windows-ban lev\u0151 Sz\u00e1mol\u00f3g\u00e9p alkalmaz\u00e1s is seg\u00edts\u00e9g\u00fcnkre lehet, csak \u00e1t kell kapcsolni Programoz\u00f3 \u00fczemm\u00f3dra - \u00e9rdemes kipr\u00f3b\u00e1lni): 97 108 109 97 13 10 115 122 105 108 118 97 Ez \u00edgy m\u00e1s sokkal \u00e1tl\u00e1that\u00f3bb. Mostant\u00f3l \u00fagy gondolunk minden f\u00e1jlra, mint b\u00e1jtok egym\u00e1s ut\u00e1n k\u00f6vetkez\u0151 sorozat\u00e1ra. Pl. amikor egy k\u00e9p f\u00e1jr\u00f3l van sz\u00f3, ezekbe a sz\u00e1mokban a k\u00e9p pixeljeinek sz\u00ednei vannak \"belek\u00f3dolva\". Egy egyszer\u0171 sz\u00f6vegf\u00e1jl eset\u00e9n pedig ezek a sz\u00e1mok a sz\u00f6veg egyes karaktereit jelentik (erre m\u00e9g visszat\u00e9r\u00fcnk). Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokat \u00edrunk \u00e9s olvasunk nyersen, akkor b\u00e1jtokat \u00edrunk ki \u00e9s b\u00e1jtokat olvasunk be. Pl. C# nyelven ki tudjuk \u00edrni egy b\u00e1jl t\u00f6mb tartalm\u00e1t, vagy be tudunk olvasni f\u00e1jlb\u00f3l r\u00e9szeket egy b\u00e1jt t\u00f6mbbe.","title":"F\u00e1jlok (\u00e1llom\u00e1nyok)"},{"location":"Fajlkezeles/fajl-alapok%20old/#fajlkezeles-altalanossagaban","text":"Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokkal dolgozunk, akkor lehet\u0151s\u00e9g\u00fcnk van: * A f\u00e1jl tartalm\u00e1t olvasni. * A f\u00e1jl tartalm\u00e1t \u00edrni (ez m\u00f3dos\u00edtja a tartalmat) * F\u00e1jlt l\u00e9trehozni, t\u00f6r\u00f6lni, \u00e1tnevezni, mozgatni, stb. A f\u00e1jl tartalm\u00e1nak olvas\u00e1sa/\u00edr\u00e1sa az al\u00e1bbiaknak megfelel\u0151en t\u00f6rt\u00e9nik: F\u00e1jlt megnyit\u00e1sa Tartalom olvas\u00e1sa vagy \u00edr\u00e1sa C# k\u00f3db\u00f3l be tudunk olvasni adott pozici\u00f3t\u00f3l adott darabsz\u00e1m\u00fa b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l k\u00e9r\u00fcnk 100-at), \u00e9s az pl. egy b\u00e1jt t\u00f6mbbe ker\u00fcl. Onnan tudjuk tov\u00e1bb alak\u00edtani sz\u00e1mm\u00e1, sztring\u00e9, vagy ahogy \u00e9rtelmezni k\u00edv\u00e1njuk az adatokat. Arra vigy\u00e1zni kell, hogy a f\u00e1jl v\u00e9g\u00e9n ne akarjunk t\u00falolvasni (pl. ha 1000 b\u00e1jlt van egy f\u00e1jlban, ne akarjuk az 1001-ediket beolvasni.) Adott poz\u00edci\u00f3t\u00f3l ki tudunk \u00edrni adott darab b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l ki\u00edrunk 100 \u00e1ltalunk mehat\u00e1rozott b\u00e1jtot). Amikor nem b\u00e1jtot/b\u00e1jt t\u00f6mb\u00f6t \u00edrunk ki, f\u00e1jlba, hanem pl. sz\u00e1mot, sztringet, vagy m\u00e1s t\u00edpust, azt is el\u0151sz\u00f6r b\u00e1jtokk\u00e1 kell alak\u00edtani a f\u00e1jlba \u00edr\u00e1s el\u0151tt (szerencs\u00e9re a .NET sz\u00e1munkra ezt sokszor elrejti). F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). K\u00f3d \u00e9s p\u00e9lda. Az alacsonyabb, b\u00e1jtszint\u0171 f\u00e1jlkezel\u00e9sre ritk\u00e1bban van sz\u00fcks\u00e9g, \u00edgy erre nem n\u00e9z\u00fcnk p\u00e9ld\u00e1kat. De itt van egy\u00e9bk\u00e9nt egy p\u00e9lda, az l\u00e1tsz\u00f3dik, hogy a File oszt\u00e1llyal nyitja meg a f\u00e1jlt, \u00e9s ut\u00e1n byte t\u00f6mbe teszi az adatot, \u00e9s ezt \u00edrja ki a FileStream.Write m\u0171velet\u00e9vel (adott poz\u00edci\u00f3t\u00f3l), az olvas\u00e1s is b\u00e1jtokkal dolgozik: https://docs.microsoft.com/en-us/dotnet/api/system.io.file.openwrite?view=netcore-3.1#examples","title":"F\u00e1jlkezel\u00e9s \u00e1ltal\u00e1noss\u00e1g\u00e1ban"},{"location":"Fajlkezeles/fajl-alapok%20old/#szovegfajlok","text":"A sz\u00f6vegf\u00e1jlok is f\u00e1jlok, csak \u00e9ppen a tartalmuk sz\u00f6veg, \u00edgy pl. az egyszer\u0171 Jegyzett\u00f6mb alkalmaz\u00e1ssal is meg lehet \u00e9rtelmesen jelen\u00edteni a tartalmukat. L\u00e9nyeges, hogy nem a f\u00e1jl kiterjeszt\u00e9s\u00e9t\u0151l lesz a f\u00e1jl sz\u00f6veges, hanem a tartalm\u00e1t\u00f3l, b\u00e1milyen kiterjeszt\u00e9s\u0171 f\u00e1jlba lehet sz\u00f6veges tartalmat ki\u00edrni (de term\u00e9szetesen logikus ilyen esetben a .txt kiterjeszt\u00e9s haszn\u00e1lata, vagy pl. a csv, ha valamilyen szepat\u00e1rorral elv\u00e1lasztott struktr\u00e1lt sz\u00f6veges tartalom van a f\u00e1jlban). A sz\u00f6vegf\u00e1jlban is b\u00e1jtok vannak, csak ezek a b\u00e1jtok sz\u00f6vegbeli karaktereket jelentenek. A klasszikus ASCII k\u00f3dol\u00e1s\u00fa sz\u00f6vegf\u00e1jlok eset\u00e9n minden b\u00e1jt pontosan egy karaktert jelent. N\u00e9zz\u00fck a fenti p\u00e9ld\u00e1nkat, amikor a f\u00e1jl tartalma a k\u00f6vetkez\u0151: 97 108 109 97 13 10 115 122 105 108 118 97 Pr\u00f3b\u00e1ljuk ezt most sz\u00f6vegf\u00e1jltk\u00e9nt \u00e9rtelmezni, ennekmegfelel\u0151en egy ASCII t\u00e1bl\u00e1zatban n\u00e9zz\u00fck meg minden egyes b\u00e1jtra, milyen karakter tartozik hozz\u00e1 (pl. itt https://hu.wikipedia.org/wiki/ASCII ): a l m a CR LF s z i v l a Vagyis egy CR+LF-vel elv\u00e1lasztott \"alma\" \u00e9s \"szilva\". Egyben, ha mint C# string n\u00e9zz\u00fck \"alma\\r\\nszilva\" Ez bizony sz\u00f6veges tartalom, vagyis egy sz\u00f6vegf\u00e1jllal van dolgunk. Ha megnyitjuk a Jegyzett\u00f6mb (Notepad) alkalmaz\u00e1sban, \u00edgy n\u00e9z ki: A tiszt\u00e1zand\u00f3 m\u00e9g, hogy mia a 10 (CR) \u00e9s 13 (LF) b\u00e1jt a k\u00f6zep\u00e9n. Egyszer\u0171en arr\u00f3l van sz\u00f3, hogy van egy sort\u00f6r\u00e9s is az alma ut\u00e1n, amit Windows oper\u00e1ci\u00f3s rendszerben k\u00e9t speci\u00e1lis karakter jel\u00f6l. C#-ban '\\r' \u00e9s egy '\\n' karakter, egy stringbe \u00edrva \"\\r\\n\". A '\\r' sz\u00e1m\u00e9rt\u00e9ke 13, a '\\n'-n\u00e9 10. Megjegyz\u00e9s: Linux oper\u00e1ci\u00f3s rendszer alatt csak egy karakter haszn\u00e1latos, a '\\n'. Megjegyz\u00e9s: A '\\n' \u00e9s a '\\n', b\u00e1r C# nyelven a forr\u00e1sk\u00f3dban k\u00e9t karakterrel jel\u00f6lj\u00fck, csak egy b\u00e1jt hossz\u00fa mindkett\u0151: a C# nyelven a egy escape szekvencia kezdet\u00e9t jel\u00f6li, vagyis pl. a '\\n' nem egy '\\' \u00e9s egy 'n' karakter egym\u00e1sut\u00e1n, hanem a '\\n' \u00f6nmag\u00e1ban jel\u00f6l egyetlen speci\u00e1lis karaktert, melynek a sz\u00e1mk\u00f3dja 13. A sz\u00f6vegf\u00e1jlok \u00edr\u00e1s\u00e1ra/olvas\u00e1s\u00e1ra egyszer\u0171bb lehet\u0151s\u00e9g\u00fcnk is van, mint b\u00e1jtokkal, b\u00e1jt\u00f6mb\u00f6kkel dolkgozni. A f\u00e1jlt soronk\u00e9nt \u00edrjuk ( StreamWriter oszt\u00e1ly WriteLine m\u0171velete) \u00e9s olvassuk ( StreamReader oszt\u00e1ly ReadLine m\u0171velete). Mindig egyszerre egy sort \u00edrunk ki, illeve olvasunk be, string form\u00e1j\u00e1ban. A f\u00e1jl tartalm\u00e1nak olvas\u00e1sa/\u00edr\u00e1sa az al\u00e1bbiaknak megfelel\u0151en t\u00f6rt\u00e9nik: F\u00e1jlt megnyit\u00e1sa A f\u00e1jlban mindig van egy aktu\u00e1lis f\u00e1jlmutat\u00f3 , mely alapesetben a f\u00e1jl legelej\u00e9re mutat, de b\u00e1rmelyik poz\u00edci\u00f3ra r\u00e1 tudjuk \u00e1ll\u00edtani (pl. c\u00e9lszer\u0171 a f\u00e1jl v\u00e9g\u00e9re \u00e1ll\u00edtani, ha a f\u00e1jlhoz hozz\u00e1f\u0171zni szeretn\u00e9nk). C# k\u00f3db\u00f3l be tudunk olvasni \u00e1ltalunk meghat\u00e1rozott darabsz\u00e1m\u00fa b\u00e1jtot, \u00e9s az pl. egy b\u00e1jt t\u00f6mbbe ker\u00fcl. Onnan tudjuk tov\u00e1bb alak\u00edtani sz\u00e1mm\u00e1, sztring\u00e9, vagy ahogy \u00e9rtelmezni k\u00edv\u00e1njuk az adatokat. Arra vigy\u00e1zni kell, hogy a f\u00e1jl v\u00e9g\u00e9n ne akarjunk t\u00falolvasni (pl. ha 1000 b\u00e1jlt van egy f\u00e1jlban, ne akarjuk az 1001-ediket beolvasni.) Amikor pl. C# k\u00f3db\u00f3l ki\u00edrunk N darab b\u00e1jtot, az \u00edr\u00e1s a f\u00e1jlmutat\u00f3t\u00f3l kezdve t\u00f6rt\u00e9nik, \u00e9s a f\u00e1jlmutat\u00f3 az ki\u00edr\u00e1s v\u00e9g\u00e9re ker\u00fcl. Amikor nem b\u00e1jtot/b\u00e1jt t\u00f6mb\u00f6t \u00edrunk ki, f\u00e1jlba, hanem pl. sz\u00e1mot, sztringet, vagy m\u00e1s t\u00edpust, azt is el\u0151sz\u00f6r b\u00e1jtokk\u00e1 kell alak\u00edtani a f\u00e1jlba \u00edr\u00e1s el\u0151tt (szerencs\u00e9re a .NET sz\u00e1munkra ezt sokszor elrejti). F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). Itt tal\u00e1lsz j\u00f3 magyar\u00e1zatot \u00e9s p\u00e9ld\u00e1kat sz\u00f6vegf\u00e1jl \u00edr\u00e1s\u00e1ra \u00e9s olvas\u00e1s\u00e1ra is: http://aries.ektf.hu/~hz/wiki7/mprog1ea/text_file","title":"Sz\u00f6vegf\u00e1jlok"},{"location":"Fajlkezeles/fajl-alapok%20old/#tovabbi-lenyeges-informaciok","text":"","title":"Tov\u00e1bbi l\u00e9nyeges inform\u00e1ci\u00f3k"},{"location":"Fajlkezeles/fajl-alapok/","text":"F\u00e1jlkezel\u00e9s \u00b6 A program fut\u00e1sa sor\u00e1n sokszor adatokat \u00e1ll\u00edt el\u0151, adatokat k\u00e9r be, ezekkel sz\u00e1m\u00edt\u00e1sokat v\u00e9gez. Gyakran van ig\u00e9ny arra, hogy ezen adatokat valamilyen form\u00e1ban ki\u00edrjuk egy f\u00e1jlban h\u00e1tt\u00e9rt\u00e1rra (diszkre). M\u00edg a mem\u00f3ri\u00e1ban t\u00e1rolt adatok az alkalmaz\u00e1s \u00fajraindul\u00e1sa sor\u00e1n elvesznek, a h\u00e1tt\u00e9rt\u00e1ron lev\u0151 adatok megmaradnak, m\u00e9g akkor is, ha a sz\u00e1m\u00edt\u00f3g\u00e9p \u00fajraindul. Ezen fel\u00fcl a f\u00e1jlok seg\u00edts\u00e9g\u00e9vel nagyon egyszer\u0171 m\u00f3don tudnak alkalmaz\u00e1sok egym\u00e1ssal kommunik\u00e1lni, adatot megosztani. Pl. az egyik alkalmaz\u00e1s ki\u00edrja az adatot egy f\u00e1jlba, egy m\u00e1sik pedig beolvassa. Egy f\u00e1jlra m\u00e1s sz\u00f3val **\u00e1llom\u00e1ny**k\u00e9nt \u00e9s szok\u00e1s hivatkozni (\u00edgy a f\u00e1jlkezel\u00e9s ugyanazt jelenti, mint az \u00e1llom\u00e1nykezel\u00e9s.) Minden f\u00e1jlt egy \u00fatvonal azonos\u00edt, mely megmondja, mely meghajt\u00f3n, annak milyen mapp\u00e1j\u00e1ban van a f\u00e1jl. Pl.: c:\\work\\temp\\gyumolcsok.txt. A f\u00e1jl tartalma, ha nagyon szigor\u00faan n\u00e9zz\u00fck, akkor bitek (igaz/hamis, 0/1) egym\u00e1sut\u00e1nja, mint minden a digit\u00e1lis vil\u00e1gban. A sz\u00e1m\u00edt\u00f3g\u00e9pek alcsony szinten csak a biteket \u00e9rtik, illetve a h\u00e1tt\u00e9rt\u00e1rak is biteket tudnak nyersen t\u00e1rolni. Pl. egy f\u00e1jl nyers tartalma lehet a k\u00f6vetkez\u0151 bithalmaz: 01100001 01101100 01101101 01100001 00001101 00001010 01110011 01111010 01101001 01101100 01110110 01100001 Szukjuk a gondolatot, hogy minden f\u00e1jl a dolgok legm\u00e9ly\u00e9n hasonl\u00f3k\u00e9ppen bitek sorozat\u00e1b\u00f3l \u00e1ll... A bitek a h\u00e1tt\u00e9rt\u00e1ron gyakran folytat\u00f3lagosan helyezkednek el, de mivel sz\u00e1munka ez teljesen \u00e1tl\u00e1thatatlan lenne, \u00edgy 8 bitenk\u00e9nt csoportos\u00edtva jelen\u00edtett\u00fck meg fent. A gyakorlatban soha nem szoktunk f\u00e1jlok tartalm\u00e1val bitenk\u00e9nt dolgozni. A biteket 8-as csoportokban dolgozzuk fel. 8 bit egy b\u00e1jt. Egy b\u00e1jt 0 \u00e9s 255 k\u00f6z\u00f6tt vehet fel \u00e9rt\u00e9keket. pl. a 00000000 bitsorozat b\u00e1jt\u00e9rt\u00e9ke 0, a 00000001-\u00e9 1, a 00000010-\u00e9 2, a 00000011-\u00e9 3, az 11111111-\u00e9 pedig 255. A l\u00e9nyeg, hogy a f\u00e1jlok tartalm\u00e1ra most m\u00e1r nem mint bitek, hanem f\u00e1jlok sorozat\u00e1ra gondolunk. A fenti f\u00e1jl p\u00e9ld\u00e1nk \u00edgy n\u00e9z ki b\u00e1jtokkal reprezent\u00e1lva (minden 8-as bin\u00e1rist \u00e1tsz\u00e1moltunk b\u00e1jtra, ebben p\u00e9d\u00e1ul a Windows-ban lev\u0151 Sz\u00e1mol\u00f3g\u00e9p alkalmaz\u00e1s is seg\u00edts\u00e9g\u00fcnkre lehet, csak \u00e1t kell kapcsolni Programoz\u00f3 \u00fczemm\u00f3dra - \u00e9rdemes kipr\u00f3b\u00e1lni): 97 108 109 97 13 10 115 122 105 108 118 97 Ez \u00edgy m\u00e1s sokkal \u00e1tl\u00e1that\u00f3bb. Mostant\u00f3l \u00fagy gondolunk minden f\u00e1jlra, mint b\u00e1jtok egym\u00e1s ut\u00e1n k\u00f6vetkez\u0151 sorozat\u00e1ra. Pl. amikor egy k\u00e9p f\u00e1jr\u00f3l van sz\u00f3, ezekbe a sz\u00e1mokban a k\u00e9p pixeljeinek sz\u00ednei vannak \"belek\u00f3dolva\". Egy egyszer\u0171 sz\u00f6vegf\u00e1jl eset\u00e9n pedig ezek a sz\u00e1mok a sz\u00f6veg egyes karaktereit jelentik (erre m\u00e9g visszat\u00e9r\u00fcnk). Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokat \u00edrunk \u00e9s olvasunk nyersen, akkor b\u00e1jtokat \u00edrunk ki \u00e9s b\u00e1jtokat olvasunk be. Pl. C# nyelven ki tudjuk \u00edrni egy b\u00e1jl t\u00f6mb tartalm\u00e1t, vagy be tudunk olvasni f\u00e1jlb\u00f3l r\u00e9szeket egy b\u00e1jt t\u00f6mbbe. F\u00e1jlkezel\u00e9s \u00e1ltal\u00e1noss\u00e1g\u00e1ban \u00b6 Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokkal dolgozunk, akkor lehet\u0151s\u00e9g\u00fcnk van: * A f\u00e1jl tartalm\u00e1t olvasni. * A f\u00e1jl tartalm\u00e1t \u00edrni (ez m\u00f3dos\u00edtja a tartalmat) * F\u00e1jlt l\u00e9trehozni, t\u00f6r\u00f6lni, \u00e1tnevezni, mozgatni, stb. A f\u00e1jl tartalm\u00e1nak olvas\u00e1sa/\u00edr\u00e1sa az al\u00e1bbiaknak megfelel\u0151en t\u00f6rt\u00e9nik: F\u00e1jlt megnyit\u00e1sa Tartalom olvas\u00e1sa vagy \u00edr\u00e1sa C# k\u00f3db\u00f3l be tudunk olvasni adott pozici\u00f3t\u00f3l adott darabsz\u00e1m\u00fa b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l k\u00e9r\u00fcnk 100-at), \u00e9s az pl. egy b\u00e1jt t\u00f6mbbe ker\u00fcl. Onnan tudjuk tov\u00e1bb alak\u00edtani sz\u00e1mm\u00e1, sztring\u00e9, vagy ahogy \u00e9rtelmezni k\u00edv\u00e1njuk az adatokat. Arra vigy\u00e1zni kell, hogy a f\u00e1jl v\u00e9g\u00e9n ne akarjunk t\u00falolvasni (pl. ha 1000 b\u00e1jlt van egy f\u00e1jlban, ne akarjuk az 1001-ediket beolvasni.) Adott poz\u00edci\u00f3t\u00f3l ki tudunk \u00edrni adott darab b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l ki\u00edrunk 100 \u00e1ltalunk mehat\u00e1rozott b\u00e1jtot). Amikor nem b\u00e1jtot/b\u00e1jt t\u00f6mb\u00f6t \u00edrunk ki, f\u00e1jlba, hanem pl. sz\u00e1mot, sztringet, vagy m\u00e1s t\u00edpust, azt is el\u0151sz\u00f6r b\u00e1jtokk\u00e1 kell alak\u00edtani a f\u00e1jlba \u00edr\u00e1s el\u0151tt (szerencs\u00e9re a .NET sz\u00e1munkra ezt sokszor elrejti). F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). K\u00f3d \u00e9s p\u00e9lda. Az alacsonyabb, b\u00e1jtszint\u0171 f\u00e1jlkezel\u00e9sre ritk\u00e1bban van sz\u00fcks\u00e9g, \u00edgy erre nem n\u00e9z\u00fcnk p\u00e9ld\u00e1kat. De itt van egy\u00e9bk\u00e9nt egy p\u00e9lda, az l\u00e1tsz\u00f3dik, hogy a File oszt\u00e1llyal nyitja meg a f\u00e1jlt, \u00e9s ut\u00e1n byte t\u00f6mbe teszi az adatot, \u00e9s ezt \u00edrja ki a FileStream.Write m\u0171velet\u00e9vel (adott poz\u00edci\u00f3t\u00f3l), az olvas\u00e1s is b\u00e1jtokkal dolgozik: https://docs.microsoft.com/en-us/dotnet/api/system.io.file.openwrite?view=netcore-3.1#examples Sz\u00f6vegf\u00e1jlok \u00b6 A sz\u00f6vegf\u00e1jlok is f\u00e1jlok, csak \u00e9ppen a tartalmuk sz\u00f6veg, \u00edgy pl. az egyszer\u0171 Jegyzett\u00f6mb (Notepad) alkalmaz\u00e1ssal is meg lehet \u00e9rtelmesen jelen\u00edteni a tartalmukat. L\u00e9nyeges, hogy nem a f\u00e1jl kiterjeszt\u00e9s\u00e9t\u0151l lesz a f\u00e1jl sz\u00f6veges, hanem a tartalm\u00e1t\u00f3l, b\u00e1milyen kiterjeszt\u00e9s\u0171 f\u00e1jlba lehet sz\u00f6veges tartalmat ki\u00edrni (de term\u00e9szetesen logikus ilyen esetben a .txt kiterjeszt\u00e9s haszn\u00e1lata, vagy pl. a csv, ha valamilyen szepat\u00e1rorral elv\u00e1lasztott struktr\u00e1lt sz\u00f6veges tartalom van a f\u00e1jlban). A sz\u00f6vegf\u00e1jlban is b\u00e1jtok vannak, csak ezek a b\u00e1jtok sz\u00f6vegbeli karaktereket jelentenek. A klasszikus ASCII k\u00f3dol\u00e1s\u00fa sz\u00f6vegf\u00e1jlok eset\u00e9n minden b\u00e1jt pontosan egy karaktert jelent. N\u00e9zz\u00fck a fenti p\u00e9ld\u00e1nkat, amikor a f\u00e1jl tartalma a k\u00f6vetkez\u0151: 97 108 109 97 13 10 115 122 105 108 118 97 Pr\u00f3b\u00e1ljuk ezt most sz\u00f6vegf\u00e1jltk\u00e9nt \u00e9rtelmezni, ennekmegfelel\u0151en egy ASCII t\u00e1bl\u00e1zatban n\u00e9zz\u00fck meg minden egyes b\u00e1jtra, milyen karakter tartozik hozz\u00e1 (pl. itt https://hu.wikipedia.org/wiki/ASCII ): a l m a CR LF s z i v l a Vagyis egy CR+LF-vel elv\u00e1lasztott \"alma\" \u00e9s \"szilva\". Egyben, ha mint C# string n\u00e9zz\u00fck \"alma\\r\\nszilva\". Ez bizony sz\u00f6veges tartalom, vagyis egy sz\u00f6vegf\u00e1jllal van dolgunk. Ha megnyitjuk a Jegyzett\u00f6mb (Notepad) alkalmaz\u00e1sban, \u00edgy n\u00e9z ki: A tiszt\u00e1zand\u00f3 m\u00e9g, hogy mik a 10 (CR) \u00e9s 13 (LF) b\u00e1jt a k\u00f6zep\u00e9n. Egyszer\u0171en arr\u00f3l van sz\u00f3, hogy van egy sort\u00f6r\u00e9s is az alma ut\u00e1n, amit Windows oper\u00e1ci\u00f3s rendszerben k\u00e9t speci\u00e1lis karakter jel\u00f6l. C#-ban '\\r' \u00e9s egy '\\n' karakter, egy stringbe \u00edrva \"\\r\\n\". A '\\r' sz\u00e1m\u00e9rt\u00e9ke 13, a '\\n'-n\u00e9 10. Megjegyz\u00e9s: Linux oper\u00e1ci\u00f3s rendszer alatt csak egy karakter haszn\u00e1latos, a '\\n'. Megjegyz\u00e9s: A '\\n' \u00e9s a '\\n', b\u00e1r C# nyelven a forr\u00e1sk\u00f3dban k\u00e9t karakterrel jel\u00f6lj\u00fck, csak egy b\u00e1jt hossz\u00fa mindkett\u0151: a C# nyelven a egy escape szekvencia kezdet\u00e9t jel\u00f6li, vagyis pl. a '\\n' nem egy '\\' \u00e9s egy 'n' karakter egym\u00e1sut\u00e1n, hanem a '\\n' \u00f6nmag\u00e1ban jel\u00f6l egyetlen speci\u00e1lis karaktert, melynek a sz\u00e1mk\u00f3dja 13. A sz\u00f6vegf\u00e1jlok \u00edr\u00e1s\u00e1ra/olvas\u00e1s\u00e1ra egyszer\u0171bb lehet\u0151s\u00e9g\u00fcnk is van, mint b\u00e1jtokkal, b\u00e1jt\u00f6mb\u00f6kkel dolkgozni. Egyszer\u0171 sztringekkel dolgozunk. Sz\u00f6vegf\u00e1jl \u00edr\u00e1sa \u00b6 Sz\u00f6vegf\u00e1jlba \u00edrni a StreamWriter oszt\u00e1ly Write , illetve WriteLine m\u0171velet\u00e9vel tudunk: a Write egyszer\u0171en ki\u00edrja a f\u00e1jl v\u00e9g\u00e9re a param\u00e9terk\u00e9nt kapott stringet. A WriteLine is ki\u00edrja a param\u00e9terk\u00e9nt kapott stringet, de a v\u00e9g\u00e9re m\u00e9g egy sort\u00f6r\u00e9st is hozz\u00e1f\u0171z (\"\\r\\n\"), \u00edgy a k\u00e9s\u0151bbi \u00edr\u00e1s m\u00e1r egy \u00faj sorba t\u00f6rt\u00e9nik majd (ha m\u00e9g \u00edrunk a f\u00e1jlba). P\u00e9lda a fenti, k\u00e9t gy\u00fcm\u00f6lcs\u00f6t tartalmaz\u00f3 f\u00e1jl \u00edr\u00e1s\u00e1ra: string fajlUtvonal = @\"c:\\temp\\gyumolcsok.txt\" ; // #1 StreamWriter writer = new StreamWriter ( fajlUtvonal , false ); // #2 writer . WriteLine ( \"alma\" ); // #3 writer . WriteLine ( \"szilva\" ); // #4 writer . Close (); // #5 #1 - \u00datvonal a f\u00e1jlhoz. A c:\\temp mapp\u00e1nak l\u00e9teznie kell! L\u00e9nyges, hogy @ karakterrel kezdj\u00fck az \u00fatvonalat, k\u00fcl\u00f6nben a \\-t escape karakter kedet\u00e9nek veszi, \u00e9s nem \\ karakternek (vagy ha nem haszn\u00e1ljuk a @-ot, dupl\u00e1zzuk meg mindenhol a -t, \u00edgy: \\\\) #2 - A StreamWriter egy .NET be\u00e9p\u00edtett oszt\u00e1ly. Amikor l\u00e9trehozunk bel\u0151le egy p\u00e9ld\u00e1nyt, megnyitja a f\u00e1jlt. Az els\u0151 param\u00e9ter (fajlnev) adja meg a f\u00e1jl nev\u00e9t, ebbe \u00edrunk majd. A m\u00e1sodik param\u00e9ter egy bool. Ha false-t adunk meg, akkor amennyiben l\u00e9tezik m\u00e1r ilyen f\u00e1jl, ezt t\u00f6rli \u00e9s az elej\u00e9t\u0151l kezdve \u00edrunk bele. Ha true (ez \u00fan. append, hozz\u00e1f\u0171z\u00e9s m\u00f3d), akkor a m\u00e1r l\u00e9tez\u0151 file tartalma megmarad, \u00e9s amit mi bele\u00edrunk, az a v\u00e9g\u00e9hez f\u0171z\u0151dik hozz\u00e1. Megjegyz\u00e9s: ha akartunk volna, megadhattuk volna egy harmadik param\u00e9terben, hogy milyen karakterk\u00f3dol\u00e1ssal \u00edrjuk a f\u00e1jlt. #3 - Ki\u00edrja az \"alma\" sz\u00f6veget \u00e9s egy sort\u00f6r\u00e9st a writer objektum \u00e1ltal kezelt f\u00e1jl v\u00e9g\u00e9re (\"\\r\\n\"). Ha azt szerett\u00fck volna, hogy a r\u00e1k\u00f6vetkez\u0151 sorban a \"szilva\" is az \"alma\" sor\u00e1ban jelenjen meg, akkor a WriteLine helyett a Write m\u0171veletet haszn\u00e1ltuk volna. #4 - Ki\u00edrja a \"szilva\" sz\u00f6veget, \u00e9s ennek a v\u00e9g\u00e9re is tesz sort\u00f6r\u00e9st. \u00cdgy most nem is az eredeti feladatunknak megfelel\u0151 f\u00e1jlt kapjuk, abban nem volt a szilva ut\u00e1n sort\u00f6r\u00e9s! Ha ez valakit zavar, a WriteLine helyett a Write -ot kell haszn\u00e1lni. #5 - F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). Ha nem stringet, hanem pl. sz\u00e1mot szeretn\u00e9nk ki\u00edrni, akkor azt el\u0151bb stringg\u00e9 kell alak\u00edtani (pl. ToString() h\u00edv\u00e1ssal). Vagy haszn\u00e1lhatjuk a Write \u00e9s WriteLine kicsit halad\u00f3bb v\u00e1ltozat\u00e1t: string fajlUtvonal = @\"c:\\temp\\adatok.txt\" ; StreamWriter writer = new StreamWriter ( fajlnev , false ); // A {0} hely\u00e9re behelyettes\u00edti a nulladik param\u00e9tert, vagyis a 3.14-et // A {1} hely\u00e9re pedig az els\u0151 param\u00e9tert, vagyis a 8.2-5, \u00e9s \u00edgy \u00edrja ki. writer . WriteLine ( \"Pi: {0}, Ter\u00fclet: {1}\" , 3.14 , 8.2 ); writer . Close (); Teljes sz\u00f6vegf\u00e1jl \u00edr\u00e1sa egyben \u00b6 Alternat\u00edv lehet\u0151s\u00e9g f\u00e1jl \u00edr\u00e1s\u00e1ra. Ha nem darabokb\u00f3l akarjuk \u00f6sszerakni (pl. soronk\u00e9nt) a f\u00e1jlt \u00e9s nem csak hozz\u00e1f\u0171zni akarunk, hanem \u00fagy ahogy van, a teljes tartalmat ki\u00edrni, erre is van nagyon egyszer\u0171 lehet\u0151s\u00e9g: string fajlUtvonal = @\"c:\\temp\\adatok.txt\" ; string szoveg = \"alma\\r\\nszilva\" ; File . WriteAllText ( fajlUtvonal , szoveg ); A be\u00e9p\u00edtett File oszt\u00e1ly statikus WriteAllText m\u0171velet\u00e9t haszn\u00e1ljuk. Mivel ez statikus, a File-b\u00f3l nem kell a new-val objektumot l\u00e9trehozni. Csak megadjuk az \u00fatvonalat a f\u00e1jlhoz \u00e9s a stringet, aminek a tartalm\u00e1t egy az egyben ki\u00edrja a f\u00e1jlba. Ha akarunk, megadhatunk egy harmadik param\u00e9tert is (karakterk\u00f3dol\u00e1s). Sz\u00f6vegf\u00e1jl olvas\u00e1sa \u00b6 Sz\u00f6vegf\u00e1jlb\u00f3l olvasni \u00edrni a StreamReader oszt\u00e1ly Read , illetve ReadLine m\u0171velet\u00e9vel tudunk: a Read egyetlen karaktert olvas be az aktu\u00e1lis f\u00e1jlpoz\u00edci\u00f3t\u00f3l, a ReadLine pedig az aktu\u00e1lis sort olvassa be egy stringbe (vagyis addig olvas az aktu\u00e1lis f\u00e1jl poz\u00edci\u00f3t\u00f3l, m\u00edg \"\\r\\n\"-t nem tal\u00e1l, vagy el nem \u00e9r a f\u00e1jl v\u00e9g\u00e9ig). P\u00e9lda a fenti, k\u00e9t gy\u00fcm\u00f6lcs\u00f6t tartalmaz\u00f3 f\u00e1jl soronk\u00e9nt t\u00f6rt\u00e9n\u0151 beolvas\u00e1s\u00e1ra: string fajlUtvonal = @\"c:\\temp\\gyumolcsok.txt\" ; // #1 StreamReader reader = new StreamReader ( fajlUtvonal ); // #2 string gyumolcs1 = reader . ReadLine (); // #3 string gyumolcs2 = reader . ReadLine (); // #4 writer . Close (); // #5 #1 - \u00datvonal a f\u00e1jlhoz. A c:\\temp mapp\u00e1nak l\u00e9teznie kell! L\u00e9nyges, hogy @ karakterrel kezdj\u00fck az \u00fatvonalat, k\u00fcl\u00f6nben a \\-t escape karakter kedet\u00e9nek veszi, \u00e9s nem \\ karakternek (vagy ha nem haszn\u00e1ljuk a @-ot, dupl\u00e1zzuk meg mindenhol a -t, \u00edgy: \\\\) #2 - A StreamReader egy .NET be\u00e9p\u00edtett oszt\u00e1ly. Amikor l\u00e9trehozunk bel\u0151le egy p\u00e9ld\u00e1nyt, megnyitja a f\u00e1jlt. #3 - Beolvassa k\u00f6vetkez\u0151 sort \u00e9s visszat\u00e9r vele, elmentj\u00fck egy stringben. #4 - Beolvassa k\u00f6vetkez\u0151 sort \u00e9s visszat\u00e9r vele, elmentj\u00fck egy stringben. #5 - F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). \u00c1ltal\u00e1ban nem tudjuk, h\u00e1ny sorb\u00f3l \u00e1ll egy f\u00e1jl, ez\u00e9rt while ciklusban olvassuk a sorokat mindaddig, am\u00edg el nem \u00e9r\u00fcnk a f\u00e1jl v\u00e9g\u00e9re: string fajlUtvonal = @\"c:\\temp\\gyumolcsok.txt\" ; StreamReader reader = new StreamReader ( fajlUtvonal ); // Ebben t\u00e1roljuk majd az aktu\u00e1lis sort string sor ; // Beolvassuk a k\u00f6vetkez\u0151 sort a sor v\u00e1ltoz\u00f3ba. // Ha el\u00e9rt\u00fck a f\u00e1jl v\u00e9g\u00e9t, a ReadLine() null-lal t\u00e9r vissza, a sor is null lesz // \u00edgy kil\u00e9p\u00fcnk a ciklusb\u00f3l. while (( sor = sr . ReadLine ()) != null ) { // A line-ban ott az aktu\u00e1lis sor. Itt csak ki\u00edrjuk a konzolra. Console . WriteLine ( line ); } writer . Close (); // Ne felejtsd el lez\u00e1rni! A p\u00e9lda magyar\u00e1zat\u00e1t a k\u00f3dba f\u0171z\u00f6tt megjegyz\u00e9sekben l\u00e1tod. A ciklus beljes\u00e9ben gyakran nem csak ki\u00edrjuk a konzolra az aktu\u00e1lis sort, hanem fel is dolgozzuk azt. Pl., ha valamilyen szepar\u00e1tottal elv\u00e1lasztott \"elemek\" vannak benne, akkor a string.Splittel sz\u00e9t tudjuk v\u00e1gni: itt string t\u00f6mb\u00f6t kapunk, ebb\u0151l m\u00e1r megfelel\u0151 konverzi\u00f3kkal ki tudjuk nyerni a tartalmat. Pl. string [] elemek = sor . Split ( \"\\t\" ); // tab ment\u00e9n v\u00e1gunk string nev = elemek [ 0 ]; string kor = Convert . ToInt32 ( elemek [ 1 ]); ... Megjegyz\u00e9s: \u00edgy is lehet while ciklusban soron\u00e9nt felolvasni a f\u00e1jlt, ugyanaz a l\u00e9nyege, mint a fentinek, csak m\u00e1sk\u00e9nt detekt\u00e1lja a f\u00e1jl v\u00e9g\u00e9t: while (! r . EndOfStream ) { string s = r . ReadLine (); ... } Teljes sz\u00f6vegf\u00e1jl olvas\u00e1sa egyben \u00b6 Alternat\u00edv lehet\u0151s\u00e9g f\u00e1jl olvas\u00e1s\u00e1ra. Sz\u00f6vegf\u00e1jlt lehet\u0151s\u00e9g\u00fcnk van egyben (\u00e9s nem soronk\u00e9nt), egyetlen stringbe beolvasni: string fajlUtvonal = @\"c:\\temp\\adatok.txt\" ; string szoveg = File . ReadAllText ( fajlUtvonal ); Ezzel csak \u00f3vatosan, ritk\u00e1bban dolgozunk \u00edgy: ha nagy a f\u00e1jl, lehet nem f\u00e9r ez a teljes tartalom a mem\u00f3ri\u00e1ba (hiszen itt nagym\u00e9ret\u0171, ak\u00e1r t\u00f6bb gigab\u00e1jtos f\u00e1jlt is beolvashatunk), \u00e9s ekkor cs\u00fanya hib\u00e1t fogunk kapni! A szoveg sztringben megkapjuk a f\u00e1jl teljes sz\u00f6veges tartalm\u00e1t egyben. Ha sort\u00f6r\u00e9sek voltak a f\u00e1jlban, azok a stringben \"\\r\\n\"-ek lesznek! Feladat: hogyan tudjuk ezt a stringet sort\u00f6r\u00e9sek ment\u00e9n v\u00e1gni, \u00e9s egy string t\u00f6mbben a sorokat megkapni? (a v\u00e1lasz szoveg.Split(\"\\r\\n)). Itt tal\u00e1lsz j\u00f3 magyar\u00e1zatot \u00e9s p\u00e9ld\u00e1kat sz\u00f6vegf\u00e1jl \u00edr\u00e1s\u00e1ra \u00e9s olvas\u00e1s\u00e1ra is: http://aries.ektf.hu/~hz/wiki7/mprog1ea/text_file Tov\u00e1bbi l\u00e9nyeges inform\u00e1ci\u00f3k \u00b6 TODO (Van m\u00e9g? - igen, a biztos f\u00e1jl lez\u00e1r\u00e1s, using blokk) Feladat \u00b6 \u00cdrj egy f\u00fcggv\u00e9nyt, mely egy sz\u00f6veges f\u00e1jl tartalm\u00e1t \u00e1tm\u00e1solja egy m\u00e1sik f\u00e1jlba. K\u00e9t param\u00e9tere van: \u00fatvonal a forr\u00e1sf\u00e1jlhoz, illetve \u00fatvonal a c\u00e9lf\u00e1jlhoz. K\u00e9t v\u00e1ltozat\u00e1t \u00e9s k\u00e9sz\u00edtsd el. Az els\u0151, egyszer\u0171 megold\u00e1sban a File.ReadAllText \u00e9s File.WriteAllText-et haszn\u00e1lhatod. A m\u00e1sodik megold\u00e1s legyen takar\u00e9kos a mem\u00f3ri\u00e1val, m\u0171k\u00f6dj\u00f6n akkor is, ha \u00f3ri\u00e1si f\u00e1jl kell m\u00e1solni. Azt felteheted, hogy a f\u00e1jl sok sorb\u00f3l \u00e1ll (vagyis soronk\u00e9nt c\u00e9lszer\u0171 a f\u00e1jlt m\u00e1solni).","title":"F\u00e1jlkezel\u00e9s"},{"location":"Fajlkezeles/fajl-alapok/#fajlkezeles","text":"A program fut\u00e1sa sor\u00e1n sokszor adatokat \u00e1ll\u00edt el\u0151, adatokat k\u00e9r be, ezekkel sz\u00e1m\u00edt\u00e1sokat v\u00e9gez. Gyakran van ig\u00e9ny arra, hogy ezen adatokat valamilyen form\u00e1ban ki\u00edrjuk egy f\u00e1jlban h\u00e1tt\u00e9rt\u00e1rra (diszkre). M\u00edg a mem\u00f3ri\u00e1ban t\u00e1rolt adatok az alkalmaz\u00e1s \u00fajraindul\u00e1sa sor\u00e1n elvesznek, a h\u00e1tt\u00e9rt\u00e1ron lev\u0151 adatok megmaradnak, m\u00e9g akkor is, ha a sz\u00e1m\u00edt\u00f3g\u00e9p \u00fajraindul. Ezen fel\u00fcl a f\u00e1jlok seg\u00edts\u00e9g\u00e9vel nagyon egyszer\u0171 m\u00f3don tudnak alkalmaz\u00e1sok egym\u00e1ssal kommunik\u00e1lni, adatot megosztani. Pl. az egyik alkalmaz\u00e1s ki\u00edrja az adatot egy f\u00e1jlba, egy m\u00e1sik pedig beolvassa. Egy f\u00e1jlra m\u00e1s sz\u00f3val **\u00e1llom\u00e1ny**k\u00e9nt \u00e9s szok\u00e1s hivatkozni (\u00edgy a f\u00e1jlkezel\u00e9s ugyanazt jelenti, mint az \u00e1llom\u00e1nykezel\u00e9s.) Minden f\u00e1jlt egy \u00fatvonal azonos\u00edt, mely megmondja, mely meghajt\u00f3n, annak milyen mapp\u00e1j\u00e1ban van a f\u00e1jl. Pl.: c:\\work\\temp\\gyumolcsok.txt. A f\u00e1jl tartalma, ha nagyon szigor\u00faan n\u00e9zz\u00fck, akkor bitek (igaz/hamis, 0/1) egym\u00e1sut\u00e1nja, mint minden a digit\u00e1lis vil\u00e1gban. A sz\u00e1m\u00edt\u00f3g\u00e9pek alcsony szinten csak a biteket \u00e9rtik, illetve a h\u00e1tt\u00e9rt\u00e1rak is biteket tudnak nyersen t\u00e1rolni. Pl. egy f\u00e1jl nyers tartalma lehet a k\u00f6vetkez\u0151 bithalmaz: 01100001 01101100 01101101 01100001 00001101 00001010 01110011 01111010 01101001 01101100 01110110 01100001 Szukjuk a gondolatot, hogy minden f\u00e1jl a dolgok legm\u00e9ly\u00e9n hasonl\u00f3k\u00e9ppen bitek sorozat\u00e1b\u00f3l \u00e1ll... A bitek a h\u00e1tt\u00e9rt\u00e1ron gyakran folytat\u00f3lagosan helyezkednek el, de mivel sz\u00e1munka ez teljesen \u00e1tl\u00e1thatatlan lenne, \u00edgy 8 bitenk\u00e9nt csoportos\u00edtva jelen\u00edtett\u00fck meg fent. A gyakorlatban soha nem szoktunk f\u00e1jlok tartalm\u00e1val bitenk\u00e9nt dolgozni. A biteket 8-as csoportokban dolgozzuk fel. 8 bit egy b\u00e1jt. Egy b\u00e1jt 0 \u00e9s 255 k\u00f6z\u00f6tt vehet fel \u00e9rt\u00e9keket. pl. a 00000000 bitsorozat b\u00e1jt\u00e9rt\u00e9ke 0, a 00000001-\u00e9 1, a 00000010-\u00e9 2, a 00000011-\u00e9 3, az 11111111-\u00e9 pedig 255. A l\u00e9nyeg, hogy a f\u00e1jlok tartalm\u00e1ra most m\u00e1r nem mint bitek, hanem f\u00e1jlok sorozat\u00e1ra gondolunk. A fenti f\u00e1jl p\u00e9ld\u00e1nk \u00edgy n\u00e9z ki b\u00e1jtokkal reprezent\u00e1lva (minden 8-as bin\u00e1rist \u00e1tsz\u00e1moltunk b\u00e1jtra, ebben p\u00e9d\u00e1ul a Windows-ban lev\u0151 Sz\u00e1mol\u00f3g\u00e9p alkalmaz\u00e1s is seg\u00edts\u00e9g\u00fcnkre lehet, csak \u00e1t kell kapcsolni Programoz\u00f3 \u00fczemm\u00f3dra - \u00e9rdemes kipr\u00f3b\u00e1lni): 97 108 109 97 13 10 115 122 105 108 118 97 Ez \u00edgy m\u00e1s sokkal \u00e1tl\u00e1that\u00f3bb. Mostant\u00f3l \u00fagy gondolunk minden f\u00e1jlra, mint b\u00e1jtok egym\u00e1s ut\u00e1n k\u00f6vetkez\u0151 sorozat\u00e1ra. Pl. amikor egy k\u00e9p f\u00e1jr\u00f3l van sz\u00f3, ezekbe a sz\u00e1mokban a k\u00e9p pixeljeinek sz\u00ednei vannak \"belek\u00f3dolva\". Egy egyszer\u0171 sz\u00f6vegf\u00e1jl eset\u00e9n pedig ezek a sz\u00e1mok a sz\u00f6veg egyes karaktereit jelentik (erre m\u00e9g visszat\u00e9r\u00fcnk). Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokat \u00edrunk \u00e9s olvasunk nyersen, akkor b\u00e1jtokat \u00edrunk ki \u00e9s b\u00e1jtokat olvasunk be. Pl. C# nyelven ki tudjuk \u00edrni egy b\u00e1jl t\u00f6mb tartalm\u00e1t, vagy be tudunk olvasni f\u00e1jlb\u00f3l r\u00e9szeket egy b\u00e1jt t\u00f6mbbe.","title":"F\u00e1jlkezel\u00e9s"},{"location":"Fajlkezeles/fajl-alapok/#fajlkezeles-altalanossagaban","text":"Amikor valamilyen programoz\u00e1si nyelven f\u00e1jlokkal dolgozunk, akkor lehet\u0151s\u00e9g\u00fcnk van: * A f\u00e1jl tartalm\u00e1t olvasni. * A f\u00e1jl tartalm\u00e1t \u00edrni (ez m\u00f3dos\u00edtja a tartalmat) * F\u00e1jlt l\u00e9trehozni, t\u00f6r\u00f6lni, \u00e1tnevezni, mozgatni, stb. A f\u00e1jl tartalm\u00e1nak olvas\u00e1sa/\u00edr\u00e1sa az al\u00e1bbiaknak megfelel\u0151en t\u00f6rt\u00e9nik: F\u00e1jlt megnyit\u00e1sa Tartalom olvas\u00e1sa vagy \u00edr\u00e1sa C# k\u00f3db\u00f3l be tudunk olvasni adott pozici\u00f3t\u00f3l adott darabsz\u00e1m\u00fa b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l k\u00e9r\u00fcnk 100-at), \u00e9s az pl. egy b\u00e1jt t\u00f6mbbe ker\u00fcl. Onnan tudjuk tov\u00e1bb alak\u00edtani sz\u00e1mm\u00e1, sztring\u00e9, vagy ahogy \u00e9rtelmezni k\u00edv\u00e1njuk az adatokat. Arra vigy\u00e1zni kell, hogy a f\u00e1jl v\u00e9g\u00e9n ne akarjunk t\u00falolvasni (pl. ha 1000 b\u00e1jlt van egy f\u00e1jlban, ne akarjuk az 1001-ediket beolvasni.) Adott poz\u00edci\u00f3t\u00f3l ki tudunk \u00edrni adott darab b\u00e1jtot (pl. mondhajuk, hogy a 10-edik b\u00e1jtt\u00f3l ki\u00edrunk 100 \u00e1ltalunk mehat\u00e1rozott b\u00e1jtot). Amikor nem b\u00e1jtot/b\u00e1jt t\u00f6mb\u00f6t \u00edrunk ki, f\u00e1jlba, hanem pl. sz\u00e1mot, sztringet, vagy m\u00e1s t\u00edpust, azt is el\u0151sz\u00f6r b\u00e1jtokk\u00e1 kell alak\u00edtani a f\u00e1jlba \u00edr\u00e1s el\u0151tt (szerencs\u00e9re a .NET sz\u00e1munkra ezt sokszor elrejti). F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). K\u00f3d \u00e9s p\u00e9lda. Az alacsonyabb, b\u00e1jtszint\u0171 f\u00e1jlkezel\u00e9sre ritk\u00e1bban van sz\u00fcks\u00e9g, \u00edgy erre nem n\u00e9z\u00fcnk p\u00e9ld\u00e1kat. De itt van egy\u00e9bk\u00e9nt egy p\u00e9lda, az l\u00e1tsz\u00f3dik, hogy a File oszt\u00e1llyal nyitja meg a f\u00e1jlt, \u00e9s ut\u00e1n byte t\u00f6mbe teszi az adatot, \u00e9s ezt \u00edrja ki a FileStream.Write m\u0171velet\u00e9vel (adott poz\u00edci\u00f3t\u00f3l), az olvas\u00e1s is b\u00e1jtokkal dolgozik: https://docs.microsoft.com/en-us/dotnet/api/system.io.file.openwrite?view=netcore-3.1#examples","title":"F\u00e1jlkezel\u00e9s \u00e1ltal\u00e1noss\u00e1g\u00e1ban"},{"location":"Fajlkezeles/fajl-alapok/#szovegfajlok","text":"A sz\u00f6vegf\u00e1jlok is f\u00e1jlok, csak \u00e9ppen a tartalmuk sz\u00f6veg, \u00edgy pl. az egyszer\u0171 Jegyzett\u00f6mb (Notepad) alkalmaz\u00e1ssal is meg lehet \u00e9rtelmesen jelen\u00edteni a tartalmukat. L\u00e9nyeges, hogy nem a f\u00e1jl kiterjeszt\u00e9s\u00e9t\u0151l lesz a f\u00e1jl sz\u00f6veges, hanem a tartalm\u00e1t\u00f3l, b\u00e1milyen kiterjeszt\u00e9s\u0171 f\u00e1jlba lehet sz\u00f6veges tartalmat ki\u00edrni (de term\u00e9szetesen logikus ilyen esetben a .txt kiterjeszt\u00e9s haszn\u00e1lata, vagy pl. a csv, ha valamilyen szepat\u00e1rorral elv\u00e1lasztott struktr\u00e1lt sz\u00f6veges tartalom van a f\u00e1jlban). A sz\u00f6vegf\u00e1jlban is b\u00e1jtok vannak, csak ezek a b\u00e1jtok sz\u00f6vegbeli karaktereket jelentenek. A klasszikus ASCII k\u00f3dol\u00e1s\u00fa sz\u00f6vegf\u00e1jlok eset\u00e9n minden b\u00e1jt pontosan egy karaktert jelent. N\u00e9zz\u00fck a fenti p\u00e9ld\u00e1nkat, amikor a f\u00e1jl tartalma a k\u00f6vetkez\u0151: 97 108 109 97 13 10 115 122 105 108 118 97 Pr\u00f3b\u00e1ljuk ezt most sz\u00f6vegf\u00e1jltk\u00e9nt \u00e9rtelmezni, ennekmegfelel\u0151en egy ASCII t\u00e1bl\u00e1zatban n\u00e9zz\u00fck meg minden egyes b\u00e1jtra, milyen karakter tartozik hozz\u00e1 (pl. itt https://hu.wikipedia.org/wiki/ASCII ): a l m a CR LF s z i v l a Vagyis egy CR+LF-vel elv\u00e1lasztott \"alma\" \u00e9s \"szilva\". Egyben, ha mint C# string n\u00e9zz\u00fck \"alma\\r\\nszilva\". Ez bizony sz\u00f6veges tartalom, vagyis egy sz\u00f6vegf\u00e1jllal van dolgunk. Ha megnyitjuk a Jegyzett\u00f6mb (Notepad) alkalmaz\u00e1sban, \u00edgy n\u00e9z ki: A tiszt\u00e1zand\u00f3 m\u00e9g, hogy mik a 10 (CR) \u00e9s 13 (LF) b\u00e1jt a k\u00f6zep\u00e9n. Egyszer\u0171en arr\u00f3l van sz\u00f3, hogy van egy sort\u00f6r\u00e9s is az alma ut\u00e1n, amit Windows oper\u00e1ci\u00f3s rendszerben k\u00e9t speci\u00e1lis karakter jel\u00f6l. C#-ban '\\r' \u00e9s egy '\\n' karakter, egy stringbe \u00edrva \"\\r\\n\". A '\\r' sz\u00e1m\u00e9rt\u00e9ke 13, a '\\n'-n\u00e9 10. Megjegyz\u00e9s: Linux oper\u00e1ci\u00f3s rendszer alatt csak egy karakter haszn\u00e1latos, a '\\n'. Megjegyz\u00e9s: A '\\n' \u00e9s a '\\n', b\u00e1r C# nyelven a forr\u00e1sk\u00f3dban k\u00e9t karakterrel jel\u00f6lj\u00fck, csak egy b\u00e1jt hossz\u00fa mindkett\u0151: a C# nyelven a egy escape szekvencia kezdet\u00e9t jel\u00f6li, vagyis pl. a '\\n' nem egy '\\' \u00e9s egy 'n' karakter egym\u00e1sut\u00e1n, hanem a '\\n' \u00f6nmag\u00e1ban jel\u00f6l egyetlen speci\u00e1lis karaktert, melynek a sz\u00e1mk\u00f3dja 13. A sz\u00f6vegf\u00e1jlok \u00edr\u00e1s\u00e1ra/olvas\u00e1s\u00e1ra egyszer\u0171bb lehet\u0151s\u00e9g\u00fcnk is van, mint b\u00e1jtokkal, b\u00e1jt\u00f6mb\u00f6kkel dolkgozni. Egyszer\u0171 sztringekkel dolgozunk.","title":"Sz\u00f6vegf\u00e1jlok"},{"location":"Fajlkezeles/fajl-alapok/#szovegfajl-irasa","text":"Sz\u00f6vegf\u00e1jlba \u00edrni a StreamWriter oszt\u00e1ly Write , illetve WriteLine m\u0171velet\u00e9vel tudunk: a Write egyszer\u0171en ki\u00edrja a f\u00e1jl v\u00e9g\u00e9re a param\u00e9terk\u00e9nt kapott stringet. A WriteLine is ki\u00edrja a param\u00e9terk\u00e9nt kapott stringet, de a v\u00e9g\u00e9re m\u00e9g egy sort\u00f6r\u00e9st is hozz\u00e1f\u0171z (\"\\r\\n\"), \u00edgy a k\u00e9s\u0151bbi \u00edr\u00e1s m\u00e1r egy \u00faj sorba t\u00f6rt\u00e9nik majd (ha m\u00e9g \u00edrunk a f\u00e1jlba). P\u00e9lda a fenti, k\u00e9t gy\u00fcm\u00f6lcs\u00f6t tartalmaz\u00f3 f\u00e1jl \u00edr\u00e1s\u00e1ra: string fajlUtvonal = @\"c:\\temp\\gyumolcsok.txt\" ; // #1 StreamWriter writer = new StreamWriter ( fajlUtvonal , false ); // #2 writer . WriteLine ( \"alma\" ); // #3 writer . WriteLine ( \"szilva\" ); // #4 writer . Close (); // #5 #1 - \u00datvonal a f\u00e1jlhoz. A c:\\temp mapp\u00e1nak l\u00e9teznie kell! L\u00e9nyges, hogy @ karakterrel kezdj\u00fck az \u00fatvonalat, k\u00fcl\u00f6nben a \\-t escape karakter kedet\u00e9nek veszi, \u00e9s nem \\ karakternek (vagy ha nem haszn\u00e1ljuk a @-ot, dupl\u00e1zzuk meg mindenhol a -t, \u00edgy: \\\\) #2 - A StreamWriter egy .NET be\u00e9p\u00edtett oszt\u00e1ly. Amikor l\u00e9trehozunk bel\u0151le egy p\u00e9ld\u00e1nyt, megnyitja a f\u00e1jlt. Az els\u0151 param\u00e9ter (fajlnev) adja meg a f\u00e1jl nev\u00e9t, ebbe \u00edrunk majd. A m\u00e1sodik param\u00e9ter egy bool. Ha false-t adunk meg, akkor amennyiben l\u00e9tezik m\u00e1r ilyen f\u00e1jl, ezt t\u00f6rli \u00e9s az elej\u00e9t\u0151l kezdve \u00edrunk bele. Ha true (ez \u00fan. append, hozz\u00e1f\u0171z\u00e9s m\u00f3d), akkor a m\u00e1r l\u00e9tez\u0151 file tartalma megmarad, \u00e9s amit mi bele\u00edrunk, az a v\u00e9g\u00e9hez f\u0171z\u0151dik hozz\u00e1. Megjegyz\u00e9s: ha akartunk volna, megadhattuk volna egy harmadik param\u00e9terben, hogy milyen karakterk\u00f3dol\u00e1ssal \u00edrjuk a f\u00e1jlt. #3 - Ki\u00edrja az \"alma\" sz\u00f6veget \u00e9s egy sort\u00f6r\u00e9st a writer objektum \u00e1ltal kezelt f\u00e1jl v\u00e9g\u00e9re (\"\\r\\n\"). Ha azt szerett\u00fck volna, hogy a r\u00e1k\u00f6vetkez\u0151 sorban a \"szilva\" is az \"alma\" sor\u00e1ban jelenjen meg, akkor a WriteLine helyett a Write m\u0171veletet haszn\u00e1ltuk volna. #4 - Ki\u00edrja a \"szilva\" sz\u00f6veget, \u00e9s ennek a v\u00e9g\u00e9re is tesz sort\u00f6r\u00e9st. \u00cdgy most nem is az eredeti feladatunknak megfelel\u0151 f\u00e1jlt kapjuk, abban nem volt a szilva ut\u00e1n sort\u00f6r\u00e9s! Ha ez valakit zavar, a WriteLine helyett a Write -ot kell haszn\u00e1lni. #5 - F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). Ha nem stringet, hanem pl. sz\u00e1mot szeretn\u00e9nk ki\u00edrni, akkor azt el\u0151bb stringg\u00e9 kell alak\u00edtani (pl. ToString() h\u00edv\u00e1ssal). Vagy haszn\u00e1lhatjuk a Write \u00e9s WriteLine kicsit halad\u00f3bb v\u00e1ltozat\u00e1t: string fajlUtvonal = @\"c:\\temp\\adatok.txt\" ; StreamWriter writer = new StreamWriter ( fajlnev , false ); // A {0} hely\u00e9re behelyettes\u00edti a nulladik param\u00e9tert, vagyis a 3.14-et // A {1} hely\u00e9re pedig az els\u0151 param\u00e9tert, vagyis a 8.2-5, \u00e9s \u00edgy \u00edrja ki. writer . WriteLine ( \"Pi: {0}, Ter\u00fclet: {1}\" , 3.14 , 8.2 ); writer . Close ();","title":"Sz\u00f6vegf\u00e1jl \u00edr\u00e1sa"},{"location":"Fajlkezeles/fajl-alapok/#teljes-szovegfajl-irasa-egyben","text":"Alternat\u00edv lehet\u0151s\u00e9g f\u00e1jl \u00edr\u00e1s\u00e1ra. Ha nem darabokb\u00f3l akarjuk \u00f6sszerakni (pl. soronk\u00e9nt) a f\u00e1jlt \u00e9s nem csak hozz\u00e1f\u0171zni akarunk, hanem \u00fagy ahogy van, a teljes tartalmat ki\u00edrni, erre is van nagyon egyszer\u0171 lehet\u0151s\u00e9g: string fajlUtvonal = @\"c:\\temp\\adatok.txt\" ; string szoveg = \"alma\\r\\nszilva\" ; File . WriteAllText ( fajlUtvonal , szoveg ); A be\u00e9p\u00edtett File oszt\u00e1ly statikus WriteAllText m\u0171velet\u00e9t haszn\u00e1ljuk. Mivel ez statikus, a File-b\u00f3l nem kell a new-val objektumot l\u00e9trehozni. Csak megadjuk az \u00fatvonalat a f\u00e1jlhoz \u00e9s a stringet, aminek a tartalm\u00e1t egy az egyben ki\u00edrja a f\u00e1jlba. Ha akarunk, megadhatunk egy harmadik param\u00e9tert is (karakterk\u00f3dol\u00e1s).","title":"Teljes sz\u00f6vegf\u00e1jl \u00edr\u00e1sa egyben"},{"location":"Fajlkezeles/fajl-alapok/#szovegfajl-olvasasa","text":"Sz\u00f6vegf\u00e1jlb\u00f3l olvasni \u00edrni a StreamReader oszt\u00e1ly Read , illetve ReadLine m\u0171velet\u00e9vel tudunk: a Read egyetlen karaktert olvas be az aktu\u00e1lis f\u00e1jlpoz\u00edci\u00f3t\u00f3l, a ReadLine pedig az aktu\u00e1lis sort olvassa be egy stringbe (vagyis addig olvas az aktu\u00e1lis f\u00e1jl poz\u00edci\u00f3t\u00f3l, m\u00edg \"\\r\\n\"-t nem tal\u00e1l, vagy el nem \u00e9r a f\u00e1jl v\u00e9g\u00e9ig). P\u00e9lda a fenti, k\u00e9t gy\u00fcm\u00f6lcs\u00f6t tartalmaz\u00f3 f\u00e1jl soronk\u00e9nt t\u00f6rt\u00e9n\u0151 beolvas\u00e1s\u00e1ra: string fajlUtvonal = @\"c:\\temp\\gyumolcsok.txt\" ; // #1 StreamReader reader = new StreamReader ( fajlUtvonal ); // #2 string gyumolcs1 = reader . ReadLine (); // #3 string gyumolcs2 = reader . ReadLine (); // #4 writer . Close (); // #5 #1 - \u00datvonal a f\u00e1jlhoz. A c:\\temp mapp\u00e1nak l\u00e9teznie kell! L\u00e9nyges, hogy @ karakterrel kezdj\u00fck az \u00fatvonalat, k\u00fcl\u00f6nben a \\-t escape karakter kedet\u00e9nek veszi, \u00e9s nem \\ karakternek (vagy ha nem haszn\u00e1ljuk a @-ot, dupl\u00e1zzuk meg mindenhol a -t, \u00edgy: \\\\) #2 - A StreamReader egy .NET be\u00e9p\u00edtett oszt\u00e1ly. Amikor l\u00e9trehozunk bel\u0151le egy p\u00e9ld\u00e1nyt, megnyitja a f\u00e1jlt. #3 - Beolvassa k\u00f6vetkez\u0151 sort \u00e9s visszat\u00e9r vele, elmentj\u00fck egy stringben. #4 - Beolvassa k\u00f6vetkez\u0151 sort \u00e9s visszat\u00e9r vele, elmentj\u00fck egy stringben. #5 - F\u00e1jl lez\u00e1r\u00e1sa. Ez is fontos, mert ha elmarad, akkor lehet ki sem \u00edr\u00f3dnak a m\u00f3dos\u00edt\u00e1sok, vagy a f\u00e1jl z\u00e1rolva lesz, \u00edgy nem tudjuk m\u00e1s alkalmaz\u00e1sokb\u00f3l megnyitni, m\u00f3dos\u00edtani, t\u00f6r\u00f6lni (ez att\u00f3l f\u00fcgg, hogy nyitottuk meg a f\u00e1jlt). \u00c1ltal\u00e1ban nem tudjuk, h\u00e1ny sorb\u00f3l \u00e1ll egy f\u00e1jl, ez\u00e9rt while ciklusban olvassuk a sorokat mindaddig, am\u00edg el nem \u00e9r\u00fcnk a f\u00e1jl v\u00e9g\u00e9re: string fajlUtvonal = @\"c:\\temp\\gyumolcsok.txt\" ; StreamReader reader = new StreamReader ( fajlUtvonal ); // Ebben t\u00e1roljuk majd az aktu\u00e1lis sort string sor ; // Beolvassuk a k\u00f6vetkez\u0151 sort a sor v\u00e1ltoz\u00f3ba. // Ha el\u00e9rt\u00fck a f\u00e1jl v\u00e9g\u00e9t, a ReadLine() null-lal t\u00e9r vissza, a sor is null lesz // \u00edgy kil\u00e9p\u00fcnk a ciklusb\u00f3l. while (( sor = sr . ReadLine ()) != null ) { // A line-ban ott az aktu\u00e1lis sor. Itt csak ki\u00edrjuk a konzolra. Console . WriteLine ( line ); } writer . Close (); // Ne felejtsd el lez\u00e1rni! A p\u00e9lda magyar\u00e1zat\u00e1t a k\u00f3dba f\u0171z\u00f6tt megjegyz\u00e9sekben l\u00e1tod. A ciklus beljes\u00e9ben gyakran nem csak ki\u00edrjuk a konzolra az aktu\u00e1lis sort, hanem fel is dolgozzuk azt. Pl., ha valamilyen szepar\u00e1tottal elv\u00e1lasztott \"elemek\" vannak benne, akkor a string.Splittel sz\u00e9t tudjuk v\u00e1gni: itt string t\u00f6mb\u00f6t kapunk, ebb\u0151l m\u00e1r megfelel\u0151 konverzi\u00f3kkal ki tudjuk nyerni a tartalmat. Pl. string [] elemek = sor . Split ( \"\\t\" ); // tab ment\u00e9n v\u00e1gunk string nev = elemek [ 0 ]; string kor = Convert . ToInt32 ( elemek [ 1 ]); ... Megjegyz\u00e9s: \u00edgy is lehet while ciklusban soron\u00e9nt felolvasni a f\u00e1jlt, ugyanaz a l\u00e9nyege, mint a fentinek, csak m\u00e1sk\u00e9nt detekt\u00e1lja a f\u00e1jl v\u00e9g\u00e9t: while (! r . EndOfStream ) { string s = r . ReadLine (); ... }","title":"Sz\u00f6vegf\u00e1jl olvas\u00e1sa"},{"location":"Fajlkezeles/fajl-alapok/#teljes-szovegfajl-olvasasa-egyben","text":"Alternat\u00edv lehet\u0151s\u00e9g f\u00e1jl olvas\u00e1s\u00e1ra. Sz\u00f6vegf\u00e1jlt lehet\u0151s\u00e9g\u00fcnk van egyben (\u00e9s nem soronk\u00e9nt), egyetlen stringbe beolvasni: string fajlUtvonal = @\"c:\\temp\\adatok.txt\" ; string szoveg = File . ReadAllText ( fajlUtvonal ); Ezzel csak \u00f3vatosan, ritk\u00e1bban dolgozunk \u00edgy: ha nagy a f\u00e1jl, lehet nem f\u00e9r ez a teljes tartalom a mem\u00f3ri\u00e1ba (hiszen itt nagym\u00e9ret\u0171, ak\u00e1r t\u00f6bb gigab\u00e1jtos f\u00e1jlt is beolvashatunk), \u00e9s ekkor cs\u00fanya hib\u00e1t fogunk kapni! A szoveg sztringben megkapjuk a f\u00e1jl teljes sz\u00f6veges tartalm\u00e1t egyben. Ha sort\u00f6r\u00e9sek voltak a f\u00e1jlban, azok a stringben \"\\r\\n\"-ek lesznek! Feladat: hogyan tudjuk ezt a stringet sort\u00f6r\u00e9sek ment\u00e9n v\u00e1gni, \u00e9s egy string t\u00f6mbben a sorokat megkapni? (a v\u00e1lasz szoveg.Split(\"\\r\\n)). Itt tal\u00e1lsz j\u00f3 magyar\u00e1zatot \u00e9s p\u00e9ld\u00e1kat sz\u00f6vegf\u00e1jl \u00edr\u00e1s\u00e1ra \u00e9s olvas\u00e1s\u00e1ra is: http://aries.ektf.hu/~hz/wiki7/mprog1ea/text_file","title":"Teljes sz\u00f6vegf\u00e1jl olvas\u00e1sa egyben"},{"location":"Fajlkezeles/fajl-alapok/#tovabbi-lenyeges-informaciok","text":"TODO (Van m\u00e9g? - igen, a biztos f\u00e1jl lez\u00e1r\u00e1s, using blokk)","title":"Tov\u00e1bbi l\u00e9nyeges inform\u00e1ci\u00f3k"},{"location":"Fajlkezeles/fajl-alapok/#feladat","text":"\u00cdrj egy f\u00fcggv\u00e9nyt, mely egy sz\u00f6veges f\u00e1jl tartalm\u00e1t \u00e1tm\u00e1solja egy m\u00e1sik f\u00e1jlba. K\u00e9t param\u00e9tere van: \u00fatvonal a forr\u00e1sf\u00e1jlhoz, illetve \u00fatvonal a c\u00e9lf\u00e1jlhoz. K\u00e9t v\u00e1ltozat\u00e1t \u00e9s k\u00e9sz\u00edtsd el. Az els\u0151, egyszer\u0171 megold\u00e1sban a File.ReadAllText \u00e9s File.WriteAllText-et haszn\u00e1lhatod. A m\u00e1sodik megold\u00e1s legyen takar\u00e9kos a mem\u00f3ri\u00e1val, m\u0171k\u00f6dj\u00f6n akkor is, ha \u00f3ri\u00e1si f\u00e1jl kell m\u00e1solni. Azt felteheted, hogy a f\u00e1jl sok sorb\u00f3l \u00e1ll (vagyis soronk\u00e9nt c\u00e9lszer\u0171 a f\u00e1jlt m\u00e1solni).","title":"Feladat"},{"location":"Fajlkezeles/fajl-feladat-megoldasok/","text":"F\u00e1jlkezel\u00e9s - Feladatok megold\u00e1sa \u00b6 Feladat 1 \u00b6 Itt csak egy egyszer\u0171, a Main f\u00fcggv\u00e9nyb\u0151l is haszn\u00e1lhat\u00f3 statikus f\u00fcggv\u00e9nyt \u00edrunk mag\u00e1ban a Porgram.cs f\u00e1jlban: public static FileAtmasolo ( string fajlutvonalbe , string fajlutvonalki ) { string szoveg = File . ReadAllText ( fajlutvonalbe ); File . WriteAllText ( fajlutvonalki , szoveg ); } Feladat 2 \u00b6 2.1 \u00b6 Mivel itt az volt a k\u00e9r\u00e9s, hogy a lehet\u0151 legegyszer\u0171bben, p\u00e9ld\u00e1nyos\u00edt\u00e1s n\u00e9lk\u00fcl lehessen haszn\u00e1lni, a Masol f\u00fcggv\u00e9nyt statikuss\u00e1 tett\u00fck: class FileAtmasolo { public static void Masol ( string fajlutvonalbe , string fajlutvonalki ) { StreamReader olvaso = new StreamReader ( fajlutvonalbe ); StreamWriter iro = new StreamWriter ( fajlutvonalki ); string tar ; while (! olvaso . EndOfStream ) { tar = olvaso . ReadLine (); iro . WriteLine ( tar ); } olvaso . Close (); iro . Close (); } } Haszn\u00e1lat: string fajlutvonalbe = @\"C:\\4_Tarsalgo\\ajto.txt\" ; string fajlutvonalki = @\"C:\\4_Tarsalgo\\ajto2.txt\" ; // Mivel statikus, nem kell p\u00e9ld\u00e1nyos\u00edtani, az oszt\u00e1ly nev\u00e9n kereszt\u00fcl h\u00edvhat\u00f3 a `Masol` f\u00fcggv\u00e9ny: FileAtmasolo . Masol ( fajlutvonalbe , fajlutvonalki ); 2.2 \u00b6 Itt az a c\u00e9l, hogy a l\u00e9trehoz\u00e1skor me tudjuk adni az \u00fatvonalakat: ehhez kell egy megfelel\u0151 kontruktor. Ez k\u00e9t tagv\u00e1ltoz\u00f3ban elt\u00e1rolja az \u00fatvonalakat. Az\u00e9rt, hogy a Masol f\u00fcggv\u00e9nyben, ami a t\u00e9nyleges m\u00e1sol\u00e1st v\u00e9gzi, el\u00e9rhet\u0151 legyen. class FileAtmasolo { string fajlutvonalbe ; string fajlutvonalki ; public FileAtmasolo ( string fajlutvonalbe , string fajlutvonalki ) { this . fajlutvonalbe = fajlutvonalbe ; this . fajlutvonalki = fajlutvonalki ; } public void Masol () { StreamReader olvaso = new StreamReader ( fajlutvonalbe ); StreamWriter iro = new StreamWriter ( fajlutvonalki ); string tar ; while (! olvaso . EndOfStream ) { tar = Console . ReadLine (); iro . WriteLine ( tar ); } olvaso . Close (); iro . Close (); } } Haszn\u00e1lat: string fajlutvonalbe = @\"C:\\4_Tarsalgo\\ajto.txt\" ; string fajlutvonalki = @\"C:\\4_Tarsalgo\\ajto2.txt\" ; // Mivel itt semmi nem statikus, l\u00e9tre kell hozni egy objektumot. // A l\u00e9tehoz\u00e1s sor\u00e1n \u00e1tadjuk a k\u00e9t \u00fatvonalat, ezt az objektum // tagv\u00e1ltoz\u00f3kban elt\u00e1rolja FileAtmasolo fileAtmasolo = new FileAtmasolo ( fajlutvonalbe , fajlutvonalki ); // Az objektumra megh\u00edvjuk a Masol() m\u0171veletet, ez v\u00e9gzi a m\u00e1sol\u00e1st // Itt m\u00e1r nem adjuk meg az \u00fatvonalakat, mert a fileAtmasolo objektum a // a tagv\u00e1ltoz\u00f3iban elt\u00e1rolta, a Masol m\u0171velet ezt el\u00e9ri. fileAtmasolo . Masol ();","title":"Feladat megol\u00e1sok"},{"location":"Fajlkezeles/fajl-feladat-megoldasok/#fajlkezeles-feladatok-megoldasa","text":"","title":"F\u00e1jlkezel\u00e9s - Feladatok megold\u00e1sa"},{"location":"Fajlkezeles/fajl-feladat-megoldasok/#feladat-1","text":"Itt csak egy egyszer\u0171, a Main f\u00fcggv\u00e9nyb\u0151l is haszn\u00e1lhat\u00f3 statikus f\u00fcggv\u00e9nyt \u00edrunk mag\u00e1ban a Porgram.cs f\u00e1jlban: public static FileAtmasolo ( string fajlutvonalbe , string fajlutvonalki ) { string szoveg = File . ReadAllText ( fajlutvonalbe ); File . WriteAllText ( fajlutvonalki , szoveg ); }","title":"Feladat 1"},{"location":"Fajlkezeles/fajl-feladat-megoldasok/#feladat-2","text":"","title":"Feladat 2"},{"location":"Fajlkezeles/fajl-feladat-megoldasok/#21","text":"Mivel itt az volt a k\u00e9r\u00e9s, hogy a lehet\u0151 legegyszer\u0171bben, p\u00e9ld\u00e1nyos\u00edt\u00e1s n\u00e9lk\u00fcl lehessen haszn\u00e1lni, a Masol f\u00fcggv\u00e9nyt statikuss\u00e1 tett\u00fck: class FileAtmasolo { public static void Masol ( string fajlutvonalbe , string fajlutvonalki ) { StreamReader olvaso = new StreamReader ( fajlutvonalbe ); StreamWriter iro = new StreamWriter ( fajlutvonalki ); string tar ; while (! olvaso . EndOfStream ) { tar = olvaso . ReadLine (); iro . WriteLine ( tar ); } olvaso . Close (); iro . Close (); } } Haszn\u00e1lat: string fajlutvonalbe = @\"C:\\4_Tarsalgo\\ajto.txt\" ; string fajlutvonalki = @\"C:\\4_Tarsalgo\\ajto2.txt\" ; // Mivel statikus, nem kell p\u00e9ld\u00e1nyos\u00edtani, az oszt\u00e1ly nev\u00e9n kereszt\u00fcl h\u00edvhat\u00f3 a `Masol` f\u00fcggv\u00e9ny: FileAtmasolo . Masol ( fajlutvonalbe , fajlutvonalki );","title":"2.1"},{"location":"Fajlkezeles/fajl-feladat-megoldasok/#22","text":"Itt az a c\u00e9l, hogy a l\u00e9trehoz\u00e1skor me tudjuk adni az \u00fatvonalakat: ehhez kell egy megfelel\u0151 kontruktor. Ez k\u00e9t tagv\u00e1ltoz\u00f3ban elt\u00e1rolja az \u00fatvonalakat. Az\u00e9rt, hogy a Masol f\u00fcggv\u00e9nyben, ami a t\u00e9nyleges m\u00e1sol\u00e1st v\u00e9gzi, el\u00e9rhet\u0151 legyen. class FileAtmasolo { string fajlutvonalbe ; string fajlutvonalki ; public FileAtmasolo ( string fajlutvonalbe , string fajlutvonalki ) { this . fajlutvonalbe = fajlutvonalbe ; this . fajlutvonalki = fajlutvonalki ; } public void Masol () { StreamReader olvaso = new StreamReader ( fajlutvonalbe ); StreamWriter iro = new StreamWriter ( fajlutvonalki ); string tar ; while (! olvaso . EndOfStream ) { tar = Console . ReadLine (); iro . WriteLine ( tar ); } olvaso . Close (); iro . Close (); } } Haszn\u00e1lat: string fajlutvonalbe = @\"C:\\4_Tarsalgo\\ajto.txt\" ; string fajlutvonalki = @\"C:\\4_Tarsalgo\\ajto2.txt\" ; // Mivel itt semmi nem statikus, l\u00e9tre kell hozni egy objektumot. // A l\u00e9tehoz\u00e1s sor\u00e1n \u00e1tadjuk a k\u00e9t \u00fatvonalat, ezt az objektum // tagv\u00e1ltoz\u00f3kban elt\u00e1rolja FileAtmasolo fileAtmasolo = new FileAtmasolo ( fajlutvonalbe , fajlutvonalki ); // Az objektumra megh\u00edvjuk a Masol() m\u0171veletet, ez v\u00e9gzi a m\u00e1sol\u00e1st // Itt m\u00e1r nem adjuk meg az \u00fatvonalakat, mert a fileAtmasolo objektum a // a tagv\u00e1ltoz\u00f3iban elt\u00e1rolta, a Masol m\u0171velet ezt el\u00e9ri. fileAtmasolo . Masol ();","title":"2.2"},{"location":"Fajlkezeles/fajl-feladatok/","text":"F\u00e1jkezel\u00e9s - Feladatok \u00b6 Feladat 1 \u00b6 \u00cdrj egy f\u00fcggv\u00e9nyt, mely egy sz\u00f6veges f\u00e1jl tartalm\u00e1t \u00e1tm\u00e1solja egy m\u00e1sik f\u00e1jlba. K\u00e9t param\u00e9tere van: \u00fatvonal a forr\u00e1sf\u00e1jlhoz, illetve \u00fatvonal a c\u00e9lf\u00e1jlhoz. Felteheted, hogy a f\u00e1jlok nem nagyok, vagyis haszn\u00e1lhatod a File.ReadAllText \u00e9s File.WriteAllText f\u00fcggv\u00e9nyeket. Feladat 2 \u00b6 Ugyanaz, mint az els\u0151 feladat, de ez a megold\u00e1s legyen takar\u00e9kos a mem\u00f3ri\u00e1val, m\u0171k\u00f6dj\u00f6n akkor is, ha \u00f3ri\u00e1si f\u00e1jl kell m\u00e1solni. Azt felteheted, hogy a f\u00e1jl sok sorb\u00f3l \u00e1ll (vagyis soronk\u00e9nt c\u00e9lszer\u0171 a f\u00e1jlt m\u00e1solni). A megold\u00e1sod k\u00e9tf\u00e9lek\u00e9ppen is k\u00e9sz\u00edtsd el: A k\u00f3dot k\u00fcl\u00f6n oszt\u00e1lyba tedd. A f\u00e1jlm\u00e1sol\u00e1st legyen a lehet\u0151 legegyszer\u0171bb haszn\u00e1lni, ne kelljeken hozz\u00e1 az oszt\u00e1lyb\u00f3l p\u00e9ld\u00e1nyt l\u00e9trehozni. A k\u00f3dot k\u00fcl\u00f6n oszt\u00e1lyba tedd. A objektum l\u00e9trehoz\u00e1skor lehessen megadni a forr\u00e1s \u00e9s c\u00e9l \u00fatvonalat, a m\u00e1sol\u00e1st pedig egy k\u00fcl\u00f6n Masol f\u00fcggv\u00e9ny hajtsa v\u00e9gre.","title":"Feladatok"},{"location":"Fajlkezeles/fajl-feladatok/#fajkezeles-feladatok","text":"","title":"F\u00e1jkezel\u00e9s - Feladatok"},{"location":"Fajlkezeles/fajl-feladatok/#feladat-1","text":"\u00cdrj egy f\u00fcggv\u00e9nyt, mely egy sz\u00f6veges f\u00e1jl tartalm\u00e1t \u00e1tm\u00e1solja egy m\u00e1sik f\u00e1jlba. K\u00e9t param\u00e9tere van: \u00fatvonal a forr\u00e1sf\u00e1jlhoz, illetve \u00fatvonal a c\u00e9lf\u00e1jlhoz. Felteheted, hogy a f\u00e1jlok nem nagyok, vagyis haszn\u00e1lhatod a File.ReadAllText \u00e9s File.WriteAllText f\u00fcggv\u00e9nyeket.","title":"Feladat 1"},{"location":"Fajlkezeles/fajl-feladatok/#feladat-2","text":"Ugyanaz, mint az els\u0151 feladat, de ez a megold\u00e1s legyen takar\u00e9kos a mem\u00f3ri\u00e1val, m\u0171k\u00f6dj\u00f6n akkor is, ha \u00f3ri\u00e1si f\u00e1jl kell m\u00e1solni. Azt felteheted, hogy a f\u00e1jl sok sorb\u00f3l \u00e1ll (vagyis soronk\u00e9nt c\u00e9lszer\u0171 a f\u00e1jlt m\u00e1solni). A megold\u00e1sod k\u00e9tf\u00e9lek\u00e9ppen is k\u00e9sz\u00edtsd el: A k\u00f3dot k\u00fcl\u00f6n oszt\u00e1lyba tedd. A f\u00e1jlm\u00e1sol\u00e1st legyen a lehet\u0151 legegyszer\u0171bb haszn\u00e1lni, ne kelljeken hozz\u00e1 az oszt\u00e1lyb\u00f3l p\u00e9ld\u00e1nyt l\u00e9trehozni. A k\u00f3dot k\u00fcl\u00f6n oszt\u00e1lyba tedd. A objektum l\u00e9trehoz\u00e1skor lehessen megadni a forr\u00e1s \u00e9s c\u00e9l \u00fatvonalat, a m\u00e1sol\u00e1st pedig egy k\u00fcl\u00f6n Masol f\u00fcggv\u00e9ny hajtsa v\u00e9gre.","title":"Feladat 2"},{"location":"Linq/Linq-attekinto/","text":"LINQ - \u00e1ttekint\u0151 \u00b6 A legfontosabbak parancsok, ',' ut\u00e1n az l\u00e1that\u00f3, mi az adott m\u0171veletn\u00e9l a param\u00e9ter, amit megkapunk: Where: sz\u0171r\u00e9s, elem Select: elemek lek\u00e9pez\u00e9se m\u00e1s elemre, elem OrderBy: sorrendez\u00e9s, elem GroupBy: csoportos\u00edt\u00e1s, csoport","title":"LINQ - \u00e1ttekint\u0151"},{"location":"Linq/Linq-attekinto/#linq-attekinto","text":"A legfontosabbak parancsok, ',' ut\u00e1n az l\u00e1that\u00f3, mi az adott m\u0171veletn\u00e9l a param\u00e9ter, amit megkapunk: Where: sz\u0171r\u00e9s, elem Select: elemek lek\u00e9pez\u00e9se m\u00e1s elemre, elem OrderBy: sorrendez\u00e9s, elem GroupBy: csoportos\u00edt\u00e1s, csoport","title":"LINQ - \u00e1ttekint\u0151"},{"location":"Linq/Linq-csoportositas-feladatok/","text":"LINQ - feladatok \u00b6 Ir\u00e1nyelvek: Pr\u00f3b\u00e1ld is ki a megold\u00e1sod! A feladat sz\u00f6veg\u00e9t \u00edrd a megold\u00e1sod f\u00f6l\u00e9 egy megjegyz\u00e9sben az el\u0151z\u0151 feladatot megold\u00e1s\u00e1t \u00edrd \u00e1t, ahogy haladsz, hanem legyen meg mind k\u00fcl\u00f6n! Kiindul\u00e1s \u00b6 Az al\u00e1bbi oszt\u00e1lyt haszn\u00e1ld a feladatok megold\u00e1sa sor\u00e1n: class Szinesz { public int Szulev ; public string Nev ; // Ne adjuk \u00e1t a sz\u00fcl. \u00e9v\u00e9t, mert m\u00e1r megvan tagv\u00e1ltoz\u00f3ban! public int EletkorSzamolo () { return DateTime . Now . Year - szulev ; } public Szinesz ( int szulev , string nev ) { this . szulev = szulev ; this . nev = nev ; } } Feladat 1 \u00b6 B\u0151v\u00edtsd ki a Szinesz oszt\u00e1lyt, minden sz\u00edn\u00e9sznek legyen egy \u00faj tulajdons\u00e1ga, egy string orszag, ahol sz\u00fcletett. Feladat 2 \u00b6 \u00cdrj egy f\u00fcggv\u00e9nyt (ha m\u00e9g nincs), amelyik el\u0151\u00e1ll\u00edt \u00e9s visszaad egy t\u00f6mbben 6 sz\u00edn\u00e9szt. Mindenkinek m\u00e1s a neve; 1 sz\u00edn\u00e9sz sz\u00fclessen 1975-ben, 2 1998-ban, 3 1980-ban; 1 sz\u00fclet\u00e9si helye Spanyolorsz\u00e1g, 2 USA, 3 Kanada. A t\u00f6mb\u00f6t inicializ\u00e1l\u00e1ssal hozd l\u00e9tre, ha lehet, vagyis az elemeket a l\u00e9trehoz\u00e1skor {} k\u00f6z\u00f6tt add meg, ahogy egyszer mutattam. Ezt a f\u00fcggv\u00e9nyt a k\u00e9s\u0151bb arra haszn\u00e1ljuk, hogy a LINQ lek\u00e9rdez\u00e9sekhez visszaadja a 6 tesztadatot. Feladat 3 \u00b6 a) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szeket egy t\u00f6mbben, akik 1990 ut\u00e1n sz\u00fclettek b) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szek neveit egy list\u00e1ban, akik 1990 ut\u00e1n sz\u00fclettek. c) \u00c1ll\u00edts el\u0151 egyetlen sztringet, mely vessz\u0151vel elv\u00e1lasztva azon sz\u00edn\u00e9szek sz\u00fclet\u00e9si \u00e9v\u00e9t tartalmazza (egyetlen sztringben), akik 1990 ut\u00e1n sz\u00fclettek. Feladat 4 - csoportos\u00edt\u00e1sok \u00b6 a) Egyszer\u0171 csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben a sz\u00fclet\u00e9si helyek szerepelnek (minden csoportra egyszer). Ezt k\u00f6vet\u0151en \u00edrd ki, vessz\u0151vel elv\u00e1lasztva ezen sz\u00fclet\u00e9si helyeket (ezt a ki\u00edr\u00e1st egyetlen sorban oldd meg)! Magyar\u00e1zat : Tfh van 6 sz\u00edn\u00e9sz, sz1, sz2, \u2026sz6. A szineszek.GroupBy(sz => sz.Orszag) ut\u00e1n, ha orsz\u00e1g szerint csoportos\u00edtunk, 3 sz\u00edn\u00e9sz csoport lesz: Csop1: Key: Spanyolorsz\u00e1g Elemek: [sz1] Csop2: Key: USA Elemek: [sz2, sz3] Csop3: Key: Kanada Elemek: [sz4, sz5, sz6] L\u00e9nyeges: minden csoporthoz egy kulcs tartozik (az orsz\u00e1g, mert eszerint csoportos\u00edtottunk), \u00e9s egy gy\u0171jtem\u00e9ny a csoportban lev\u0151 sz\u00edn\u00e9szekr\u0151l (mert sz\u00edn\u00e9szekre h\u00edvtuk a GroupBy-t) b) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: sz\u00edn\u00e9szek t\u00f6mbje \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben az egyes csoportokban lev\u0151 sz\u00edn\u00e9szek tal\u00e1lhat\u00f3k. Ezt pr\u00f3b\u00e1lt elk\u00e9pzelni magadt\u00f3l, \u00e9s csak ut\u00e1na olvass tov\u00e1bb, mert itt kicsit s\u00fagni fogok\u2026 Vagyis a t\u00f6mb els\u0151 eleme az els\u0151 csoport sz\u00edn\u00e9szeit tartalmazza egy t\u00f6mbben, a m\u00e1sodik eleme a m\u00e1sodik csoport szineszeit tartalmazza egy t\u00f6mbben, \u00e9s \u00edgy tov\u00e1bb. Vagyis a kimenet egy olyan t\u00f6mb lesz, melynek az elemi szin\u00e9sz t\u00f6mb\u00f6k. Nincs ebben semmi var\u00e1zslat: t\u00f6mb eleme b\u00e1rmi lehet, sz\u00e1m, string, oszt\u00e1ly, vagy ak\u00e1r mint eset\u00fcnkben is, m\u00e1sik t\u00f6mb is: Kb. ilyesmik\u00e9nt kell elk\u00e9pzelni: [ [sz1, sz2], [sz3, sz5, sz6], [sz7] ]. Ez olyan t\u00f6mb, melynek elemei t\u00f6mb\u00f6k, t\u00f6mb\u00f6k t\u00f6mbj\u00e9nek is szoktuk mondani. c) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: sz\u00edn\u00e9szek neve vessz\u0151vel elv\u00e1lasztva \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, mely elemei a csoportban lev\u0151 sz\u00edn\u00e9szek neveit tartalmazz\u00e1k, vessz\u0151vel elv\u00e1lasztva. El\u0151sz\u00f6r pr\u00f3b\u00e1ld ezt magadt\u00f3l elk\u00e9pzelni, csak ut\u00e1na olvasd tov\u00e1bb, s\u00fagok \u2026 A t\u00f6mb elemei itt most stringek, ilyesmi kimenetet v\u00e1runk, h\u00e1rom elem\u0171 string t\u00f6mb\u00f6t: [\"B\u00e9la, J\u00f3zsi\", \"Jani, Juli, G\u00e9za\", \"Misi\" ] d) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00b6 Hasonl\u00f3, mint a b) volt, vagyis most is sz\u00fclet\u00e9si hely szerint csoportos\u00edtunk. A b)-n\u00e9l, ha megn\u00e9zed, megvolt a kimenetben a h\u00e1rom csoport, mert a kimenet h\u00e1rom elem\u0171 t\u00f6mb volt, de nem tudtuk, melyik t\u00f6mb elem/csoport melyik orsz\u00e1ghoz tartozott. Pl. a kimeneti t\u00f6mb nulladik elem\u00e9ben volt k\u00e9t sz\u00edn\u00e9sz, de nem tudtuk megmondani, mely orsz\u00e1g csoportj\u00e1ba tartoztak . Ezt fontos lenne, hogy \u00e9rtsd, ha nem, besz\u00e9lj\u00fck meg! Mindenesetre ez \u00edgy sokszor nem szerencs\u00e9s. A c\u00e9l az, hogy a kimenetben azt is tudjuk, mely csoporthoz tartoznak az elemek (eset\u00fcnkben mely orsz\u00e1ghoz). Ezt t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet oldani. Picit gondolkozz azon, van-e \u00f6tleted\u2026 Meg lehet oldani KeyValuePair haszn\u00e1lat\u00e1val is, de az a k\u00f6vetkez\u0151 feladat lesz, most m\u00e9g hagyjuk. Els\u0151 k\u00f6rben egy \u201enyersebb\u201d megold\u00e1st n\u00e9z\u00fcnk, mert az sokszor \u00e1ltal\u00e1nosabb \u00e9s jobban haszn\u00e1lhat\u00f3, csak egy kicsit munk\u00e1sabb. A megold\u00e1s alapelve az, hogy bevezet\u00fcnk egy \u00faj oszt\u00e1ly, mely a kimenet egy csoportj\u00e1t (ami a t\u00f6mb egy eleme) fogja reprezent\u00e1lni. Mire is van sz\u00fcks\u00e9g minden egyes csoportn\u00e1l: az orsz\u00e1gn\u00e9vre, illetve hozz\u00e1 tartoz\u00f3 szin\u00e9szek t\u00f6mbj\u00e9re. vagyis egy ilyen oszt\u00e1lyt kell bevezetni: class SzineszCsoport { public string Orszag ; public Szinesz [] Szineszek ; < \u00cdrj m\u00e9g egy konstruktort , minek van k\u00e9t param\u00e9tere , az orsz\u00e1g \u00e9s a szineszek , erre sz\u00fcks\u00e9g lesz > } Ha ez megvan, akkor hasonl\u00f3an kell dolgozni, mint a b)-n\u00e9l, csak a Select-ben a csoportokat nem Szinesz t\u00f6mbre, hanem SzineszCsoport oszt\u00e1lyra kell lepezni, egy ilyet kell a new-val l\u00e9trehozni. Egy picit pr\u00f3b\u00e1lkozz, \u00e9s besz\u00e9lj\u00fck meg, ebben sokminden volt. e) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00e9letkora vessz\u0151vel elv\u00e1lasztva \u00b6 Ugyanaz, mint az el\u0151z\u0151, csak a kimenetben az orsz\u00e1gokhoz nem a szin\u00e9szek t\u00f6mbj\u00e9t, hanem a sz\u00edn\u00e9szek \u00e9letkor\u00e1nak vessz\u0151vel \u00f6sszef\u0171z\u00f6tt \u00e9vsz\u00e1m\u00e1t szeretn\u00e9nk l\u00e1tni. Tipp: vezess be egy SzineszCsoportEvekkel oszt\u00e1lyt, ebben a string Orszag mellett nem szinesz t\u00f6mb, hanem string evek legyen. f) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint, a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek, de most a be\u00e9p\u00edtett KeyValuePair-rel \u00b6 Hasonl\u00f3, mint a d) el\u0151z\u0151, csak itt nem akarunk \u00faj oszt\u00e1lyt (SzineszCsoport oszt\u00e1ly) bevezetni. De a c\u00e9lunk ugyanaz, vagyis legyen meg minden csoportra az orsz\u00e1g is, valamint a benne lev\u0151 sz\u00edn\u00e9szek is. A megold\u00e1s elve az, hogy nem vezet\u00fcnk be SzineszCsoport oszt\u00e1lyt, hanem helyette a be\u00e9p\u00edtett KeyValuePair-t haszn\u00e1ljuk. Minden csoportn\u00e1l a kulcs (vagyis a Key) az orsz\u00e1g, hiszen eszerint csoportos\u00edtunk, a Value, a kulcshoz tartoz\u00f3 \u00e9rt\u00e9k pedig \u2026 ezt pr\u00f3b\u00e1ld kital\u00e1lni, hogy \u00e9rdemes. g) Csoportos\u00edt\u00e1s sz\u00edn\u00e9szn\u00e9v kezd\u0151bet\u0171 alapj\u00e1n, sorrendezve \u00b6 Csoportos\u00edtsd a sz\u00edn\u00e9szeket aszerint, hogy milyen bet\u0171vel kezd\u0151dik a nev\u00fck. KeyValuePair-rel dolgozz. Az egyes csoportokban ne a csoportban lev\u0151 sz\u00edn\u00e9szeket, hanem a csoportban lev\u0151 sz\u00edn\u00e9szek neveit c\u00edmeit t\u00e1rold t\u00f6mbben. A kimenet legyen sorrendezve a n\u00e9v kezd\u0151bet\u0171 alapj\u00e1n!","title":"LINQ - feladatok"},{"location":"Linq/Linq-csoportositas-feladatok/#linq-feladatok","text":"Ir\u00e1nyelvek: Pr\u00f3b\u00e1ld is ki a megold\u00e1sod! A feladat sz\u00f6veg\u00e9t \u00edrd a megold\u00e1sod f\u00f6l\u00e9 egy megjegyz\u00e9sben az el\u0151z\u0151 feladatot megold\u00e1s\u00e1t \u00edrd \u00e1t, ahogy haladsz, hanem legyen meg mind k\u00fcl\u00f6n!","title":"LINQ - feladatok"},{"location":"Linq/Linq-csoportositas-feladatok/#kiindulas","text":"Az al\u00e1bbi oszt\u00e1lyt haszn\u00e1ld a feladatok megold\u00e1sa sor\u00e1n: class Szinesz { public int Szulev ; public string Nev ; // Ne adjuk \u00e1t a sz\u00fcl. \u00e9v\u00e9t, mert m\u00e1r megvan tagv\u00e1ltoz\u00f3ban! public int EletkorSzamolo () { return DateTime . Now . Year - szulev ; } public Szinesz ( int szulev , string nev ) { this . szulev = szulev ; this . nev = nev ; } }","title":"Kiindul\u00e1s"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-1","text":"B\u0151v\u00edtsd ki a Szinesz oszt\u00e1lyt, minden sz\u00edn\u00e9sznek legyen egy \u00faj tulajdons\u00e1ga, egy string orszag, ahol sz\u00fcletett.","title":"Feladat 1"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-2","text":"\u00cdrj egy f\u00fcggv\u00e9nyt (ha m\u00e9g nincs), amelyik el\u0151\u00e1ll\u00edt \u00e9s visszaad egy t\u00f6mbben 6 sz\u00edn\u00e9szt. Mindenkinek m\u00e1s a neve; 1 sz\u00edn\u00e9sz sz\u00fclessen 1975-ben, 2 1998-ban, 3 1980-ban; 1 sz\u00fclet\u00e9si helye Spanyolorsz\u00e1g, 2 USA, 3 Kanada. A t\u00f6mb\u00f6t inicializ\u00e1l\u00e1ssal hozd l\u00e9tre, ha lehet, vagyis az elemeket a l\u00e9trehoz\u00e1skor {} k\u00f6z\u00f6tt add meg, ahogy egyszer mutattam. Ezt a f\u00fcggv\u00e9nyt a k\u00e9s\u0151bb arra haszn\u00e1ljuk, hogy a LINQ lek\u00e9rdez\u00e9sekhez visszaadja a 6 tesztadatot.","title":"Feladat 2"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-3","text":"a) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szeket egy t\u00f6mbben, akik 1990 ut\u00e1n sz\u00fclettek b) \u00cdrj egy LINQ kifejez\u00e9st, ami visszaadja azon sz\u00edn\u00e9szek neveit egy list\u00e1ban, akik 1990 ut\u00e1n sz\u00fclettek. c) \u00c1ll\u00edts el\u0151 egyetlen sztringet, mely vessz\u0151vel elv\u00e1lasztva azon sz\u00edn\u00e9szek sz\u00fclet\u00e9si \u00e9v\u00e9t tartalmazza (egyetlen sztringben), akik 1990 ut\u00e1n sz\u00fclettek.","title":"Feladat 3"},{"location":"Linq/Linq-csoportositas-feladatok/#feladat-4-csoportositasok","text":"","title":"Feladat 4 - csoportos\u00edt\u00e1sok"},{"location":"Linq/Linq-csoportositas-feladatok/#a-egyszeru-csoportositas-szuletesi-hely-szerint","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben a sz\u00fclet\u00e9si helyek szerepelnek (minden csoportra egyszer). Ezt k\u00f6vet\u0151en \u00edrd ki, vessz\u0151vel elv\u00e1lasztva ezen sz\u00fclet\u00e9si helyeket (ezt a ki\u00edr\u00e1st egyetlen sorban oldd meg)! Magyar\u00e1zat : Tfh van 6 sz\u00edn\u00e9sz, sz1, sz2, \u2026sz6. A szineszek.GroupBy(sz => sz.Orszag) ut\u00e1n, ha orsz\u00e1g szerint csoportos\u00edtunk, 3 sz\u00edn\u00e9sz csoport lesz: Csop1: Key: Spanyolorsz\u00e1g Elemek: [sz1] Csop2: Key: USA Elemek: [sz2, sz3] Csop3: Key: Kanada Elemek: [sz4, sz5, sz6] L\u00e9nyeges: minden csoporthoz egy kulcs tartozik (az orsz\u00e1g, mert eszerint csoportos\u00edtottunk), \u00e9s egy gy\u0171jtem\u00e9ny a csoportban lev\u0151 sz\u00edn\u00e9szekr\u0151l (mert sz\u00edn\u00e9szekre h\u00edvtuk a GroupBy-t)","title":"a) Egyszer\u0171 csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint"},{"location":"Linq/Linq-csoportositas-feladatok/#b-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-szineszek-tombje","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, melyben az egyes csoportokban lev\u0151 sz\u00edn\u00e9szek tal\u00e1lhat\u00f3k. Ezt pr\u00f3b\u00e1lt elk\u00e9pzelni magadt\u00f3l, \u00e9s csak ut\u00e1na olvass tov\u00e1bb, mert itt kicsit s\u00fagni fogok\u2026 Vagyis a t\u00f6mb els\u0151 eleme az els\u0151 csoport sz\u00edn\u00e9szeit tartalmazza egy t\u00f6mbben, a m\u00e1sodik eleme a m\u00e1sodik csoport szineszeit tartalmazza egy t\u00f6mbben, \u00e9s \u00edgy tov\u00e1bb. Vagyis a kimenet egy olyan t\u00f6mb lesz, melynek az elemi szin\u00e9sz t\u00f6mb\u00f6k. Nincs ebben semmi var\u00e1zslat: t\u00f6mb eleme b\u00e1rmi lehet, sz\u00e1m, string, oszt\u00e1ly, vagy ak\u00e1r mint eset\u00fcnkben is, m\u00e1sik t\u00f6mb is: Kb. ilyesmik\u00e9nt kell elk\u00e9pzelni: [ [sz1, sz2], [sz3, sz5, sz6], [sz7] ]. Ez olyan t\u00f6mb, melynek elemei t\u00f6mb\u00f6k, t\u00f6mb\u00f6k t\u00f6mbj\u00e9nek is szoktuk mondani.","title":"b) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: sz\u00edn\u00e9szek t\u00f6mbje"},{"location":"Linq/Linq-csoportositas-feladatok/#c-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-szineszek-neve-vesszovel-elvalasztva","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket sz\u00fclet\u00e9si hely szerint, \u00e9s \u00e1ll\u00edts el\u0151 egy t\u00f6mb\u00f6t, mely elemei a csoportban lev\u0151 sz\u00edn\u00e9szek neveit tartalmazz\u00e1k, vessz\u0151vel elv\u00e1lasztva. El\u0151sz\u00f6r pr\u00f3b\u00e1ld ezt magadt\u00f3l elk\u00e9pzelni, csak ut\u00e1na olvasd tov\u00e1bb, s\u00fagok \u2026 A t\u00f6mb elemei itt most stringek, ilyesmi kimenetet v\u00e1runk, h\u00e1rom elem\u0171 string t\u00f6mb\u00f6t: [\"B\u00e9la, J\u00f3zsi\", \"Jani, Juli, G\u00e9za\", \"Misi\" ]","title":"c) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: sz\u00edn\u00e9szek neve vessz\u0151vel elv\u00e1lasztva"},{"location":"Linq/Linq-csoportositas-feladatok/#d-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek","text":"Hasonl\u00f3, mint a b) volt, vagyis most is sz\u00fclet\u00e9si hely szerint csoportos\u00edtunk. A b)-n\u00e9l, ha megn\u00e9zed, megvolt a kimenetben a h\u00e1rom csoport, mert a kimenet h\u00e1rom elem\u0171 t\u00f6mb volt, de nem tudtuk, melyik t\u00f6mb elem/csoport melyik orsz\u00e1ghoz tartozott. Pl. a kimeneti t\u00f6mb nulladik elem\u00e9ben volt k\u00e9t sz\u00edn\u00e9sz, de nem tudtuk megmondani, mely orsz\u00e1g csoportj\u00e1ba tartoztak . Ezt fontos lenne, hogy \u00e9rtsd, ha nem, besz\u00e9lj\u00fck meg! Mindenesetre ez \u00edgy sokszor nem szerencs\u00e9s. A c\u00e9l az, hogy a kimenetben azt is tudjuk, mely csoporthoz tartoznak az elemek (eset\u00fcnkben mely orsz\u00e1ghoz). Ezt t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet oldani. Picit gondolkozz azon, van-e \u00f6tleted\u2026 Meg lehet oldani KeyValuePair haszn\u00e1lat\u00e1val is, de az a k\u00f6vetkez\u0151 feladat lesz, most m\u00e9g hagyjuk. Els\u0151 k\u00f6rben egy \u201enyersebb\u201d megold\u00e1st n\u00e9z\u00fcnk, mert az sokszor \u00e1ltal\u00e1nosabb \u00e9s jobban haszn\u00e1lhat\u00f3, csak egy kicsit munk\u00e1sabb. A megold\u00e1s alapelve az, hogy bevezet\u00fcnk egy \u00faj oszt\u00e1ly, mely a kimenet egy csoportj\u00e1t (ami a t\u00f6mb egy eleme) fogja reprezent\u00e1lni. Mire is van sz\u00fcks\u00e9g minden egyes csoportn\u00e1l: az orsz\u00e1gn\u00e9vre, illetve hozz\u00e1 tartoz\u00f3 szin\u00e9szek t\u00f6mbj\u00e9re. vagyis egy ilyen oszt\u00e1lyt kell bevezetni: class SzineszCsoport { public string Orszag ; public Szinesz [] Szineszek ; < \u00cdrj m\u00e9g egy konstruktort , minek van k\u00e9t param\u00e9tere , az orsz\u00e1g \u00e9s a szineszek , erre sz\u00fcks\u00e9g lesz > } Ha ez megvan, akkor hasonl\u00f3an kell dolgozni, mint a b)-n\u00e9l, csak a Select-ben a csoportokat nem Szinesz t\u00f6mbre, hanem SzineszCsoport oszt\u00e1lyra kell lepezni, egy ilyet kell a new-val l\u00e9trehozni. Egy picit pr\u00f3b\u00e1lkozz, \u00e9s besz\u00e9lj\u00fck meg, ebben sokminden volt.","title":"d) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek"},{"location":"Linq/Linq-csoportositas-feladatok/#e-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek-eletkora-vesszovel-elvalasztva","text":"Ugyanaz, mint az el\u0151z\u0151, csak a kimenetben az orsz\u00e1gokhoz nem a szin\u00e9szek t\u00f6mbj\u00e9t, hanem a sz\u00edn\u00e9szek \u00e9letkor\u00e1nak vessz\u0151vel \u00f6sszef\u0171z\u00f6tt \u00e9vsz\u00e1m\u00e1t szeretn\u00e9nk l\u00e1tni. Tipp: vezess be egy SzineszCsoportEvekkel oszt\u00e1lyt, ebben a string Orszag mellett nem szinesz t\u00f6mb, hanem string evek legyen.","title":"e) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek \u00e9letkora vessz\u0151vel elv\u00e1lasztva"},{"location":"Linq/Linq-csoportositas-feladatok/#f-csoportositas-szuletesi-hely-szerint-a-kimenet-minden-csoportra-orszag-csoport-kulcs-es-a-benne-levo-szineszek-de-most-a-beepitett-keyvaluepair-rel","text":"Hasonl\u00f3, mint a d) el\u0151z\u0151, csak itt nem akarunk \u00faj oszt\u00e1lyt (SzineszCsoport oszt\u00e1ly) bevezetni. De a c\u00e9lunk ugyanaz, vagyis legyen meg minden csoportra az orsz\u00e1g is, valamint a benne lev\u0151 sz\u00edn\u00e9szek is. A megold\u00e1s elve az, hogy nem vezet\u00fcnk be SzineszCsoport oszt\u00e1lyt, hanem helyette a be\u00e9p\u00edtett KeyValuePair-t haszn\u00e1ljuk. Minden csoportn\u00e1l a kulcs (vagyis a Key) az orsz\u00e1g, hiszen eszerint csoportos\u00edtunk, a Value, a kulcshoz tartoz\u00f3 \u00e9rt\u00e9k pedig \u2026 ezt pr\u00f3b\u00e1ld kital\u00e1lni, hogy \u00e9rdemes.","title":"f) Csoportos\u00edt\u00e1s sz\u00fclet\u00e9si hely szerint,  a kimenet minden csoportra: orsz\u00e1g (csoport kulcs) \u00e9s a benne lev\u0151 sz\u00edn\u00e9szek, de most a be\u00e9p\u00edtett KeyValuePair-rel"},{"location":"Linq/Linq-csoportositas-feladatok/#g-csoportositas-szinesznev-kezdobetu-alapjan-sorrendezve","text":"Csoportos\u00edtsd a sz\u00edn\u00e9szeket aszerint, hogy milyen bet\u0171vel kezd\u0151dik a nev\u00fck. KeyValuePair-rel dolgozz. Az egyes csoportokban ne a csoportban lev\u0151 sz\u00edn\u00e9szeket, hanem a csoportban lev\u0151 sz\u00edn\u00e9szek neveit c\u00edmeit t\u00e1rold t\u00f6mbben. A kimenet legyen sorrendezve a n\u00e9v kezd\u0151bet\u0171 alapj\u00e1n!","title":"g) Csoportos\u00edt\u00e1s sz\u00edn\u00e9szn\u00e9v kezd\u0151bet\u0171 alapj\u00e1n, sorrendezve"},{"location":"Linq/Linq-kiskerdesek/","text":"LINQ - kisk\u00e9rd\u00e9sek \u00b6 Van egy gy\u0171jtem\u00e9nyed (lehet t\u00f6mb, lista, stb.), ebb\u0151l egy pontosan ilyen elemsz\u00e1m\u00fa, de m\u00e1s gy\u0171jtem\u00e9nyt kell k\u00e9sz\u00edteni, melyben minden elem az els\u0151 gy\u0171jtem\u00e9ny adott eleme alapj\u00e1n \u00e1ll\u00edthat\u00f3 el\u0151. Mit haszn\u00e1ln\u00e1l hozz\u00e1? Egy sz\u00f3ban v\u00e1laszolj! Select","title":"LINQ - kisk\u00e9rd\u00e9sek"},{"location":"Linq/Linq-kiskerdesek/#linq-kiskerdesek","text":"Van egy gy\u0171jtem\u00e9nyed (lehet t\u00f6mb, lista, stb.), ebb\u0151l egy pontosan ilyen elemsz\u00e1m\u00fa, de m\u00e1s gy\u0171jtem\u00e9nyt kell k\u00e9sz\u00edteni, melyben minden elem az els\u0151 gy\u0171jtem\u00e9ny adott eleme alapj\u00e1n \u00e1ll\u00edthat\u00f3 el\u0151. Mit haszn\u00e1ln\u00e1l hozz\u00e1? Egy sz\u00f3ban v\u00e1laszolj! Select","title":"LINQ - kisk\u00e9rd\u00e9sek"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/","text":"Inicializ\u00e1l\u00e1s alapok \u00b6 Objektumok inicializ\u00e1l\u00e1sa (object initilizer) \u00b6 R\u00e9szletes angol le\u00edr\u00e1s: Object initilizers Alepelve: a az objektum new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok \u00e9rt\u00e9k\u00e9t . Ezzel azt nyerj\u00fck, hogy ha nincs az oszt\u00e1lynak ezen tagokat inizializ\u00e1l\u00f3 konstruktora, akkor is kezd\u0151\u00e9rt\u00e9ket tudunk adni ezen tagoknak a l\u00e9trehoz\u00e1skor. A p\u00e9ld\u00e1kban ezen oszt\u00e1lyokat haszn\u00e1ljuk: public class Cim { public string Varos ; public string Utca ; } // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Cim Cim ; // A fenti Cim oszt\u00e1ly objektuma !!! } P\u00e9ld\u00e1k // Pont \u00fagy hozzuk l\u00e9tre a new-val az objektumot, mint eddig // csak folytatjuk a sort {}-lel, \u00e9s k\u00f6zte megadjuk a tagok \u00e9rt\u00e9k\u00e9t Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" } ; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" } ; // Ugyanez, de t\u00f6bb sorba t\u00f6rve (\u00e1ltal\u00e1ban \u00edgy szoktuk) Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" }; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" , } ; // A Szemely oszt\u00e1lynak van Cim tagja, ezt is tudjuk be\u00e1gyazott m\u00f3don inicializ\u00e1lni: ``` csharp Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = cim1 ; // a cim1-et m\u00e1r fent l\u00e9trehoztuk! } // Lehet\u0151s\u00e9g van a be\u00e1gyazott objektumot (Cim) helyben inicializ\u00e1lni // Nagyon gyakran \u00edgy dolgozunk! Ezt tetsz\u0151leges m\u00e9lys\u00e9gben lehets\u00e9ges, // itt egyszint\u0171 a m\u00e9lys\u00e9g. Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = new Cim () { Varos = \"Miskolc\" , Utca = \"Szeretet\" , }; } \u00d6sszefoglal\u00f3 \u00b6 Arra, hogy objektumokat adott \u00e1llapottal, tagv\u00e1ltoz\u00f3 kezd\u0151\u00e9rt\u00e9kekkel hozzunk l\u00e9tre, k\u00e9t lehet\u0151s\u00e9g\u00fcnk is van: Konstruktort \u00edrunk \u00e9s abban \u00e1ll\u00edjuk be a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t. Ez a klasszikus, rugalmas, minden k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt j\u00f3l haszn\u00e1lhat\u00f3 megold\u00e1s. Az itt ismertetett objektum iniciliz\u00e1l\u00e1st haszn\u00e1ljuk. Ez egyszer\u0171bb tud lennni (nem kell konstruktort \u00edrni), de korl\u00e1tozottabban haszn\u00e1lhat\u00f3: Csak akkor m\u0171k\u00f6dik, ha a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok publikusak, amit viszont a gyakorlatban sokszor elker\u00fcl\u00fcnk, \u00e9s ink\u00e1bb v\u00e9dett tagokkal dolgozunk (az\u00e9rt, hogy az objektumot ne lehessen inkonzisztens\u00e9 tenni) M\u00edg a konstruktorba tetsz\u0151leges inicializ\u00e1l\u00f3 k\u00f3dot tudunk tenni (pl. valid\u00e1lni, m\u00e1s f\u00fcggv\u00e9nyeket h\u00edvni, stb.), itt csak a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t tudjuk megadni. A kontruktorral jobban ki tudjuk k\u00e9nyszer\u00edteni a konzisztenci\u00e1t. Pl. egy K\u00f6r osz\u00e1ly eset\u00e9ben el tudjuk v\u00e1rni, hogy l\u00e9trehoz\u00e1skor k\u00f6telez\u0151 legyen megadni a sugarat, s\u0151t, ha a l\u00e9trehoz\u00f3 a new param\u00e9ter\u00e9ben negat\u00edv \u00e9rt\u00e9ket ad meg, akkor ezt tudjuk ellen\u0151rizni \u00e9s hib\u00e1val (kiv\u00e9tellel) jelezni. Megjegyz\u00e9s \u00b6 A LINQ Select haszn\u00e1latakor is j\u00f3l tud j\u00f6nni az objektum inicializ\u00e1l\u00e1s, amikor a => ut\u00e1n \u00faj, de m\u00e1r adott m\u00f3don inicializ\u00e1lt objektumokat kell l\u00e9trehozni, \u00e9s az oszt\u00e1lyban nincs ehhez konstruktor. Pl.: // Ezek csak egyszer\u0171 stringek! string [] varosNevek = new string [] { \"Budapest\" , \"Szeged\" , \"Miskolc\" }; // Minden v\u00e1rosn\u00e9vhez gy\u00e1rtsunk le egy a v\u00e1rosnak megfelel\u0151 c\u00edmet, az utca legyen \"ismeretlen\". Cim [] cimek = varosNevek . Select ( varosnev => new Cim () { Varos = varosnev , Utca = \"ismeretlen\" } ); Gy\u0171jtem\u00e9nyek inicializ\u00e1l\u00e1sa \u00b6 R\u00e9szletes angol le\u00edr\u00e1s: Collection initializers Alepelve: a t\u00f6mb, lista, stb. new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni az elemeket . Int t\u00f6mb p\u00e9lda: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; Int lista p\u00e9lda: List < int > szamok = new List < int > { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; A gy\u0171jtem\u00e9ny elemei lehetnek objektumok is: // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Szemely () { } public Szemely ( string nev , int kor ) { this . Nev = nev ; this . Kor = kor ; } } ... // Minden egy sorban Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // \u00c1ltal\u00e1ban t\u00f6bb sorba t\u00f6rve szoktuk \u00edrni, jobban \u00e1tl\u00e1that\u00f3 Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // Az egyes elemeket objektum inicializ\u00e1l\u00e1ssal is l\u00e9tre lehet hozni (kombin\u00e1ljuk a // gy\u0171jtem\u00e9ny \u00e9s objektum inicializ\u00e1l\u00e1st) Szemely [] szemelyek = new Szemely [] { new Szemely () { Nev = \"Joe\" , Kor = 20 }, new Szemely () { Nev = \"Jill\" , Kor = 23 } };","title":"Inicializ\u00e1l\u00e1s alapok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#inicializalas-alapok","text":"","title":"Inicializ\u00e1l\u00e1s alapok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#objektumok-inicializalasa-object-initilizer","text":"R\u00e9szletes angol le\u00edr\u00e1s: Object initilizers Alepelve: a az objektum new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok \u00e9rt\u00e9k\u00e9t . Ezzel azt nyerj\u00fck, hogy ha nincs az oszt\u00e1lynak ezen tagokat inizializ\u00e1l\u00f3 konstruktora, akkor is kezd\u0151\u00e9rt\u00e9ket tudunk adni ezen tagoknak a l\u00e9trehoz\u00e1skor. A p\u00e9ld\u00e1kban ezen oszt\u00e1lyokat haszn\u00e1ljuk: public class Cim { public string Varos ; public string Utca ; } // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Cim Cim ; // A fenti Cim oszt\u00e1ly objektuma !!! } P\u00e9ld\u00e1k // Pont \u00fagy hozzuk l\u00e9tre a new-val az objektumot, mint eddig // csak folytatjuk a sort {}-lel, \u00e9s k\u00f6zte megadjuk a tagok \u00e9rt\u00e9k\u00e9t Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" } ; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" } ; // Ugyanez, de t\u00f6bb sorba t\u00f6rve (\u00e1ltal\u00e1ban \u00edgy szoktuk) Cim cim1 = new Cim () { Varos = \"Budapest\" , Utca = \"Di\u00f3fa\" }; Cim cim2 = new Cim () { Varos = \"Szeged\" , Utca = \"Tiszafa\" , } ; // A Szemely oszt\u00e1lynak van Cim tagja, ezt is tudjuk be\u00e1gyazott m\u00f3don inicializ\u00e1lni: ``` csharp Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = cim1 ; // a cim1-et m\u00e1r fent l\u00e9trehoztuk! } // Lehet\u0151s\u00e9g van a be\u00e1gyazott objektumot (Cim) helyben inicializ\u00e1lni // Nagyon gyakran \u00edgy dolgozunk! Ezt tetsz\u0151leges m\u00e9lys\u00e9gben lehets\u00e9ges, // itt egyszint\u0171 a m\u00e9lys\u00e9g. Szemely sz1 = new Szemely () { Nev = \"Joe\" , Kor = 12 Cim = new Cim () { Varos = \"Miskolc\" , Utca = \"Szeretet\" , }; }","title":"Objektumok inicializ\u00e1l\u00e1sa (object initilizer)"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#osszefoglalo","text":"Arra, hogy objektumokat adott \u00e1llapottal, tagv\u00e1ltoz\u00f3 kezd\u0151\u00e9rt\u00e9kekkel hozzunk l\u00e9tre, k\u00e9t lehet\u0151s\u00e9g\u00fcnk is van: Konstruktort \u00edrunk \u00e9s abban \u00e1ll\u00edjuk be a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t. Ez a klasszikus, rugalmas, minden k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt j\u00f3l haszn\u00e1lhat\u00f3 megold\u00e1s. Az itt ismertetett objektum iniciliz\u00e1l\u00e1st haszn\u00e1ljuk. Ez egyszer\u0171bb tud lennni (nem kell konstruktort \u00edrni), de korl\u00e1tozottabban haszn\u00e1lhat\u00f3: Csak akkor m\u0171k\u00f6dik, ha a tagv\u00e1ltoz\u00f3k/tulajdons\u00e1gok publikusak, amit viszont a gyakorlatban sokszor elker\u00fcl\u00fcnk, \u00e9s ink\u00e1bb v\u00e9dett tagokkal dolgozunk (az\u00e9rt, hogy az objektumot ne lehessen inkonzisztens\u00e9 tenni) M\u00edg a konstruktorba tetsz\u0151leges inicializ\u00e1l\u00f3 k\u00f3dot tudunk tenni (pl. valid\u00e1lni, m\u00e1s f\u00fcggv\u00e9nyeket h\u00edvni, stb.), itt csak a tagv\u00e1ltoz\u00f3k kezd\u0151\u00e9rt\u00e9k\u00e9t tudjuk megadni. A kontruktorral jobban ki tudjuk k\u00e9nyszer\u00edteni a konzisztenci\u00e1t. Pl. egy K\u00f6r osz\u00e1ly eset\u00e9ben el tudjuk v\u00e1rni, hogy l\u00e9trehoz\u00e1skor k\u00f6telez\u0151 legyen megadni a sugarat, s\u0151t, ha a l\u00e9trehoz\u00f3 a new param\u00e9ter\u00e9ben negat\u00edv \u00e9rt\u00e9ket ad meg, akkor ezt tudjuk ellen\u0151rizni \u00e9s hib\u00e1val (kiv\u00e9tellel) jelezni.","title":"\u00d6sszefoglal\u00f3"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#megjegyzes","text":"A LINQ Select haszn\u00e1latakor is j\u00f3l tud j\u00f6nni az objektum inicializ\u00e1l\u00e1s, amikor a => ut\u00e1n \u00faj, de m\u00e1r adott m\u00f3don inicializ\u00e1lt objektumokat kell l\u00e9trehozni, \u00e9s az oszt\u00e1lyban nincs ehhez konstruktor. Pl.: // Ezek csak egyszer\u0171 stringek! string [] varosNevek = new string [] { \"Budapest\" , \"Szeged\" , \"Miskolc\" }; // Minden v\u00e1rosn\u00e9vhez gy\u00e1rtsunk le egy a v\u00e1rosnak megfelel\u0151 c\u00edmet, az utca legyen \"ismeretlen\". Cim [] cimek = varosNevek . Select ( varosnev => new Cim () { Varos = varosnev , Utca = \"ismeretlen\" } );","title":"Megjegyz\u00e9s"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-alapok/#gyujtemenyek-inicializalasa","text":"R\u00e9szletes angol le\u00edr\u00e1s: Collection initializers Alepelve: a t\u00f6mb, lista, stb. new-val t\u00f6rt\u00e9n\u0151 l\u00e9trehoz\u00e1sakor { } k\u00f6z\u00f6tt kell megadni az elemeket . Int t\u00f6mb p\u00e9lda: int [] szamok = new int [] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; Int lista p\u00e9lda: List < int > szamok = new List < int > { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; A gy\u0171jtem\u00e9ny elemei lehetnek objektumok is: // Ebb\u0151l fogunk gy\u0171jtem\u00e9nyeket l\u00e9trehozni public class Szemely { public string Nev ; public int Kor ; public Szemely () { } public Szemely ( string nev , int kor ) { this . Nev = nev ; this . Kor = kor ; } } ... // Minden egy sorban Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // \u00c1ltal\u00e1ban t\u00f6bb sorba t\u00f6rve szoktuk \u00edrni, jobban \u00e1tl\u00e1that\u00f3 Szemely [] szemelyek = new Szemely [] { new Szemely ( \"Joe\" , 20 ), new Szemely ( \"Jill\" , 23 ) }; // Az egyes elemeket objektum inicializ\u00e1l\u00e1ssal is l\u00e9tre lehet hozni (kombin\u00e1ljuk a // gy\u0171jtem\u00e9ny \u00e9s objektum inicializ\u00e1l\u00e1st) Szemely [] szemelyek = new Szemely [] { new Szemely () { Nev = \"Joe\" , Kor = 20 }, new Szemely () { Nev = \"Jill\" , Kor = 23 } };","title":"Gy\u0171jtem\u00e9nyek inicializ\u00e1l\u00e1sa"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/","text":"Inicializ\u00e1l\u00e1s feladatok \u00b6 Feladat 1 \u00b6 \u00cdrj egy Kerek (mint j\u00e1rm\u0171ker\u00e9k) oszt\u00e1lyt. K\u00e9t tulajdons\u00e1ga van: int Atmero , double Nyomas . \u00cdrj egy Auto oszt\u00e1ly, melynek van n\u00e9gy kereke ( Kerek t\u00f6mb) \u00e9s sz\u00edne ( string Szin ). Hozz l\u00e9tre egy Auto objektumot egyetlen inicializ\u00e1l\u00f3 kifejez\u00e9ssel (mind a n\u00e9gy kerek\u00e9vel egyszerre). Az aut\u00f3 sz\u00edne k\u00e9k, van n\u00e9gy kereke. A kerekek \u00e1tm\u00e9r\u0151je legyen ugyanaz, de a nyom\u00e1s legyen mindn\u00e9l kicsit m\u00e1s. Feladat 2 \u00b6 Adott az al\u00e1bbi k\u00f3d: public class Szampar { public int Szam1 ; public int Szam2 ; } // A Main f\u00fcggv\u00e9nyben: Szampar [] szamparok = new Szampar [] { new Szampar () { Szam1 = 2 , Szam2 = 3 }, new Szampar () { Szam1 = 4 , Szam2 = 8 }, new Szampar () { Szam1 = 10 , Szam2 = 20 } }; \u00cdrj egy Teglalap osz\u00e1lyt, melynek van Szelesseg \u00e9s Magassag tagja. Konstruktort ne \u00edrj hozz\u00e1. A Main f\u00fcggv\u00e9nyben a fenti szamparok mindegyike alapj\u00e1n \u00e1ll\u00edts el\u0151 egy t\u00e9galalapot egy Tegalap list\u00e1ban, minden t\u00e9glalap eset\u00e9n a szeless\u00e9g az adott sz\u00e1mp\u00e1r els\u0151 tagj\u00e1nak dupl\u00e1ja, a magass\u00e1g pedig az adott sz\u00e1mp\u00e1r m\u00e1sodik tagj\u00e1nak n\u00e9gyzete legyen. A megold\u00e1sodban ne haszn\u00e1lj semmilyen ciklust! (gondolj arra, hogy egy sz\u00e1mp\u00e1r gy\u0171jtem\u00e9nyt kell lek\u00e9pezni egy m\u00e1sik gy\u0171jtem\u00e9nyre, mit is szoktunk erre haszn\u00e1lni).","title":"Inicializ\u00e1l\u00e1s feladatok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/#inicializalas-feladatok","text":"","title":"Inicializ\u00e1l\u00e1s feladatok"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/#feladat-1","text":"\u00cdrj egy Kerek (mint j\u00e1rm\u0171ker\u00e9k) oszt\u00e1lyt. K\u00e9t tulajdons\u00e1ga van: int Atmero , double Nyomas . \u00cdrj egy Auto oszt\u00e1ly, melynek van n\u00e9gy kereke ( Kerek t\u00f6mb) \u00e9s sz\u00edne ( string Szin ). Hozz l\u00e9tre egy Auto objektumot egyetlen inicializ\u00e1l\u00f3 kifejez\u00e9ssel (mind a n\u00e9gy kerek\u00e9vel egyszerre). Az aut\u00f3 sz\u00edne k\u00e9k, van n\u00e9gy kereke. A kerekek \u00e1tm\u00e9r\u0151je legyen ugyanaz, de a nyom\u00e1s legyen mindn\u00e9l kicsit m\u00e1s.","title":"Feladat 1"},{"location":"ObjektumokLetrehozasa/Inicializalas/inicializalas-feladatok/#feladat-2","text":"Adott az al\u00e1bbi k\u00f3d: public class Szampar { public int Szam1 ; public int Szam2 ; } // A Main f\u00fcggv\u00e9nyben: Szampar [] szamparok = new Szampar [] { new Szampar () { Szam1 = 2 , Szam2 = 3 }, new Szampar () { Szam1 = 4 , Szam2 = 8 }, new Szampar () { Szam1 = 10 , Szam2 = 20 } }; \u00cdrj egy Teglalap osz\u00e1lyt, melynek van Szelesseg \u00e9s Magassag tagja. Konstruktort ne \u00edrj hozz\u00e1. A Main f\u00fcggv\u00e9nyben a fenti szamparok mindegyike alapj\u00e1n \u00e1ll\u00edts el\u0151 egy t\u00e9galalapot egy Tegalap list\u00e1ban, minden t\u00e9glalap eset\u00e9n a szeless\u00e9g az adott sz\u00e1mp\u00e1r els\u0151 tagj\u00e1nak dupl\u00e1ja, a magass\u00e1g pedig az adott sz\u00e1mp\u00e1r m\u00e1sodik tagj\u00e1nak n\u00e9gyzete legyen. A megold\u00e1sodban ne haszn\u00e1lj semmilyen ciklust! (gondolj arra, hogy egy sz\u00e1mp\u00e1r gy\u0171jtem\u00e9nyt kell lek\u00e9pezni egy m\u00e1sik gy\u0171jtem\u00e9nyre, mit is szoktunk erre haszn\u00e1lni).","title":"Feladat 2"},{"location":"ObjektumokLetrehozasa/Konstruktor/konstruktor-alapok/","text":"Konstruktor alapok \u00b6 TODO","title":"Konstruktor alapok"},{"location":"ObjektumokLetrehozasa/Konstruktor/konstruktor-alapok/#konstruktor-alapok","text":"TODO","title":"Konstruktor alapok"},{"location":"Static/static-feladatok/","text":"Statikus tagok - feladatok \u00b6 Feladat 1 \u00b6 \u00cdrj egy Matek oszt\u00e1lyt, melynek van egy Osszead \u00e9s Kivon m\u0171velete (melyek visszat\u00e9rnek k\u00e9t eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9vel, ill. k\u00fcl\u00f6nbs\u00e9g\u00e9vel). A Matek oszt\u00e1lyt k\u00e9nyelmesen lehessen haszn\u00e1lni, ne kelljen ehhez objektumokat a new-val l\u00e9trehozni. Mutass p\u00e9ld\u00e1kat a k\u00e9r m\u0171velet haszn\u00e1lat\u00e1ra. Feladat 2 \u00b6 \u00cdrj egy Bomba oszt\u00e1lyt. Minden bomb\u00e1r\u00f3l r\u00e1tolni kell a robban\u00f3erej\u00e9t (int) \u00e9s fel felrobbant-e (bool). Egy bomb\u00e1t felrobbantan a Robban m\u0171velet\u00e9vel lehet, ez a felrobbant \u00e1llapot\u00e1t igazba teszi. Az alkalmaz\u00e1sban lek\u00e9rdezhet\u0151v\u00e9 kell tenni, hogy \u00f6sszesen h\u00e1ny bomba robbant fel! Ennek nyilv\u00e1ntart\u00e1s\u00e1t/lek\u00e9rdezhet\u0151s\u00e9g\u00e9t r\u00e1 lehetne b\u00edzni egy k\u00fcl\u00f6n oszt\u00e1lyba, de a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9p\u00edtsd be mag\u00e1ba a Bomba oszt\u00e1lyba. A megold\u00e1sod teszteld a Main f\u00fcggv\u00e9nyben: hozz l\u00e9tre p\u00e1r bomb\u00e1t, robbantsd fel \u00e9s p\u00e1r helyen \u00edrd ki a felrobbant bomb\u00e1k darabsz\u00e1m\u00e1t!","title":"Statikus tagok - feladatok"},{"location":"Static/static-feladatok/#statikus-tagok-feladatok","text":"","title":"Statikus tagok - feladatok"},{"location":"Static/static-feladatok/#feladat-1","text":"\u00cdrj egy Matek oszt\u00e1lyt, melynek van egy Osszead \u00e9s Kivon m\u0171velete (melyek visszat\u00e9rnek k\u00e9t eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9vel, ill. k\u00fcl\u00f6nbs\u00e9g\u00e9vel). A Matek oszt\u00e1lyt k\u00e9nyelmesen lehessen haszn\u00e1lni, ne kelljen ehhez objektumokat a new-val l\u00e9trehozni. Mutass p\u00e9ld\u00e1kat a k\u00e9r m\u0171velet haszn\u00e1lat\u00e1ra.","title":"Feladat 1"},{"location":"Static/static-feladatok/#feladat-2","text":"\u00cdrj egy Bomba oszt\u00e1lyt. Minden bomb\u00e1r\u00f3l r\u00e1tolni kell a robban\u00f3erej\u00e9t (int) \u00e9s fel felrobbant-e (bool). Egy bomb\u00e1t felrobbantan a Robban m\u0171velet\u00e9vel lehet, ez a felrobbant \u00e1llapot\u00e1t igazba teszi. Az alkalmaz\u00e1sban lek\u00e9rdezhet\u0151v\u00e9 kell tenni, hogy \u00f6sszesen h\u00e1ny bomba robbant fel! Ennek nyilv\u00e1ntart\u00e1s\u00e1t/lek\u00e9rdezhet\u0151s\u00e9g\u00e9t r\u00e1 lehetne b\u00edzni egy k\u00fcl\u00f6n oszt\u00e1lyba, de a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9p\u00edtsd be mag\u00e1ba a Bomba oszt\u00e1lyba. A megold\u00e1sod teszteld a Main f\u00fcggv\u00e9nyben: hozz l\u00e9tre p\u00e1r bomb\u00e1t, robbantsd fel \u00e9s p\u00e1r helyen \u00edrd ki a felrobbant bomb\u00e1k darabsz\u00e1m\u00e1t!","title":"Feladat 2"},{"location":"Static/static/","text":"Statikus tagok \u00b6 Induljunk ki egy olyan oszt\u00e1lyb\u00f3l, melynek van k\u00e9t k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3ja \u00e9s tagf\u00fcggv\u00e9nye (m\u0171velete): class Teglalap { public double Szelesseg ; public double Magassag ; public double Terulet () { return Szelesseg * Magassag ; } } Az al\u00e1bbiakban l\u00e9trehozuk a Teglalap oszt\u00e1lyb\u00f3l k\u00e9t egym\u00e1st\u00f3l f\u00fcggetlen t1 \u00e9s t2 nev\u0171 t\u00e9glalap objektumot, elt\u00e9r\u0151 sz\u00e9less\u00e9g \u00e9s magass\u00e1g \u00e9rt\u00e9kekkel, majd ki\u00edrjuk ezek ter\u00fclet\u00e9t a konzolra. static void Main ( string [] args ) { Teglalap t1 = new Teglalap (); // #1 t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet () ); Teglalap t2 = new Teglalap (); // #2 t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagv\u00e1ltoz\u00f3 \u00b6 A feladat legyen a k\u00f6vetkez\u0151. Tartsuk nyilv\u00e1n egy sz\u00e1ml\u00e1l\u00f3ban, hogy h\u00e1ny objektumot hoztunk l\u00e9tre a Teglalap oszt\u00e1lyb\u00f3l. Ha b\u00e1rhol a programban l\u00e9trehozunk egy \u00faj Teglalap objektumot, akkor ennek a sz\u00e1ml\u00e1l\u00f3nak eggyel n\u0151nie kell. A fenti Main f\u00fcggv\u00e9ny p\u00e9ld\u00e1t n\u00e9zve, am\u00edg a // #1 megjegyz\u00e9ssel ell\u00e1tott sorban az objektumot nem hoztuk l\u00e9tre, addig a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ke 0, ezt k\u00f6vet\u0151en 1, majd a // #2 sor ut\u00e1n 2 kell legyen. Egy nagy, komplex alkalmaz\u00e1sban sok ezer helyen hozhatunk l\u00e9tre Teglalap objektumot, nem akarunk minden helyen sz\u00e1ml\u00e1l\u00f3t n\u00f6velni, csak egy k\u00f6zponti helyen. \u00cdgy tegy\u00fck bele ezt a sz\u00e1ml\u00e1l\u00f3t mag\u00e1ba a Teglalap oszt\u00e1lyba, \u00e9s n\u00f6velj\u00fck annak konstruktor\u00e1ban, hiszen a konstruktor pont akkor h\u00edv\u00f3dik, amikor egy \u00faj objektum l\u00e9trej\u00f6n: class Teglalap { public double Szelesseg ; public double Magassag ; public int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Ez \u00edgy m\u00e9g nem lesz j\u00f3. A probl\u00e9ma az, hogy a Szamlalo egy k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3, minden t\u00e9glalap objektumhoz k\u00fcl\u00f6n \u00e9rt\u00e9ke lesz 0 kezd\u0151\u00e9rt\u00e9kkel (a fenti p\u00e9ld\u00e1nkban a t1 \u00e9s t2 objektumokn\u00e1l k\u00fcl\u00f6n-k\u00fcl\u00f6n), pont \u00fagy, mint a Szelesseg \u00e9s Magassag tagv\u00e1ltoz\u00f3k eset\u00e9n. Ehelyett nek\u00fcnk egy olyan v\u00e1ltoz\u00f3 kell, ami nem Teglalap objektumonk\u00e9nt van, hanem minden Teglalap objektumra k\u00f6z\u00f6s, mag\u00e1hoz az oszt\u00e1lyhoz tartozik egyetlen \u00e9rt\u00e9k, \u00e9s m\u00e1r akkor is l\u00e9tezik, amikor m\u00e9g egyetlen objektumot sem hoztunk l\u00e9tre (ekkor az \u00e9rt\u00e9ke eset\u00fcnkben 0). Ehhez a Szamlalo tagot statikuss\u00e1 kell tenni, el\u00e9 kell \u00edrni a static kulcssz\u00f3t: class Teglalap { public double Szelesseg ; public double Magassag ; public static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } \u00cdgy a Szamlalo m\u00e1r az oszt\u00e1lyhoz tartozik (nem objektumonk\u00e9nt foglal\u00f3dik neki t\u00e1rhely), minden objektum\u00e1ra k\u00f6z\u00f6s, \u00e9s akkor is l\u00e9tezik, ha m\u00e9g egy Teglalap objektumot sem hoztunk l\u00e9tre. Valami ilyesmi a mem\u00f3riak\u00e9p a fenti, Main f\u00fcggv\u00e9nybeli haszn\u00e1lat sor\u00e1n: Az ilyen v\u00e1ltoz\u00f3k el\u00e9r\u00e9s\u00e9hez nem kell objektumot l\u00e9trehozni, hanem az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rj\u00fck el a \".\"-tal, a p\u00e9ld\u00e1nkban \u00edgy: Teglalap.Szamlalo A teljes p\u00e9lda, mely ki is \u00edrja t\u00f6bb helyen is a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t. static void Main ( string [] args ) { int teglalapokSzama = Teglalap . Szamlalo ; Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcgg\u00e9ny \u00b6 A megold\u00e1sunk m\u00e9g nem t\u00f6k\u00e9letes. A Szamlalo tag publikus a Teglalap oszt\u00e1lyban. \u00cdgy b\u00e1rhol valaki v\u00e9letlen vagy sz\u00e1nd\u00e9skosan elronthatja a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t, pl. ki tudja null\u00e1zni az al\u00e1bbis sorral, akkor is, ha m\u00e1r volt bel\u0151le objektum, \u00edgy \u00e9rt\u00e9ke hamis lesz: Teglalap.Szamlalo = 0; Ezt \u00fagy tudjuk megakad\u00e1lyozni, hogy a Szamlalo -t a Teglalap oszt\u00e1lyban v\u00e9dett\u00e9, priv\u00e1tt\u00e1 tessz\u00fck, ekkor ha m\u00e1s oszt\u00e1lyban pr\u00f3b\u00e1ljuk megv\u00e1ltoztatni az \u00e9rt\u00e9k\u00e9t, akkor a k\u00f3d le sem fordul (a priv\u00e1t tagokhoz csak az adott oszt\u00e1ly f\u00e9rhet hozz\u00e1, eset\u00fcnkben Teglalap , ez persze a norm\u00e1l, nem statikus tagokra is igaz). class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Most m\u00e1r nem lehet elrontani m\u00e1s oszt\u00e1lyb\u00f3l a sz\u00e1ml\u00e1l\u00f3t. De mivel private, lek\u00e9rdezni sem lehet m\u00e1r. Ez probl\u00e9ma, hiszen az pont c\u00e9lunk volt, hogy az aktu\u00e1lis sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ket le lehessen k\u00e9rdezni, b\u00e1rhonnan, pl. a Main f\u00fcggv\u00e9nyb\u0151l is, ahogy azt eddig is tett\u00fck. A megold\u00e1s egyszer\u0171: vezezz\u00fcnk be egy tagf\u00fcggv\u00e9nyt (legyen a neve SzamlaloErtek), ami publikus, \u00e9s le lehet vele k\u00e9rdezni a v\u00e9dett Szamlalo \u00e9rt\u00e9k\u00e9t: class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public static int SzamlaloErtek () { return Szamlalo ; } public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } A SzamlaloErtek tagf\u00fcggv\u00e9nyt statikuss\u00e1 is tett\u00fck a static kulcssz\u00f3val! Ez nagyon fontos, hiszen a statikus tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an csak \u00edgy tudjuk megh\u00edvni objektumok n\u00e9lk\u00fcl az oszt\u00e1ly nev\u00e9n kereszt\u00fcl (ak\u00e1r akkor is, ha m\u00e9g egy objektum sem l\u00e9tezik bel\u0151le): Teglalap.SzamlaloErtek() A Main f\u00fcggv\u00e9nyt is alak\u00edtsuk \u00e1t, hogy ezt a statikus tagf\u00fcggv\u00e9nyt haszn\u00e1lja: static void Main ( string [] args ) { int teglalapokSzama = Teglalap . SzamlaloErtek (); Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcggv\u00e9nyt m\u00e1r j\u00f3p\u00e1r alkalommal haszn\u00e1ltunk. Pl. a Console.WriteLine() eset\u00e9n. A Console egy be\u00e9p\u00edtett oszt\u00e1ly, a WriteLine ennek egy statikus tagf\u00fcggv\u00e9nye. Ha nem lenne statikus, akkor csak objektumra lehetne h\u00edvni, vagyis el\u0151bb l\u00e9tre kellene hozni a new-val egy Console objektumot, \u00edgy: Console c1 = new Console (); c1 . WriteLine (); Ez itt feleslegesen macer\u00e1s lenne, mi nem akarunk k\u00fcl\u00f6nb\u00f6z\u0151 Console objektumokkal bajl\u00f3dni. Hasonl\u00f3 a be\u00e9p\u00edtett Math oszt\u00e1ly is, ennek is egy csom\u00f3s statikus tagf\u00fcggv\u00e9nye van, \u00edgy k\u00e9nyelmesen a Math.Abs(-12) , nem kell Math objektumokat l\u00e9trehozni. Ez \u00edgy k\u00e9nyelmesebb, \u00e9s \u00e9rtelmesebb is, hiszen a Math oszt\u00e1lynak nincsenek \u00e1llapotot ad\u00f3 tagv\u00e1ltoz\u00f3i, szemben pl. a Teglalap oszt\u00e1lyunkkal, aminek van, hiszen a Szelesseg \u00e9s Magassag eset\u00e9n fontos, hogy az minden Tegalalap objektumra k\u00fcl\u00f6n t\u00e1rol\u00f3djon. Ilyen a string.Join(\",\", elemek) , ahol a '.'-t el\u0151tt a string a string oszt\u00e1ly neve (Megjegyz\u00e9s: C#-ban a kis \u00e9s nagybet\u0171vel kezd\u0151d\u0151 string / String ugyanazt jelenti.) Az alkalmaz\u00e1sok bel\u00e9p\u00e9si pontja, a Program oszt\u00e1ly Main f\u00fcgg\u00e9nye is statikus. Szab\u00e1lyok \u00b6 Fontos: Statikus tagf\u00fcggv\u00e9nyb\u0151l a norm\u00e1l (vagyis nem statikus) tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem lehet el\u00e9rni. Ezt meg kell tanulni, mert k\u00fcl\u00f6nben gyakran beleszalad az ember. De egy p\u00e9lda \u00e9rthet\u0151v\u00e9 is teszi: class Teglalap { public double Szelesseg ; public double Magassag ; public static double Terulet () { return Szelesseg * Magassag ; } } A p\u00e9ld\u00e1ban a Terulet() statikus tagf\u00fcggv\u00e9ny, ebb\u0151l pr\u00f3b\u00e1lunk el\u00e9rni k\u00e9t nem statikus tagot ( Szelesseg , \u00e9s Magassag ). Mivel a Terulet() statikus, nem objektumokre, hanem a Teglalap oszt\u00e1lyra tudjuk megh\u00edvni: double ter = Teglalap . Terulet (); A probl\u00e9ma az, hogy a Terulet() el\u0151tt nem objektum, hanem oszt\u00e1ly \u00e1ll, \u00edgy amikor a Terulet() f\u00fcggv\u00e9nyben hivatkozunk a nem statikus Szelesseg \u00e9s Magassag tagokra, akkor azok melyik t\u00e9galalap objektum sz\u00e9less\u00e9g\u00e9t \u00e9s magass\u00e1g\u00e1t is jelenten\u00e9k? M\u00e9g az is lehet, egyetlen Teglalap objektum sem l\u00e9tezik ekkor. Ha a Ter\u00fclet() h\u00edv\u00e1sakor a '.' el\u0151tt egy adott teglalap objektum \u00e1llna, akkor adn\u00e1 mag\u00e1t, de \u00edgy ennek nincs \u00e9rtelme. A m\u00e1sik ir\u00e1nyba nincs ilyen megk\u00f6t\u00e9s (ez is logikus): nem statikus tagf\u00fcggv\u00e9nyb\u0151l statikus tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket el lehet \u00e9rni. \u00d6sszefoglal\u00f3 \u00b6 A legfontosabb gondolatok A statikus tagv\u00e1ltoz\u00f3k az oszt\u00e1lyhoz tartoznak, annak minden objektum\u00e1ra k\u00f6z\u00f6sek Az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rhet\u0151k el, pl. Teglalap.Szamlalo, Teglalap.SzamlaloErtek(), Console.WriteLine(...), Math.Abs(...) Statikus tagf\u00fcggv\u00e9nyb\u0151l nem statikus tagokat nem lehet el\u00e9rni (nincs is \u00e9rtelme) A statikus tagv\u00e1ltoz\u00f3k \u00e9s tagf\u00fcggv\u00e9nyek haszn\u00e1lata sokszor k\u00e9nyelmes, de nem szabad t\u00falz\u00e1sba esni. Leggyakrabban olyan oszt\u00e1lyok eset\u00e9n haszn\u00e1ljuk, mint a Math, ahol az oszt\u00e1ly \u00e1llapottal (tagv\u00e1ltoz\u00f3kkal) nem rendelkezik, hanem csak egyszer\u0171 f\u00fcggv\u00e9nyek gy\u0171jtem\u00e9nye.","title":"Statikus tagok"},{"location":"Static/static/#statikus-tagok","text":"Induljunk ki egy olyan oszt\u00e1lyb\u00f3l, melynek van k\u00e9t k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3ja \u00e9s tagf\u00fcggv\u00e9nye (m\u0171velete): class Teglalap { public double Szelesseg ; public double Magassag ; public double Terulet () { return Szelesseg * Magassag ; } } Az al\u00e1bbiakban l\u00e9trehozuk a Teglalap oszt\u00e1lyb\u00f3l k\u00e9t egym\u00e1st\u00f3l f\u00fcggetlen t1 \u00e9s t2 nev\u0171 t\u00e9glalap objektumot, elt\u00e9r\u0151 sz\u00e9less\u00e9g \u00e9s magass\u00e1g \u00e9rt\u00e9kekkel, majd ki\u00edrjuk ezek ter\u00fclet\u00e9t a konzolra. static void Main ( string [] args ) { Teglalap t1 = new Teglalap (); // #1 t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet () ); Teglalap t2 = new Teglalap (); // #2 t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); }","title":"Statikus tagok"},{"location":"Static/static/#statikus-tagvaltozo","text":"A feladat legyen a k\u00f6vetkez\u0151. Tartsuk nyilv\u00e1n egy sz\u00e1ml\u00e1l\u00f3ban, hogy h\u00e1ny objektumot hoztunk l\u00e9tre a Teglalap oszt\u00e1lyb\u00f3l. Ha b\u00e1rhol a programban l\u00e9trehozunk egy \u00faj Teglalap objektumot, akkor ennek a sz\u00e1ml\u00e1l\u00f3nak eggyel n\u0151nie kell. A fenti Main f\u00fcggv\u00e9ny p\u00e9ld\u00e1t n\u00e9zve, am\u00edg a // #1 megjegyz\u00e9ssel ell\u00e1tott sorban az objektumot nem hoztuk l\u00e9tre, addig a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ke 0, ezt k\u00f6vet\u0151en 1, majd a // #2 sor ut\u00e1n 2 kell legyen. Egy nagy, komplex alkalmaz\u00e1sban sok ezer helyen hozhatunk l\u00e9tre Teglalap objektumot, nem akarunk minden helyen sz\u00e1ml\u00e1l\u00f3t n\u00f6velni, csak egy k\u00f6zponti helyen. \u00cdgy tegy\u00fck bele ezt a sz\u00e1ml\u00e1l\u00f3t mag\u00e1ba a Teglalap oszt\u00e1lyba, \u00e9s n\u00f6velj\u00fck annak konstruktor\u00e1ban, hiszen a konstruktor pont akkor h\u00edv\u00f3dik, amikor egy \u00faj objektum l\u00e9trej\u00f6n: class Teglalap { public double Szelesseg ; public double Magassag ; public int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Ez \u00edgy m\u00e9g nem lesz j\u00f3. A probl\u00e9ma az, hogy a Szamlalo egy k\u00f6z\u00f6ns\u00e9ges tagv\u00e1ltoz\u00f3, minden t\u00e9glalap objektumhoz k\u00fcl\u00f6n \u00e9rt\u00e9ke lesz 0 kezd\u0151\u00e9rt\u00e9kkel (a fenti p\u00e9ld\u00e1nkban a t1 \u00e9s t2 objektumokn\u00e1l k\u00fcl\u00f6n-k\u00fcl\u00f6n), pont \u00fagy, mint a Szelesseg \u00e9s Magassag tagv\u00e1ltoz\u00f3k eset\u00e9n. Ehelyett nek\u00fcnk egy olyan v\u00e1ltoz\u00f3 kell, ami nem Teglalap objektumonk\u00e9nt van, hanem minden Teglalap objektumra k\u00f6z\u00f6s, mag\u00e1hoz az oszt\u00e1lyhoz tartozik egyetlen \u00e9rt\u00e9k, \u00e9s m\u00e1r akkor is l\u00e9tezik, amikor m\u00e9g egyetlen objektumot sem hoztunk l\u00e9tre (ekkor az \u00e9rt\u00e9ke eset\u00fcnkben 0). Ehhez a Szamlalo tagot statikuss\u00e1 kell tenni, el\u00e9 kell \u00edrni a static kulcssz\u00f3t: class Teglalap { public double Szelesseg ; public double Magassag ; public static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } \u00cdgy a Szamlalo m\u00e1r az oszt\u00e1lyhoz tartozik (nem objektumonk\u00e9nt foglal\u00f3dik neki t\u00e1rhely), minden objektum\u00e1ra k\u00f6z\u00f6s, \u00e9s akkor is l\u00e9tezik, ha m\u00e9g egy Teglalap objektumot sem hoztunk l\u00e9tre. Valami ilyesmi a mem\u00f3riak\u00e9p a fenti, Main f\u00fcggv\u00e9nybeli haszn\u00e1lat sor\u00e1n: Az ilyen v\u00e1ltoz\u00f3k el\u00e9r\u00e9s\u00e9hez nem kell objektumot l\u00e9trehozni, hanem az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rj\u00fck el a \".\"-tal, a p\u00e9ld\u00e1nkban \u00edgy: Teglalap.Szamlalo A teljes p\u00e9lda, mely ki is \u00edrja t\u00f6bb helyen is a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t. static void Main ( string [] args ) { int teglalapokSzama = Teglalap . Szamlalo ; Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . Szamlalo ); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); }","title":"Statikus tagv\u00e1ltoz\u00f3"},{"location":"Static/static/#statikus-tagfuggeny","text":"A megold\u00e1sunk m\u00e9g nem t\u00f6k\u00e9letes. A Szamlalo tag publikus a Teglalap oszt\u00e1lyban. \u00cdgy b\u00e1rhol valaki v\u00e9letlen vagy sz\u00e1nd\u00e9skosan elronthatja a sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9k\u00e9t, pl. ki tudja null\u00e1zni az al\u00e1bbis sorral, akkor is, ha m\u00e1r volt bel\u0151le objektum, \u00edgy \u00e9rt\u00e9ke hamis lesz: Teglalap.Szamlalo = 0; Ezt \u00fagy tudjuk megakad\u00e1lyozni, hogy a Szamlalo -t a Teglalap oszt\u00e1lyban v\u00e9dett\u00e9, priv\u00e1tt\u00e1 tessz\u00fck, ekkor ha m\u00e1s oszt\u00e1lyban pr\u00f3b\u00e1ljuk megv\u00e1ltoztatni az \u00e9rt\u00e9k\u00e9t, akkor a k\u00f3d le sem fordul (a priv\u00e1t tagokhoz csak az adott oszt\u00e1ly f\u00e9rhet hozz\u00e1, eset\u00fcnkben Teglalap , ez persze a norm\u00e1l, nem statikus tagokra is igaz). class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } Most m\u00e1r nem lehet elrontani m\u00e1s oszt\u00e1lyb\u00f3l a sz\u00e1ml\u00e1l\u00f3t. De mivel private, lek\u00e9rdezni sem lehet m\u00e1r. Ez probl\u00e9ma, hiszen az pont c\u00e9lunk volt, hogy az aktu\u00e1lis sz\u00e1ml\u00e1l\u00f3 \u00e9rt\u00e9ket le lehessen k\u00e9rdezni, b\u00e1rhonnan, pl. a Main f\u00fcggv\u00e9nyb\u0151l is, ahogy azt eddig is tett\u00fck. A megold\u00e1s egyszer\u0171: vezezz\u00fcnk be egy tagf\u00fcggv\u00e9nyt (legyen a neve SzamlaloErtek), ami publikus, \u00e9s le lehet vele k\u00e9rdezni a v\u00e9dett Szamlalo \u00e9rt\u00e9k\u00e9t: class Teglalap { public double Szelesseg ; public double Magassag ; private static int Szamlalo ; public static int SzamlaloErtek () { return Szamlalo ; } public Teglalap () { Szamlalo ++; } public double Terulet () { return Szelesseg * Magassag ; } } A SzamlaloErtek tagf\u00fcggv\u00e9nyt statikuss\u00e1 is tett\u00fck a static kulcssz\u00f3val! Ez nagyon fontos, hiszen a statikus tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an csak \u00edgy tudjuk megh\u00edvni objektumok n\u00e9lk\u00fcl az oszt\u00e1ly nev\u00e9n kereszt\u00fcl (ak\u00e1r akkor is, ha m\u00e9g egy objektum sem l\u00e9tezik bel\u0151le): Teglalap.SzamlaloErtek() A Main f\u00fcggv\u00e9nyt is alak\u00edtsuk \u00e1t, hogy ezt a statikus tagf\u00fcggv\u00e9nyt haszn\u00e1lja: static void Main ( string [] args ) { int teglalapokSzama = Teglalap . SzamlaloErtek (); Console . WriteLine ( teglalapokSzama ); // 0-t \u00edr ki Teglalap t1 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 1-et \u00edr ki t1 . Szelesseg = 10 ; t1 . Magassag = 20 ; Console . WriteLine ( t1 . Terulet ()); Teglalap t2 = new Teglalap (); Console . WriteLine ( Teglalap . SzamlaloErtek ()); // 2-t \u00edr ki t2 . Szelesseg = 20 ; t2 . Magassag = 30 ; Console . WriteLine ( t2 . Terulet ()); } Statikus tagf\u00fcggv\u00e9nyt m\u00e1r j\u00f3p\u00e1r alkalommal haszn\u00e1ltunk. Pl. a Console.WriteLine() eset\u00e9n. A Console egy be\u00e9p\u00edtett oszt\u00e1ly, a WriteLine ennek egy statikus tagf\u00fcggv\u00e9nye. Ha nem lenne statikus, akkor csak objektumra lehetne h\u00edvni, vagyis el\u0151bb l\u00e9tre kellene hozni a new-val egy Console objektumot, \u00edgy: Console c1 = new Console (); c1 . WriteLine (); Ez itt feleslegesen macer\u00e1s lenne, mi nem akarunk k\u00fcl\u00f6nb\u00f6z\u0151 Console objektumokkal bajl\u00f3dni. Hasonl\u00f3 a be\u00e9p\u00edtett Math oszt\u00e1ly is, ennek is egy csom\u00f3s statikus tagf\u00fcggv\u00e9nye van, \u00edgy k\u00e9nyelmesen a Math.Abs(-12) , nem kell Math objektumokat l\u00e9trehozni. Ez \u00edgy k\u00e9nyelmesebb, \u00e9s \u00e9rtelmesebb is, hiszen a Math oszt\u00e1lynak nincsenek \u00e1llapotot ad\u00f3 tagv\u00e1ltoz\u00f3i, szemben pl. a Teglalap oszt\u00e1lyunkkal, aminek van, hiszen a Szelesseg \u00e9s Magassag eset\u00e9n fontos, hogy az minden Tegalalap objektumra k\u00fcl\u00f6n t\u00e1rol\u00f3djon. Ilyen a string.Join(\",\", elemek) , ahol a '.'-t el\u0151tt a string a string oszt\u00e1ly neve (Megjegyz\u00e9s: C#-ban a kis \u00e9s nagybet\u0171vel kezd\u0151d\u0151 string / String ugyanazt jelenti.) Az alkalmaz\u00e1sok bel\u00e9p\u00e9si pontja, a Program oszt\u00e1ly Main f\u00fcgg\u00e9nye is statikus.","title":"Statikus tagf\u00fcgg\u00e9ny"},{"location":"Static/static/#szabalyok","text":"Fontos: Statikus tagf\u00fcggv\u00e9nyb\u0151l a norm\u00e1l (vagyis nem statikus) tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem lehet el\u00e9rni. Ezt meg kell tanulni, mert k\u00fcl\u00f6nben gyakran beleszalad az ember. De egy p\u00e9lda \u00e9rthet\u0151v\u00e9 is teszi: class Teglalap { public double Szelesseg ; public double Magassag ; public static double Terulet () { return Szelesseg * Magassag ; } } A p\u00e9ld\u00e1ban a Terulet() statikus tagf\u00fcggv\u00e9ny, ebb\u0151l pr\u00f3b\u00e1lunk el\u00e9rni k\u00e9t nem statikus tagot ( Szelesseg , \u00e9s Magassag ). Mivel a Terulet() statikus, nem objektumokre, hanem a Teglalap oszt\u00e1lyra tudjuk megh\u00edvni: double ter = Teglalap . Terulet (); A probl\u00e9ma az, hogy a Terulet() el\u0151tt nem objektum, hanem oszt\u00e1ly \u00e1ll, \u00edgy amikor a Terulet() f\u00fcggv\u00e9nyben hivatkozunk a nem statikus Szelesseg \u00e9s Magassag tagokra, akkor azok melyik t\u00e9galalap objektum sz\u00e9less\u00e9g\u00e9t \u00e9s magass\u00e1g\u00e1t is jelenten\u00e9k? M\u00e9g az is lehet, egyetlen Teglalap objektum sem l\u00e9tezik ekkor. Ha a Ter\u00fclet() h\u00edv\u00e1sakor a '.' el\u0151tt egy adott teglalap objektum \u00e1llna, akkor adn\u00e1 mag\u00e1t, de \u00edgy ennek nincs \u00e9rtelme. A m\u00e1sik ir\u00e1nyba nincs ilyen megk\u00f6t\u00e9s (ez is logikus): nem statikus tagf\u00fcggv\u00e9nyb\u0151l statikus tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket el lehet \u00e9rni.","title":"Szab\u00e1lyok"},{"location":"Static/static/#osszefoglalo","text":"A legfontosabb gondolatok A statikus tagv\u00e1ltoz\u00f3k az oszt\u00e1lyhoz tartoznak, annak minden objektum\u00e1ra k\u00f6z\u00f6sek Az oszt\u00e1ly nev\u00e9n kereszt\u00fcl \u00e9rhet\u0151k el, pl. Teglalap.Szamlalo, Teglalap.SzamlaloErtek(), Console.WriteLine(...), Math.Abs(...) Statikus tagf\u00fcggv\u00e9nyb\u0151l nem statikus tagokat nem lehet el\u00e9rni (nincs is \u00e9rtelme) A statikus tagv\u00e1ltoz\u00f3k \u00e9s tagf\u00fcggv\u00e9nyek haszn\u00e1lata sokszor k\u00e9nyelmes, de nem szabad t\u00falz\u00e1sba esni. Leggyakrabban olyan oszt\u00e1lyok eset\u00e9n haszn\u00e1ljuk, mint a Math, ahol az oszt\u00e1ly \u00e1llapottal (tagv\u00e1ltoz\u00f3kkal) nem rendelkezik, hanem csak egyszer\u0171 f\u00fcggv\u00e9nyek gy\u0171jtem\u00e9nye.","title":"\u00d6sszefoglal\u00f3"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/","text":"String alapok 1 \u00b6 Feladat 1 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely megford\u00edt egy adott stringet \u00e9s visszat\u00e9r vele. Pl: ad\u00e9l ->l\u00e9da Feladat 2 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott string h\u00e1nyszor fordul el\u0151 \u00e9s visszaadja ezt a sz\u00e1mot. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * sz\u00f6veg: \"Az aut\u00f3 gyorsan ment \u00e9s lesodr\u00f3dott az \u00fatr\u00f3l. Az aut\u00f3ban \u00fcl\u0151k megr\u00e9m\u00fcltek \u00e9s kisz\u00e1lltak az aut\u00f3b\u00f3l\" * keresend\u0151: \u201eaut\u00f3\u201d A f\u00fcggv\u00e9ny kimenete: 3, hiszen h\u00e1romszor szerepel benne a keresett kifejez\u00e9s Feladat 3 \u00b6 \u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott karakter hol fordul el\u0151, \u00e9s minden el\u0151fordul\u00e1s\u00e1ra visszaadja az adott el\u0151fordul\u00e1s kezd\u0151poz\u00edci\u00f3j\u00e1t \u00e9s hossz\u00e1t. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * Sz\u00f6veg: \u201eaz aaaut\u00f3 alm\u00e1t vitt\u201d * Karakter: a A f\u00fcggv\u00e9ny kimenete: 0 poz, 1 hossz; 3 poz 3 hossz; 10 poz 1 hossz Tipp: A megold\u00e1s sor\u00e1n be kell vezetni egy oszt\u00e1lyt vagy strukt\u00far\u00e1t, mely egy el\u0151fordul\u00e1st reprezent\u00e1l (ennek megfelel\u0151en van egy Kezdopoz \u00e9s egy Hossz tagja)","title":"String alapok 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#string-alapok-1","text":"","title":"String alapok 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-1","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely megford\u00edt egy adott stringet \u00e9s visszat\u00e9r vele. Pl: ad\u00e9l ->l\u00e9da","title":"Feladat 1"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-2","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott string h\u00e1nyszor fordul el\u0151 \u00e9s visszaadja ezt a sz\u00e1mot. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * sz\u00f6veg: \"Az aut\u00f3 gyorsan ment \u00e9s lesodr\u00f3dott az \u00fatr\u00f3l. Az aut\u00f3ban \u00fcl\u0151k megr\u00e9m\u00fcltek \u00e9s kisz\u00e1lltak az aut\u00f3b\u00f3l\" * keresend\u0151: \u201eaut\u00f3\u201d A f\u00fcggv\u00e9ny kimenete: 3, hiszen h\u00e1romszor szerepel benne a keresett kifejez\u00e9s","title":"Feladat 2"},{"location":"StringAlapgyakorlatok/string-alapok-feladatcsoport-1/#feladat-3","text":"\u00cdrj egy olyan f\u00fcggv\u00e9nyt, mely egy adott sztingben megn\u00e9zi, hogy egy m\u00e1sik adott karakter hol fordul el\u0151, \u00e9s minden el\u0151fordul\u00e1s\u00e1ra visszaadja az adott el\u0151fordul\u00e1s kezd\u0151poz\u00edci\u00f3j\u00e1t \u00e9s hossz\u00e1t. Teszteld a f\u00fcggv\u00e9nyt az al\u00e1bbi bemenettel: * Sz\u00f6veg: \u201eaz aaaut\u00f3 alm\u00e1t vitt\u201d * Karakter: a A f\u00fcggv\u00e9ny kimenete: 0 poz, 1 hossz; 3 poz 3 hossz; 10 poz 1 hossz Tipp: A megold\u00e1s sor\u00e1n be kell vezetni egy oszt\u00e1lyt vagy strukt\u00far\u00e1t, mely egy el\u0151fordul\u00e1st reprezent\u00e1l (ennek megfelel\u0151en van egy Kezdopoz \u00e9s egy Hossz tagja)","title":"Feladat 3"},{"location":"StringAlapgyakorlatok/string-alapok/","text":"string immutable http://csharptk.ektf.hu/download/csharp-ekf.pdf Fontos megeml\u00edteni, hogy a C alap\u00fa nyelvekben a (backslash) karakter \u00fan.: escape szekvencia. Az s=\"C:\\hello\" karakter sorozat hib\u00e1s eredm\u00e9nyt szolg\u00e1ltat, ha el\u00e9r\u00e9si \u00fatk\u00e9nt szeretn\u00e9nk felhaszn\u00e1lni, mivel a \\h -nak nincs jelent\u00e9se, viszont a rendszer megpr\u00f3b\u00e1lja \u00e9rtelmezni. Ilyen esetekben vagy s=\"C:\\hello\" vagy s=@\"C:\\hello\" formul\u00e1t haszn\u00e1ljuk! Az els\u0131 megold\u00e1sban az els\u0131 jel elnyomja a m\u00e1sodik jel hat\u00e1s\u00e1t. A m\u00e1sodik megold\u00e1sn\u00e1l a @ jel gondoskodik arr\u00f3l, hogy az ut\u00e1na \u00edrt string a \"C:\\hello\" form\u00e1ban megmaradjon az \u00e9rt\u00e9kad\u00e1sn\u00e1l, vagy a ki\u00edr\u00f3 utas\u00edt\u00e1sokban. http://aries.ektf.hu/~hz/wiki7/mprog1ea/adattipusok A kezdeti id\u0151kben \u00fagy tal\u00e1lt\u00e1k, hogy 256 f\u00e9le karakter el\u00e9g sokmindenre el\u00e9g, ez\u00e9rt az ASCII k\u00f3dt\u00e1bla 0..255 k\u00f6z\u00f6tti sz\u00e1mk\u00f3dokat tartalmaz. Id\u0151vel ennyi karakter, szimb\u00f3lum kev\u00e9snek bizonyult, ez\u00e9rt m\u00e1sik k\u00f3dt\u00e1bl\u00e1t k\u00e9sz\u00edtettek, melyet UNICODE-nak neveznek. Ez az eredeti ASCII t\u00e1bla b\u0151v\u00edtm\u00e9ny\u00e9nek foghat\u00f3 fel. A UNICODE t\u00e1bl\u00e1zatban nem \u00e1ll meg a sorsz\u00e1moz\u00e1s 255-n\u00e9l, hanem \u00fajabb szimb\u00f3lumok felvezet\u00e9se mellett tart 65535-ig (alap UNICODE t\u00e1bla). A UNICODE k\u00f3dol\u00e1s enn\u00e9l a val\u00f3s\u00e1gban sokkal \u00f6sszetettebb, tov\u00e1bbi inform\u00e1ci\u00f3k az al\u00e1bbi linken olvashat\u00f3k. Mivel unicode sorsz\u00e1mok m\u00e1r 65535-ig tartanak, ezen sorsz\u00e1mok le\u00edr\u00e1s\u00e1ra nem el\u00e9g 1 byte, hanem 2 byte kell. A C# char t\u00edpusa a unicode k\u00f3dt\u00e1bla alapj\u00e1n m\u0171k\u00f6dik, ez\u00e9rt egy karakter\u00e9rt\u00e9k t\u00e1rol\u00e1s\u00e1hoz 2 byte-ra van sz\u00fcks\u00e9g a mem\u00f3ri\u00e1ban.","title":"String alapok"}]}